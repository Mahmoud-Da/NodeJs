*** 1- Welcome ***

## Lecture Notes – Introduction to the Complete Node Course

**Instructor:** Mosh Hamedani

### Overview

* Comprehensive and up-to-date Node.js course.
* Focuses on **modern techniques** for building applications with Node.js.
* Goal: Equip learners to become highly skilled Node developers.

### Key Points

1. **Instructor's Commitment**:

   * Designed to be the most thorough and current Node.js course available.
2. **Learning Outcome**:

   * By the end, students should be able to confidently develop modern applications using Node.js.
3. **Motivation**:

   * The course aims to turn learners into “superstar” Node developers.

### Closing of Intro

* Encouragement to start immediately: “Let’s jump in.”

*** 2- What is Node ***
## Lecture Notes – Introduction to Node.js

### 1. What is Node.js?

* **Definition**: Open-source, cross-platform runtime environment for executing JavaScript outside the browser.
* **Primary Use**: Building backend services, also called APIs (Application Programming Interfaces).

### 2. Role of Node.js in Applications

* **Client Applications**:

  * Examples: Web apps in browsers, mobile apps on devices.
  * These are the *surface layer* — what the user sees and interacts with.
* **Backend Services**:

  * Store data, send emails, push notifications, initiate workflows, etc.
  * Node.js is ideal for **highly scalable**, **data-intensive**, and **real-time** backend services.

### 3. Why Choose Node.js Over Other Backend Tools?

* **Alternative frameworks**: ASP.NET, Rails, Django, etc.
* **Advantages of Node.js**:

  1. Easy to start, good for prototyping and agile development.
  2. Capable of building **fast** and **highly scalable** production services.
  3. Used by large companies like PayPal, Uber, Netflix, Walmart.

     * PayPal case study:

       * Built twice as fast with fewer people.
       * 33% fewer lines of code.
       * 40% fewer files.
       * Double requests per second.
       * 35% lower average response time.

### 4. Additional Benefits of Node.js

* **JavaScript on both front-end and back-end**:

  * Easier for front-end developers to transition to full-stack.
  * No need to learn a new programming language.
  * Cleaner, more consistent source code (same naming conventions, tools, and best practices).
* **Largest ecosystem of open-source libraries**:

  * Nearly any feature or building block can be added using free libraries.
  * Reduces need to build from scratch, allowing focus on core application logic.

### 5. Next Topic

* Node.js architecture.


*** 3- Node Architecture ***

## Lecture Notes – What is a Runtime Environment?

### 1. Recap from Previous Video

* **Node.js**: A runtime environment for executing JavaScript code.

### 2. What is a Runtime Environment?

* **Before Node.js**:

  * JavaScript was used only for applications running inside browsers.
  * Browsers include a **JavaScript engine** that converts JavaScript into machine code.
* **Examples of JavaScript Engines**:

  * Microsoft Edge → Chakra
  * Firefox → SpiderMonkey
  * Chrome → V8
* **Browser Runtime Environment**:

  * Provides built-in objects like `window` and `document`.
  * Allows interaction with the browser environment.

### 3. The Birth of Node.js (2009)

* Created by **Ryan Dahl**.
* Idea: Execute JavaScript **outside** the browser.
* Approach:

  * Took **Google’s V8 engine** (fastest JS engine at the time).
  * Embedded it into a **C++ program**.
  * Named the program **Node**.

### 4. Node.js Runtime Environment vs Browser Runtime Environment

* Both use **V8** JavaScript engine.
* **Node.js** environment objects:

  * No `document` object.
  * Includes modules to:

    * Work with the file system.
    * Listen for network requests.
    * Perform server-side tasks not possible in browsers.
* **Browsers**: Limited to DOM manipulation, UI interaction, etc.

### 5. Common Misconceptions

* **Node.js is not a programming language**:

  * JavaScript is the language; Node is the runtime.
  * Comparing Node to C#, Ruby, etc., is incorrect.
* **Node.js is not a framework**:

  * Frameworks like ASP.NET, Rails, Django are for building applications.
  * Node provides the runtime environment, not a development framework.

### 6. Next Topic

* How Node.js works.

---

*** 4- How Node Works ***
---

## Lecture Notes – Why Node.js is Highly Scalable (Asynchronous Architecture)

### 1. Asynchronous vs Synchronous Architecture

#### **Asynchronous (Non-Blocking)** – Node.js Default

* **Metaphor**:

  * A waiter takes your order, sends it to the kitchen, and serves other tables while the chef cooks.
  * The waiter does not wait for the meal to be ready before serving others.
* **How it works in Node.js**:

  * A single thread can handle multiple requests.
  * When waiting for slow operations (e.g., database queries), the thread is freed to handle other requests.
  * Results are returned via an **event queue**.
  * Node constantly checks the event queue and processes completed tasks.

#### **Synchronous (Blocking)** – Example: ASP.NET or Rails (by default)

* **Metaphor**:

  * A waiter takes your order, gives it to the kitchen, and waits idly until the meal is ready before serving another table.
* **How it works in synchronous systems**:

  * One thread is allocated per request.
  * If the request needs to wait for a slow operation (e.g., database), the thread remains idle.
  * Large numbers of concurrent clients can cause thread exhaustion.
  * To handle more clients, more hardware is required.

---

### 2. Advantages of Node.js Asynchronous Architecture

* **Efficient resource usage**: A single thread handles many concurrent clients.
* **Scales well for**:

  * Data-intensive applications.
  * Real-time applications.
  * Apps with heavy disk or network access.
* **No extra configuration**: Asynchronous behavior is the default in Node.js.

---

### 3. Limitations of Node.js

* **Not ideal for CPU-intensive applications**:

  * Examples: Video encoding, image manipulation.
  * Reason: Single-threaded nature means CPU-heavy tasks block other clients.

---

### 4. Key Takeaways

* Node.js is asynchronous and non-blocking by default, making it highly scalable.
* Best for I/O-heavy tasks, not CPU-heavy tasks.

---

### 5. Next Topic

* Installing Node.js and building your first Node application.

---


Quotation 
*****************************************************************************
is  Asynchronous related when we type async in javascript code ?
*****************************************************************************


The **“asynchronous”** in your Node.js lecture and the `async` keyword in JavaScript are related concepts, but they’re not exactly the same thing.

Here’s how they connect and differ:

---

## 1. Asynchronous in Node.js Context (Lecture Meaning)

* Refers to **non-blocking I/O** at the architectural level.
* Node.js handles many requests without waiting for slow tasks (like database queries or file reads) to finish before moving to the next task.
* This is achieved through the **event loop** and **callback mechanisms**, not necessarily using `async`/`await`.
* Example:

  -------------------code----------------------
  const fs = require('fs');

  // Non-blocking file read
  fs.readFile('file.txt', 'utf8', (err, data) => {
    if (err) throw err;
    console.log(data);
  });
  console.log('Reading file...');
  -------------------code----------------------

---

## 2. `async` Keyword in JavaScript

* **Language feature** that lets you write asynchronous code that looks synchronous.
* Works with **Promises**.
* An `async` function **always returns a Promise**.
* Inside `async` functions, you can use `await` to pause execution until a Promise resolves.
* Example:

  -------------------code----------------------
  async function readFileAsync() {
    const fs = require('fs').promises;
    const data = await fs.readFile('file.txt', 'utf8');
    console.log(data);
  }
  readFileAsync();
  console.log('Reading file...');
  -------------------code----------------------

---

## 3. How They Relate

* Node.js **asynchronous architecture** is the reason why operations like file reading can happen without blocking other tasks.
* The `async` keyword is **just one way** to write asynchronous code in JavaScript that runs on top of this architecture.
* In Node.js, asynchronous code can be written using:

  * **Callbacks** (traditional way)
  * **Promises**
  * **async/await** (modern, cleaner syntax for Promises)

---



Quotation 
*****************************************************************************


A **Promise** in JavaScript is an object that represents the eventual **completion** or **failure** of an asynchronous operation.
Think of it like a placeholder for a value that you will get in the future.

---

## 1. Promise States

A Promise can be in one of three states:

1. **Pending** – The operation hasn’t completed yet.
2. **Fulfilled** – The operation completed successfully (resolved).
3. **Rejected** – The operation failed.

---

## 2. Very Simple Example

-------------------code----------------------
// Creating a Promise
const myPromise = new Promise((resolve, reject) => {
  let success = true; // Change to false to test rejection

  if (success) {
    resolve("Operation succeeded!");
  } else {
    reject("Operation failed!");
  }
});

// Using the Promise
myPromise
  .then(result => {
    console.log(result); // Runs if resolved
  })
  .catch(error => {
    console.error(error); // Runs if rejected
  });
-------------------code----------------------

---

### How it works:

1. The **executor function** `(resolve, reject) => { ... }` runs immediately when the Promise is created.
2. If everything goes well, call `resolve(...)` → Promise is **fulfilled**.
3. If something goes wrong, call `reject(...)` → Promise is **rejected**.
4. `.then(...)` handles the success case, `.catch(...)` handles errors.

---


Quotation 
*****************************************************************************
what is Promise?
*****************************************************************************

A **Promise** in JavaScript is an object that represents the eventual **completion** or **failure** of an asynchronous operation.
Think of it like a placeholder for a value that you will get in the future.

---

## 1. Promise States

A Promise can be in one of three states:

1. **Pending** – The operation hasn’t completed yet.
2. **Fulfilled** – The operation completed successfully (resolved).
3. **Rejected** – The operation failed.

---

## 2. Very Simple Example

-------------------code----------------------
// Creating a Promise
const myPromise = new Promise((resolve, reject) => {
  let success = true; // Change to false to test rejection

  if (success) {
    resolve("Operation succeeded!");
  } else {
    reject("Operation failed!");
  }
});

// Using the Promise
myPromise
  .then(result => {
    console.log(result); // Runs if resolved
  })
  .catch(error => {
    console.error(error); // Runs if rejected
  });
-------------------code----------------------

---

### How it works:

1. The **executor function** `(resolve, reject) => { ... }` runs immediately when the Promise is created.
2. If everything goes well, call `resolve(...)` → Promise is **fulfilled**.
3. If something goes wrong, call `reject(...)` → Promise is **rejected**.
4. `.then(...)` handles the success case, `.catch(...)` handles errors.

---


Here’s a very short and clear example of a Promise with a delay:

-------------------code----------------------
// A Promise that resolves after 2 seconds
const waitTwoSeconds = new Promise((resolve) => {
  setTimeout(() => {
    resolve("2 seconds have passed!");
  }, 2000);
});

console.log("Starting...");

waitTwoSeconds
  .then(message => {
    console.log(message); // Logs after 2 seconds
  })
  .catch(error => {
    console.error(error);
  });
-------------------code----------------------

---

**How this works:**

1. `setTimeout` waits 2000 milliseconds.
2. After the timer ends, `resolve(...)` is called.
3. `.then(...)` runs and prints the message.
4. Meanwhile, the rest of the program can keep running — it’s non-blocking.


## also rewrite this exact example using **`async/await`** so it looks like synchronous code while still being asynchronous. That will make the link between Promises and `async/await` clear.
Sure! Here’s your exact example rewritten using **`async/await`** syntax:

-------------------code----------------------
// A function that returns a Promise which resolves after 2 seconds
function waitTwoSeconds() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("2 seconds have passed!");
    }, 2000);
  });
}

async function run() {
  console.log("Starting...");
  try {
    const message = await waitTwoSeconds();
    console.log(message); // Logs after 2 seconds
  } catch (error) {
    console.error(error);
  }
}

run();
-------------------code----------------------

---

**How this works:**

1. `waitTwoSeconds()` returns a Promise that resolves after 2 seconds.
2. Inside the `async` function `run()`, the `await` keyword pauses execution until the Promise resolves.
3. After 2 seconds, the resolved message is stored in `message`.
4. The message is logged, just like in the `.then()` version.
5. The rest of the program outside `run()` can continue running without blocking.

- how `async/await` works!



---

### What is `async/await`?

* `async` and `await` are syntax in JavaScript that let you write asynchronous code in a way that *looks* and *feels* like synchronous (blocking) code, but **without blocking** the program.
* This makes asynchronous code easier to read and write, especially when you have multiple asynchronous operations that depend on each other.

---

### What is `async/await` in simple terms?

* `async` means a function always returns a Promise.
* `await` means “wait for this Promise to finish,” but **without blocking** the whole program.
* It makes your asynchronous code look like normal, easy-to-read synchronous code.


### Key points:

1. **`async` keyword**

   * When you put `async` before a function, it means the function **always returns a Promise**.
   * Inside this function, you can use the `await` keyword.

2. **`await` keyword**

   * You use `await` in front of a Promise to *pause* the execution of the `async` function until that Promise settles (resolves or rejects).
   * While the function is “paused,” other code outside the function keeps running (no blocking).

3. **Error handling**

   * You can use `try...catch` blocks inside `async` functions to catch errors from awaited Promises, just like with synchronous code.

---

### Why use `async/await`?

* It makes asynchronous code **cleaner and easier to understand** compared to chaining many `.then()` calls.
* You can write code that looks like normal sequential code but still benefits from asynchronous, non-blocking behavior.

---

### Example recap with your code:

-------------------code----------------------
async function run() {
  console.log("Starting...");
  
  try {
    const message = await waitTwoSeconds(); // Wait here without blocking
    console.log(message); // Runs after 2 seconds
  } catch (error) {
    console.error(error);
  }
}

run();
-------------------code----------------------

* `run` is an async function.
* When it hits `await waitTwoSeconds()`, it pauses until the Promise resolves.
* Once resolved, it logs the message.
* Meanwhile, other parts of your program can keep running normally.

---

*** 5- Installing Node ***

### How to Install Node.js

1. **Open your terminal or command prompt:**

   * On **Windows**, open Command Prompt.
   * On **Mac** or **Linux**, open the Terminal.

2. **Check if Node.js is already installed:**

   * Run the command:

     -------------------code----------------------
     node --version
     -------------------code----------------------
   * On the example machine, the version is `6.10.3`, which is an earlier version.
   * The latest stable version at the time of this lecture is `8.x`.

3. **If Node.js is not installed or if your version is outdated:**

   * Open your browser and go to [nodejs.org](https://nodejs.org).
   * On the homepage, you will see two versions available:

     * The **latest stable version** (recommended for most users).
     * The **latest experimental version** (may not be stable).
   * Download and install the **latest stable version**.
   * Note: This course uses core Node.js modules that are stable and consistent across versions, so the code will work on future versions as well.

4. **Installing Node.js:**

   * Download the installer package from the website.
   * Run the installer.
   * Follow the installation prompts by clicking **Continue** several times.
   * Enter your system password if prompted.
   * The installation will complete in a few seconds.

5. **Verify the installation:**

   * Go back to your terminal.
   * Run:

     -------------------code----------------------
     node --version
     -------------------code----------------------
   * Confirm that the version is now the latest stable version (e.g., `8.9.1`).

---

### Next Steps

* After installing Node.js, you will build your first Node.js application.

---

