*** 1- Introduction  ***
**Lecture Notes: Node.js Module System**

**1. Overview**

* This section introduces the **module system** in Node.js.
* It explains what **modules** are, why they are **necessary**, and how they **function**.

**2. Purpose of Modules**

* Modules help organize code into **separate, reusable components**.
* They allow developers to maintain **clean and manageable** codebases.
* Modules prevent **naming conflicts** and support **encapsulation** of functionality.

**3. Core Node.js Modules Covered**
Throughout this section, the following built-in Node.js modules will be explored:

* **Operating System (os):** Provides information about the operating system.
* **File System (fs):** Enables reading from and writing to files.
* **Events:** Allows handling and emitting of custom events.
* **HTTP:** Enables building web servers and handling HTTP requests and responses.

**4. Creating Custom Modules**

* In addition to using built-in modules, you will learn how to **create your own modules**.
* This includes **defining**, **exporting**, and **importing** custom functionality for reuse across files.

**5. Summary**

* Modules are a fundamental part of Node.js architecture.
* They make it easier to structure, maintain, and extend applications.
* Understanding both built-in and custom modules is essential for effective Node.js development.


*** 2- Global Object ***
**Lecture Notes: Global Objects in Node.js**

---

### 1. Introduction

* In the previous section, the `console.log` function was used to log messages to the console.
* The `console` object is an example of a **global object** in Node.js.
* **Global objects** are accessible **from anywhere** in your code without the need to import them.

---

### 2. Global Objects in JavaScript

* JavaScript provides several **globally available functions** and objects that can be used both:

  * In the **browser** environment.
  * In **Node.js**.

**Common examples include:**

* `setTimeout()` – Calls a function after a specified delay (e.g., 1 or 2 seconds).
* `clearTimeout()` – Cancels a timeout created with `setTimeout()`.
* `setInterval()` – Calls a function repeatedly after a given delay.
* `clearInterval()` – Stops a repeating function created with `setInterval()`.

These functions are part of the **standard JavaScript environment** and can be used in both browsers and Node.js.

---

### 3. Global Scope in Browsers

* In the browser, the **`window` object** represents the **global scope**.
* All globally declared variables and functions are accessible through the `window` object.

**Examples:**

* `window.console.log()` or simply `console.log()`

* `window.setTimeout()` or simply `setTimeout()`

* When you declare a variable, for example:

  -------------------code----------------------
  var message = "Hello";
  -------------------code----------------------

  It becomes accessible via `window.message`.

---

### 4. Global Scope in Node.js

* Node.js does **not** have the `window` object.
* Instead, it has another global object called **`global`**.

**Examples:**

* `global.console.log()`
* `global.setTimeout()`

However, in practice, developers usually omit the `global` prefix since these functions are directly accessible.

---

### 5. Difference Between Browser and Node.js Globals

* In browsers:

  * Variables defined globally are **added** to the `window` object.
  * Example:

    -------------------code----------------------
    var message = "Hello";
    console.log(window.message); // Output: Hello
    -------------------code----------------------
* In Node.js:

  * Variables defined in a file are **not** added to the `global` object.
  * They are **scoped to the specific file** (module).
  * Example:

    -------------------code----------------------
    var message = "Hello";
    console.log(global.message); // Output: undefined
    -------------------code----------------------

When running `node app.js`, the console will show `undefined`, proving that the variable is not global.

---

### 6. Reason for This Behavior

* This scoping behavior in Node.js is intentional and part of the **Node.js module system**.
* Each file in Node.js is treated as a **separate module**, meaning:

  * Variables and functions are **private** to that module.
  * They are **not automatically shared** with other files.
* This prevents naming conflicts and improves code maintainability.

---

### 7. Summary

* **Global objects** (like `console`, `setTimeout`, etc.) are available everywhere in Node.js.
* **Browsers use `window`**, while **Node.js uses `global`** as the global scope object.
* In Node.js, user-defined variables are **not attached** to `global`.
* Each file has its own **module scope**, forming the foundation of Node.js’s modular system.

---

*** 3- Modules ***
**Lecture Notes: Node.js Modules and Scope**

---

### 1. Introduction

* In client-side JavaScript (run inside browsers), any variable or function defined without special scoping is added to the **global scope**.
* For example:

  -------------------code----------------------
  function sayHello() {
    console.log("Hello");
  }
  -------------------code----------------------

  The above function becomes available globally through the **window** object.

---

### 2. Problem with the Global Scope

* In real-world applications, JavaScript code is often **split into multiple files**.
* If two files define a function with the same name (e.g., `sayHello()`), the **second definition overwrites** the first one because both share the same global scope.
* This causes:

  * Naming conflicts.
  * Unpredictable behavior.
  * Difficulties in debugging and maintenance.

---

### 3. The Need for Modularity

* To build **reliable and maintainable** applications, developers must **avoid defining variables and functions in the global scope**.
* Instead, code should be organized into **modules** — small, independent building blocks.
* Each module encapsulates its own variables and functions, preventing conflicts between files.

---

### 4. The Concept of Modules in Node.js

* **Every file** in a Node.js application is treated as a **module**.
* Variables and functions defined within a file are **scoped only to that file**.
* In object-oriented terms, these are considered **private** to that module.
* If you want to use a variable or function outside of its module, you must **explicitly export** it.

---

### 5. The Main Module

* Every Node.js application has at least one module — the **main module**.
* Typically, this is the entry file, such as `app.js`.

---

### 6. The `module` Object

* Inside any Node.js file, there is a special object called **`module`**.
* Example:

  -------------------code----------------------
  console.log(module);
  -------------------code----------------------
* When you run this (`node app.js`), it outputs a **module object** in the console.
-------------------code----------------------
Module {
  id: '.',
  path: '/Users/mahmouddabbbagh/moody/NodeJs/2-Node-Module-System',
  exports: {},
  filename: '/Users/mahmouddabbbagh/moody/NodeJs/2-Node-Module-System/app3.js',
  loaded: false,
  children: [],
  paths: [
    '/Users/mahmouddabbbagh/moody/NodeJs/2-Node-Module-System/node_modules',
    '/Users/mahmouddabbbagh/moody/NodeJs/node_modules',
    '/Users/mahmouddabbbagh/moody/node_modules',
    '/Users/mahmouddabbbagh/node_modules',
    '/Users/node_modules',
    '/node_modules'
  ]
}
-------------------code----------------------

**Properties of the `module` object include:**

| Property     | Description                                                  |
| ------------ | ------------------------------------------------------------ |
| **id**       | Unique identifier of the module                              |
| **exports**  | Object that determines what is accessible outside the module |
| **parent**   | References the module that imported this one                 |
| **filename** | Full path of the current file                                |
| **loaded**   | Boolean indicating if the module has finished loading        |
| **children** | List of modules imported by this module                      |
| **paths**    | Lookup paths for module resolution                           |

---

### 7. Important Clarification

* The `module` object may **appear global**, but it is **not** part of the global scope.
* Unlike `console` or `setTimeout`, it cannot be accessed via the `global` object.
* Each file has its own instance of the `module` object, specific to that file’s context.

---

### 8. Summary

* **In browsers:** variables and functions defined globally are attached to the `window` object.
* **In Node.js:** each file is a **module**, and its variables/functions are **private** to that module.
* To share functionality, you must **explicitly export** and **import** between modules.
* Understanding this modular structure is key to writing scalable, conflict-free Node.js applications.

---

*** 4- Creating a Module ***
**Lecture Notes: Creating and Exporting a Module in Node.js**

---

### 1. Introduction

* In this section, we add a **new module** to the Node.js application.
* The module will be created in a new file named **`logger.js`**.
* The goal is to demonstrate how to define a module, export its functionality, and use it in another file (the main module, `app.js`).

---

### 2. Creating the Logger Module

**File:** `logger.js`

* This module will simulate a **logging service** that records messages.
* In a real-world scenario, such a module could connect to a **remote logging service** via HTTP requests.
* For simplicity, this example logs messages to the console instead.

**Example Code:**

-------------------code----------------------
// logger.js

// A pretend endpoint for logging messages
var url = 'http://mylogger.io/log';

// Function that logs a message
function log(message) {
  console.log(message);
}
-------------------code----------------------

* Both the `url` variable and the `log` function are **scoped to this module**.
* They are **private** and **not accessible** outside `logger.js` by default.

---

### 3. Making the Module Public (Exporting)

* To use the `log` function in another file (such as `app.js`), it must be **exported**.
* Node.js provides the **`module.exports`** object for this purpose.
* Anything assigned to `module.exports` becomes **publicly accessible** to other files that import this module.

**Example:**

-------------------code----------------------
module.exports.log = log;
-------------------code----------------------

* The above code adds a property `log` to the exported object and sets it to the `log` function.
* This means that when another file imports this module, it can call `logger.log()`.

---

### 4. Exporting Multiple Members

* You can export multiple members (variables or functions) by attaching them to `module.exports`.

**Example:**

-------------------code----------------------
module.exports.log = log;
module.exports.url = url;
-------------------code----------------------

* However, not everything needs to be exported.
* In this example, `url` is **internal implementation detail** and does not need to be accessed from other modules.

**Renaming During Export:**

-------------------code----------------------
module.exports.endpoint = url;
-------------------code----------------------

* You can choose to rename an exported variable to make the external interface clearer.

---

### 5. The Concept of Public vs Private Members

* **Private Members:**
  Defined inside the module and **not exported** (e.g., `url`).
* **Public Members:**
  Explicitly exported via `module.exports` (e.g., `log()`).

**Metaphor:**

* A **DVD player** has buttons on the outside (public interface) and complex internal components (private implementation).
* Similarly, modules expose only essential functions or variables, hiding internal details.

---

### 6. Summary of the Logger Module

* The `logger.js` module defines:

  * A private variable: `url`
  * A public function: `log(message)`
* It exports the `log` function using `module.exports.log = log;`.
* This design ensures that only necessary functionality is exposed, keeping the module simple and stable.

---

### 7. Next Step

* After completing `logger.js`, the next step is to **load** and **use** this module in the main application file `app.js`.
* This is done using the **`require()`** function, which imports modules into a Node.js file.

---

*** 5- Loading a Module ***
**Lecture Notes: Loading and Using Modules in Node.js**

---

### 1. Introduction to the `require()` Function

* In Node.js, modules are loaded using the **`require()`** function.
* `require()` is **specific to Node.js** and does **not exist** in browsers.
* It allows one file (module) to import functionality that another module has exported.

---

### 2. Syntax and Usage

**Syntax:**

-------------------code----------------------
require('module_name_or_path');
-------------------code----------------------

* The `require()` function takes **one argument** — the **name or path** of the target module.
* The path can be:

  * **Relative path:** for local modules (e.g., `./logger`)
  * **Parent directory path:** using `../`
  * **Module name:** for built-in or installed modules

**Example (loading a local module):**

-------------------code----------------------
const logger = require('./logger');
-------------------code----------------------

---

### 3. Understanding Relative Paths

* `./` indicates the **current folder**.
* `../` refers to the **parent folder**.

**Examples:**

-------------------code----------------------
require('./logger');        // Same directory
require('./subfolder/logger'); // Inside subfolder
require('../logger');       // Parent directory
-------------------code----------------------

* The `.js` extension is **optional**; Node.js automatically assumes it’s a JavaScript file.

---

### 4. What `require()` Returns

* The `require()` function returns the **`module.exports`** object from the target module.
* This means that whatever is exported in the target file becomes accessible in the importing file.

**Example:**

-------------------code----------------------
// app.js
const logger = require('./logger');
console.log(logger);
-------------------code----------------------

* When executed (`node app.js`), this prints:

  -------------------code----------------------
  { log: [Function: log] }
  -------------------code----------------------
* You can now call the exported function:

  -------------------code----------------------
  logger.log('Message');
  -------------------code----------------------

---

### 5. Using Constants for Module Imports

* It’s a **best practice** to store the imported module in a **constant** rather than a variable.

**Example:**

-------------------code----------------------
const logger = require('./logger');
-------------------code----------------------

* Using `const` prevents accidental reassignment:

  -------------------code----------------------
  logger = 1; // Error: Assignment to constant variable
  -------------------code----------------------
* This helps prevent runtime errors like:

  -------------------code----------------------
  TypeError: logger.log is not a function
  -------------------code----------------------

---

### 6. Detecting Errors with Tools like JSHint

* **JSHint** is a popular tool for detecting JavaScript errors and bad practices.
* Running:

  -------------------code----------------------bash
  jshint app.js
  -------------------code----------------------

  may show warnings such as:

  -------------------code----------------------
  Attempting to overwrite logger, which is a constant
  -------------------code----------------------
* These tools help catch problems **before** the program runs.

---

### 7. Exporting a Single Function Instead of an Object

* When a module only needs to expose a single function, you can **export the function directly** instead of using an object.

**Original:**

-------------------code----------------------
// logger.js
function log(message) {
  console.log(message);
}

module.exports.log = log;
-------------------code----------------------

**Simplified Version:**

-------------------code----------------------
// logger.js
function log(message) {
  console.log(message);
}

module.exports = log;
-------------------code----------------------

**Usage in `app.js`:**

-------------------code----------------------
const log = require('./logger');
log('Message');
-------------------code----------------------

* In this case, `require('./logger')` returns the **function itself**, not an object.

---

### 8. Summary

| Concept           | Description                                                                         |
| ----------------- | ----------------------------------------------------------------------------------- |
| **`require()`**   | Used to import modules in Node.js                                                   |
| **Argument**      | Path or name of the module to load                                                  |
| **Return Value**  | The exported object or function from the module                                     |
| **Best Practice** | Use `const` when storing imported modules                                           |
| **Tools**         | Use linters like **JSHint** to detect assignment or syntax errors                   |
| **Export Types**  | You can export either an **object** (for multiple members) or a **single function** |

---

### 9. Key Takeaways

* `require()` loads and links modules into your application.
* `module.exports` defines what a module makes available externally.
* Using `const` improves safety by preventing unintended reassignment.
* Modules can export **objects** (for multiple exports) or **functions** (for single exports).
* This modular structure keeps Node.js applications organized, reusable, and maintainable.

---

*** 6- Module Wrapper Function ***
### Lecture Notes: How Node.js Wraps Modules

---

#### 1. **Scope of Variables and Functions in Modules**

* In Node.js, any variable or function defined inside a module is **scoped only to that module**.
* These variables and functions are **private** and **not visible outside** the file unless explicitly exported.
* This encapsulation helps prevent naming conflicts between different files.

---

#### 2. **How Node.js Implements Module Scope**

* Node does **not execute the contents of a module directly**.
* Instead, it **wraps each module’s code inside a function** before execution.
* This hidden function is known as the **Module Wrapper Function**.

Example (conceptual representation):

-------------------code----------------------
(function (exports, require, module, __filename, __dirname) {
  var url = "http://mylogger.io/log";

  function log(message) {
    console.log(message);
  }
  
  module.exports = log;

});
-------------------code----------------------

* When Node executes a file, it wraps the entire code within this function.
* This makes variables and functions **local** to the module, not global.

---

#### 3. **Demonstration of the Wrapper Function**

* By intentionally creating a syntax error at the top of a module, Node shows the internal wrapper function in the error message.
* Example error message reveals:

  -------------------code----------------------
  function (exports, require, module, __filename, __dirname) {
  -------------------code----------------------
* This proves Node wraps every file inside a function before executing it.

---

#### 4. **Parameters Passed to the Wrapper Function**

Each module receives five parameters automatically:

1. **`exports`** – A shortcut reference to `module.exports`.
2. **`require`** – A function to import other modules.
3. **`module`** – Represents the current module and its metadata.
4. **`__filename`** – The absolute path of the current module file.
5. **`__dirname`** – The absolute path of the directory containing the current module.

Example:

-------------------code----------------------
console.log(__filename);
console.log(__dirname);
-------------------code----------------------

Output:

-------------------code----------------------
/path/to/logger.js
/path/to
-------------------code----------------------

---

#### 5. **Relationship Between `exports` and `module.exports`**

* Both refer to the same object initially:

  -------------------code----------------------
  exports.log = function() { };
  // is equivalent to
  module.exports.log = function() { };
  -------------------code----------------------
* However:

  * You **can modify properties** on `exports`.
  * You **cannot reassign** `exports` directly (e.g., `exports = log`) because that breaks the reference to `module.exports`.

---

#### 6. **Purpose of the Wrapper Function**

* Keeps module variables private.
* Provides access to:

  * `require` for importing other modules.
  * `exports` and `module.exports` for exporting functionality.
  * File and directory metadata (`__filename`, `__dirname`).

---

#### 7. **Summary**

* Node wraps each module in a function called the **Module Wrapper Function**.
* This ensures that:

  * Variables and functions inside a file are **not global**.
  * Each file has its own local scope.
* The wrapper passes important objects like `exports`, `require`, `module`, `__filename`, and `__dirname`.
* Understanding this mechanism helps explain how Node manages module isolation and scope safely.
