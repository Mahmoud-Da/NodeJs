*** 1- Introduction  ***
**Lecture Notes: Node.js Module System**

**1. Overview**

* This section introduces the **module system** in Node.js.
* It explains what **modules** are, why they are **necessary**, and how they **function**.

**2. Purpose of Modules**

* Modules help organize code into **separate, reusable components**.
* They allow developers to maintain **clean and manageable** codebases.
* Modules prevent **naming conflicts** and support **encapsulation** of functionality.

**3. Core Node.js Modules Covered**
Throughout this section, the following built-in Node.js modules will be explored:

* **Operating System (os):** Provides information about the operating system.
* **File System (fs):** Enables reading from and writing to files.
* **Events:** Allows handling and emitting of custom events.
* **HTTP:** Enables building web servers and handling HTTP requests and responses.

**4. Creating Custom Modules**

* In addition to using built-in modules, you will learn how to **create your own modules**.
* This includes **defining**, **exporting**, and **importing** custom functionality for reuse across files.

**5. Summary**

* Modules are a fundamental part of Node.js architecture.
* They make it easier to structure, maintain, and extend applications.
* Understanding both built-in and custom modules is essential for effective Node.js development.


*** 2- Global Object ***
**Lecture Notes: Global Objects in Node.js**

---

### 1. Introduction

* In the previous section, the `console.log` function was used to log messages to the console.
* The `console` object is an example of a **global object** in Node.js.
* **Global objects** are accessible **from anywhere** in your code without the need to import them.

---

### 2. Global Objects in JavaScript

* JavaScript provides several **globally available functions** and objects that can be used both:

  * In the **browser** environment.
  * In **Node.js**.

**Common examples include:**

* `setTimeout()` – Calls a function after a specified delay (e.g., 1 or 2 seconds).
* `clearTimeout()` – Cancels a timeout created with `setTimeout()`.
* `setInterval()` – Calls a function repeatedly after a given delay.
* `clearInterval()` – Stops a repeating function created with `setInterval()`.

These functions are part of the **standard JavaScript environment** and can be used in both browsers and Node.js.

---

### 3. Global Scope in Browsers

* In the browser, the **`window` object** represents the **global scope**.
* All globally declared variables and functions are accessible through the `window` object.

**Examples:**

* `window.console.log()` or simply `console.log()`

* `window.setTimeout()` or simply `setTimeout()`

* When you declare a variable, for example:

  -------------------code----------------------
  var message = "Hello";
  -------------------code----------------------

  It becomes accessible via `window.message`.

---

### 4. Global Scope in Node.js

* Node.js does **not** have the `window` object.
* Instead, it has another global object called **`global`**.

**Examples:**

* `global.console.log()`
* `global.setTimeout()`

However, in practice, developers usually omit the `global` prefix since these functions are directly accessible.

---

### 5. Difference Between Browser and Node.js Globals

* In browsers:

  * Variables defined globally are **added** to the `window` object.
  * Example:

    -------------------code----------------------
    var message = "Hello";
    console.log(window.message); // Output: Hello
    -------------------code----------------------
* In Node.js:

  * Variables defined in a file are **not** added to the `global` object.
  * They are **scoped to the specific file** (module).
  * Example:

    -------------------code----------------------
    var message = "Hello";
    console.log(global.message); // Output: undefined
    -------------------code----------------------

When running `node app.js`, the console will show `undefined`, proving that the variable is not global.

---

### 6. Reason for This Behavior

* This scoping behavior in Node.js is intentional and part of the **Node.js module system**.
* Each file in Node.js is treated as a **separate module**, meaning:

  * Variables and functions are **private** to that module.
  * They are **not automatically shared** with other files.
* This prevents naming conflicts and improves code maintainability.

---

### 7. Summary

* **Global objects** (like `console`, `setTimeout`, etc.) are available everywhere in Node.js.
* **Browsers use `window`**, while **Node.js uses `global`** as the global scope object.
* In Node.js, user-defined variables are **not attached** to `global`.
* Each file has its own **module scope**, forming the foundation of Node.js’s modular system.

---

*** 3- Modules ***
**Lecture Notes: Node.js Modules and Scope**

---

### 1. Introduction

* In client-side JavaScript (run inside browsers), any variable or function defined without special scoping is added to the **global scope**.
* For example:

  -------------------code----------------------
  function sayHello() {
    console.log("Hello");
  }
  -------------------code----------------------

  The above function becomes available globally through the **window** object.

---

### 2. Problem with the Global Scope

* In real-world applications, JavaScript code is often **split into multiple files**.
* If two files define a function with the same name (e.g., `sayHello()`), the **second definition overwrites** the first one because both share the same global scope.
* This causes:

  * Naming conflicts.
  * Unpredictable behavior.
  * Difficulties in debugging and maintenance.

---

### 3. The Need for Modularity

* To build **reliable and maintainable** applications, developers must **avoid defining variables and functions in the global scope**.
* Instead, code should be organized into **modules** — small, independent building blocks.
* Each module encapsulates its own variables and functions, preventing conflicts between files.

---

### 4. The Concept of Modules in Node.js

* **Every file** in a Node.js application is treated as a **module**.
* Variables and functions defined within a file are **scoped only to that file**.
* In object-oriented terms, these are considered **private** to that module.
* If you want to use a variable or function outside of its module, you must **explicitly export** it.

---

### 5. The Main Module

* Every Node.js application has at least one module — the **main module**.
* Typically, this is the entry file, such as `app.js`.

---

### 6. The `module` Object

* Inside any Node.js file, there is a special object called **`module`**.
* Example:

  -------------------code----------------------
  console.log(module);
  -------------------code----------------------
* When you run this (`node app.js`), it outputs a **module object** in the console.
-------------------code----------------------
Module {
  id: '.',
  path: '/Users/mahmouddabbbagh/moody/NodeJs/2-Node-Module-System',
  exports: {},
  filename: '/Users/mahmouddabbbagh/moody/NodeJs/2-Node-Module-System/app3.js',
  loaded: false,
  children: [],
  paths: [
    '/Users/mahmouddabbbagh/moody/NodeJs/2-Node-Module-System/node_modules',
    '/Users/mahmouddabbbagh/moody/NodeJs/node_modules',
    '/Users/mahmouddabbbagh/moody/node_modules',
    '/Users/mahmouddabbbagh/node_modules',
    '/Users/node_modules',
    '/node_modules'
  ]
}
-------------------code----------------------

**Properties of the `module` object include:**

| Property     | Description                                                  |
| ------------ | ------------------------------------------------------------ |
| **id**       | Unique identifier of the module                              |
| **exports**  | Object that determines what is accessible outside the module |
| **parent**   | References the module that imported this one                 |
| **filename** | Full path of the current file                                |
| **loaded**   | Boolean indicating if the module has finished loading        |
| **children** | List of modules imported by this module                      |
| **paths**    | Lookup paths for module resolution                           |

---

### 7. Important Clarification

* The `module` object may **appear global**, but it is **not** part of the global scope.
* Unlike `console` or `setTimeout`, it cannot be accessed via the `global` object.
* Each file has its own instance of the `module` object, specific to that file’s context.

---

### 8. Summary

* **In browsers:** variables and functions defined globally are attached to the `window` object.
* **In Node.js:** each file is a **module**, and its variables/functions are **private** to that module.
* To share functionality, you must **explicitly export** and **import** between modules.
* Understanding this modular structure is key to writing scalable, conflict-free Node.js applications.

---

*** 4- Creating a Module ***
**Lecture Notes: Creating and Exporting a Module in Node.js**

---

### 1. Introduction

* In this section, we add a **new module** to the Node.js application.
* The module will be created in a new file named **`logger.js`**.
* The goal is to demonstrate how to define a module, export its functionality, and use it in another file (the main module, `app.js`).

---

### 2. Creating the Logger Module

**File:** `logger.js`

* This module will simulate a **logging service** that records messages.
* In a real-world scenario, such a module could connect to a **remote logging service** via HTTP requests.
* For simplicity, this example logs messages to the console instead.

**Example Code:**

-------------------code----------------------
// logger.js

// A pretend endpoint for logging messages
var url = 'http://mylogger.io/log';

// Function that logs a message
function log(message) {
  console.log(message);
}
-------------------code----------------------

* Both the `url` variable and the `log` function are **scoped to this module**.
* They are **private** and **not accessible** outside `logger.js` by default.

---

### 3. Making the Module Public (Exporting)

* To use the `log` function in another file (such as `app.js`), it must be **exported**.
* Node.js provides the **`module.exports`** object for this purpose.
* Anything assigned to `module.exports` becomes **publicly accessible** to other files that import this module.

**Example:**

-------------------code----------------------
module.exports.log = log;
-------------------code----------------------

* The above code adds a property `log` to the exported object and sets it to the `log` function.
* This means that when another file imports this module, it can call `logger.log()`.

---

### 4. Exporting Multiple Members

* You can export multiple members (variables or functions) by attaching them to `module.exports`.

**Example:**

-------------------code----------------------
module.exports.log = log;
module.exports.url = url;
-------------------code----------------------

* However, not everything needs to be exported.
* In this example, `url` is **internal implementation detail** and does not need to be accessed from other modules.

**Renaming During Export:**

-------------------code----------------------
module.exports.endpoint = url;
-------------------code----------------------

* You can choose to rename an exported variable to make the external interface clearer.

---

### 5. The Concept of Public vs Private Members

* **Private Members:**
  Defined inside the module and **not exported** (e.g., `url`).
* **Public Members:**
  Explicitly exported via `module.exports` (e.g., `log()`).

**Metaphor:**

* A **DVD player** has buttons on the outside (public interface) and complex internal components (private implementation).
* Similarly, modules expose only essential functions or variables, hiding internal details.

---

### 6. Summary of the Logger Module

* The `logger.js` module defines:

  * A private variable: `url`
  * A public function: `log(message)`
* It exports the `log` function using `module.exports.log = log;`.
* This design ensures that only necessary functionality is exposed, keeping the module simple and stable.

---

### 7. Next Step

* After completing `logger.js`, the next step is to **load** and **use** this module in the main application file `app.js`.
* This is done using the **`require()`** function, which imports modules into a Node.js file.

---

*** 5- Loading a Module ***
**Lecture Notes: Loading and Using Modules in Node.js**

---

### 1. Introduction to the `require()` Function

* In Node.js, modules are loaded using the **`require()`** function.
* `require()` is **specific to Node.js** and does **not exist** in browsers.
* It allows one file (module) to import functionality that another module has exported.

---

### 2. Syntax and Usage

**Syntax:**

-------------------code----------------------
require('module_name_or_path');
-------------------code----------------------

* The `require()` function takes **one argument** — the **name or path** of the target module.
* The path can be:

  * **Relative path:** for local modules (e.g., `./logger`)
  * **Parent directory path:** using `../`
  * **Module name:** for built-in or installed modules

**Example (loading a local module):**

-------------------code----------------------
const logger = require('./logger');
-------------------code----------------------

---

### 3. Understanding Relative Paths

* `./` indicates the **current folder**.
* `../` refers to the **parent folder**.

**Examples:**

-------------------code----------------------
require('./logger');        // Same directory
require('./subfolder/logger'); // Inside subfolder
require('../logger');       // Parent directory
-------------------code----------------------

* The `.js` extension is **optional**; Node.js automatically assumes it’s a JavaScript file.

---

### 4. What `require()` Returns

* The `require()` function returns the **`module.exports`** object from the target module.
* This means that whatever is exported in the target file becomes accessible in the importing file.

**Example:**

-------------------code----------------------
// app.js
const logger = require('./logger');
console.log(logger);
-------------------code----------------------

* When executed (`node app.js`), this prints:

  -------------------code----------------------
  { log: [Function: log] }
  -------------------code----------------------
* You can now call the exported function:

  -------------------code----------------------
  logger.log('Message');
  -------------------code----------------------

---

### 5. Using Constants for Module Imports

* It’s a **best practice** to store the imported module in a **constant** rather than a variable.

**Example:**

-------------------code----------------------
const logger = require('./logger');
-------------------code----------------------

* Using `const` prevents accidental reassignment:

  -------------------code----------------------
  logger = 1; // Error: Assignment to constant variable
  -------------------code----------------------
* This helps prevent runtime errors like:

  -------------------code----------------------
  TypeError: logger.log is not a function
  -------------------code----------------------

---

### 6. Detecting Errors with Tools like JSHint

* **JSHint** is a popular tool for detecting JavaScript errors and bad practices.
* Running:

  -------------------code----------------------bash
  jshint app.js
  -------------------code----------------------

  may show warnings such as:

  -------------------code----------------------
  Attempting to overwrite logger, which is a constant
  -------------------code----------------------
* These tools help catch problems **before** the program runs.

---

### 7. Exporting a Single Function Instead of an Object

* When a module only needs to expose a single function, you can **export the function directly** instead of using an object.

**Original:**

-------------------code----------------------
// logger.js
function log(message) {
  console.log(message);
}

module.exports.log = log;
-------------------code----------------------

**Simplified Version:**

-------------------code----------------------
// logger.js
function log(message) {
  console.log(message);
}

module.exports = log;
-------------------code----------------------

**Usage in `app.js`:**

-------------------code----------------------
const log = require('./logger');
log('Message');
-------------------code----------------------

* In this case, `require('./logger')` returns the **function itself**, not an object.

---

### 8. Summary

| Concept           | Description                                                                         |
| ----------------- | ----------------------------------------------------------------------------------- |
| **`require()`**   | Used to import modules in Node.js                                                   |
| **Argument**      | Path or name of the module to load                                                  |
| **Return Value**  | The exported object or function from the module                                     |
| **Best Practice** | Use `const` when storing imported modules                                           |
| **Tools**         | Use linters like **JSHint** to detect assignment or syntax errors                   |
| **Export Types**  | You can export either an **object** (for multiple members) or a **single function** |

---

### 9. Key Takeaways

* `require()` loads and links modules into your application.
* `module.exports` defines what a module makes available externally.
* Using `const` improves safety by preventing unintended reassignment.
* Modules can export **objects** (for multiple exports) or **functions** (for single exports).
* This modular structure keeps Node.js applications organized, reusable, and maintainable.

---

*** 6- Module Wrapper Function ***
### Lecture Notes: How Node.js Wraps Modules

---

#### 1. **Scope of Variables and Functions in Modules**

* In Node.js, any variable or function defined inside a module is **scoped only to that module**.
* These variables and functions are **private** and **not visible outside** the file unless explicitly exported.
* This encapsulation helps prevent naming conflicts between different files.

---

#### 2. **How Node.js Implements Module Scope**

* Node does **not execute the contents of a module directly**.
* Instead, it **wraps each module’s code inside a function** before execution.
* This hidden function is known as the **Module Wrapper Function**.

Example (conceptual representation):

-------------------code----------------------
(function (exports, require, module, __filename, __dirname) {
  var url = "http://mylogger.io/log";

  function log(message) {
    console.log(message);
  }
  
  module.exports = log;

});
-------------------code----------------------

* When Node executes a file, it wraps the entire code within this function.
* This makes variables and functions **local** to the module, not global.

---

#### 3. **Demonstration of the Wrapper Function**

* By intentionally creating a syntax error at the top of a module, Node shows the internal wrapper function in the error message.
* Example error message reveals:

  -------------------code----------------------
  function (exports, require, module, __filename, __dirname) {
  -------------------code----------------------
* This proves Node wraps every file inside a function before executing it.

---

#### 4. **Parameters Passed to the Wrapper Function**

Each module receives five parameters automatically:

1. **`exports`** – A shortcut reference to `module.exports`.
2. **`require`** – A function to import other modules.
3. **`module`** – Represents the current module and its metadata.
4. **`__filename`** – The absolute path of the current module file.
5. **`__dirname`** – The absolute path of the directory containing the current module.

Example:

-------------------code----------------------
console.log(__filename);
console.log(__dirname);
-------------------code----------------------

Output:

-------------------code----------------------
/path/to/logger.js
/path/to
-------------------code----------------------

---

#### 5. **Relationship Between `exports` and `module.exports`**

* Both refer to the same object initially:

  -------------------code----------------------
  exports.log = function() { };
  // is equivalent to
  module.exports.log = function() { };
  -------------------code----------------------
* However:

  * You **can modify properties** on `exports`.
  * You **cannot reassign** `exports` directly (e.g., `exports = log`) because that breaks the reference to `module.exports`.

---

#### 6. **Purpose of the Wrapper Function**

* Keeps module variables private.
* Provides access to:

  * `require` for importing other modules.
  * `exports` and `module.exports` for exporting functionality.
  * File and directory metadata (`__filename`, `__dirname`).

---

#### 7. **Summary**

* Node wraps each module in a function called the **Module Wrapper Function**.
* This ensures that:

  * Variables and functions inside a file are **not global**.
  * Each file has its own local scope.
* The wrapper passes important objects like `exports`, `require`, `module`, `__filename`, and `__dirname`.
* Understanding this mechanism helps explain how Node manages module isolation and scope safely.


*** 7- Path Module ***
### Lecture Notes: Node.js Built-in Modules and the Path Module

---

#### 1. **Introduction to Built-in Modules**

* Node.js comes with several **built-in core modules** that allow developers to interact with:

  * The **file system**
  * The **operating system**
  * The **network**
  * Other low-level system components
* These modules are included with Node.js and **do not require installation** via npm.

---

#### 2. **Viewing Built-in Modules in the Node.js Documentation**

* Go to **nodejs.org** → **Docs** → choose the current **stable version** (e.g., 8.9.3 in the example).
* In the **Table of Contents**, you can see:

  * Some **global objects** (e.g., `console`, `buffer`)
  * And a list of **built-in modules** such as `fs`, `http`, `os`, and `path`.
* The list is relatively short, but each module provides **important core functionality**.

---

#### 3. **Commonly Used Built-in Modules**

| Module               | Description                                                          |
| -------------------- | -------------------------------------------------------------------- |
| **fs (File System)** | Enables reading, writing, and managing files.                        |
| **http**             | Allows creation of web servers and handling HTTP requests/responses. |
| **os**               | Provides information about the operating system.                     |
| **path**             | Offers utilities for working with file and directory paths.          |
| **process**          | Provides information and control over the current Node process.      |
| **querystring**      | Parses and formats URL query strings (useful for HTTP services).     |
| **stream**           | Handles streaming data (e.g., file reading, network requests).       |

---

#### 4. **Using the Path Module**

* The **`path`** module provides tools to handle and transform file paths easily.
* To use it, call the **`require`** function and pass `'path'` as the argument:

  -------------------code----------------------
  const path = require('path');
  -------------------code----------------------
* When Node.js sees a string without a relative path (`./` or `../`), it assumes it refers to a **built-in module**.
* If no built-in module matches, Node will look for a **file in your application directory**.

---

#### 5. **Example: Parsing a File Path**

* Use the `path.parse()` method to get detailed information about a file path:

  -------------------code----------------------
  const path = require('path');
  const pathObj = path.parse(__filename);
  console.log(pathObj);
  -------------------code----------------------
* The special variable `__filename` is provided by Node’s **module wrapper function** and represents the absolute path of the current file.

---

#### 6. **Output of `path.parse(__filename)`**

The result is an object with several useful properties:

-------------------code----------------------
{
  root: '/',
  dir: '/Users/username/project',
  base: 'app.js',
  ext: '.js',
  name: 'app'
}
-------------------code----------------------

| Property | Description                               |
| -------- | ----------------------------------------- |
| **root** | The root directory of the file path.      |
| **dir**  | The directory containing the file.        |
| **base** | The full file name (including extension). |
| **ext**  | The file extension.                       |
| **name** | The file name without extension.          |

---

#### 7. **Benefits of Using the Path Module**

* Makes working with file and directory paths **safer and easier** than string manipulation.
* Ensures **cross-platform compatibility**, since path formats differ between operating systems (e.g., `/` on Linux vs. `\` on Windows).
* Commonly used in file handling, server development, and configuration scripts.

---


#### 8. **parsing**

In the context of files (and programming in general), **parsing** means **analyzing a string or data structure to extract useful information and break it into parts that a program can easily understand or work with**.

Let’s break that down with an example related to **file paths** in Node.js:

---

### **1. General Definition**

* **Parsing** = Taking a structured piece of data (like text, JSON, or a file path) and **converting it into a more organized or machine-friendly format**.
* The result is usually an **object** or a **set of properties** that describe parts of that data.

---

### **2. Example in Node.js Path Module**

When you call:

-------------------code----------------------
const path = require('path');
const pathObj = path.parse(__filename);
console.log(pathObj);
-------------------code----------------------

You might get something like:

-------------------code----------------------
{
  root: '/',
  dir: '/Users/mahmoud/project',
  base: 'app.js',
  ext: '.js',
  name: 'app'
}
-------------------code----------------------

Here, the `parse()` method **analyzed (parsed)** the full file path string and **broke it into parts**:

* `root` → the root directory (`/`)
* `dir` → the folder path
* `base` → the file name with extension
* `ext` → the file extension
* `name` → the file name without extension

So, instead of manually splitting the file path string, the `parse()` function does it for you.

---

### **3. More General Examples**

* **Parsing JSON:**

  -------------------code----------------------
  const data = JSON.parse('{"name": "Mahmoud"}');
  // Converts text → { name: 'Mahmoud' }
  -------------------code----------------------
* **Parsing CSV:**
  Splitting a line like `"apple,banana,grape"` into `["apple", "banana", "grape"]`.

---

### **In short**

> **Parsing** is the process of **analyzing and breaking down data** (like a file path or a text string) into meaningful parts that a program can use easily.

---

#### how Node’s `path.parse()` works internally (step-by-step how it reads and splits the path)?

---

### **1. Input to `path.parse()`**

* You give it a **file path string**, for example:

-------------------code----------------------
const filePath = '/Users/mahmoud/project/app.js';
const pathObj = path.parse(filePath);
-------------------code----------------------

---

### **2. Steps Node.js Performs Internally**

1. **Normalize the Path**

   * It first ensures the path uses the correct directory separator for your operating system:

     * `/` on Linux/macOS
     * `\` on Windows
   * Example:

     -------------------code----------------------
     /Users/mahmoud/project/app.js  →  stays the same on macOS
     -------------------code----------------------

2. **Separate the Root**

   * Node identifies the **root** of the path (like `/` or `C:\`) and stores it in `root`.
   * Example:

     -------------------code----------------------
     root: '/'
     -------------------code----------------------

3. **Split Directory and File Name**

   * Node finds the **last directory separator** and splits the path into:

     * `dir` → the directory path
     * `base` → the file name with extension
   * Example:

     -------------------code----------------------
     dir: '/Users/mahmoud/project'
     base: 'app.js'
     -------------------code----------------------

4. **Separate File Name and Extension**

   * Node looks for the **last dot `.`** in the file name to separate:

     * `name` → file name without extension
     * `ext` → file extension
   * Example:

     -------------------code----------------------
     name: 'app'
     ext: '.js'
     -------------------code----------------------

5. **Return an Object**

   * Finally, Node packages all these parts into an **object**:

     -------------------code----------------------
     {
       root: '/',
       dir: '/Users/mahmoud/project',
       base: 'app.js',
       ext: '.js',
       name: 'app'
     }
     -------------------code----------------------

---

### **3. Why This is Useful**

* You don’t have to manually manipulate strings with `split()` or `substring()`.
* Node handles all the **OS-specific details** for you.
* It’s safe and consistent, especially when working on multiple operating systems.

---


#### 9. **Next Topic**

* In the next lecture, we will explore another core Node.js module: **the `os` module**, which provides information about the **operating system and system resources**.

*** 8- OS Module ***
**Lecture Notes: Node.js OS Module and Template Strings**

---

### 1. Overview

This lecture explains how to get information about the current operating system using Node.js and introduces the concept of **template strings** from ECMAScript 6 (ES6 / 2015).

---

### 2. The OS Module

* Node.js provides a built-in module called **`os`** that allows access to operating system-related information.
* You can find this module in the official Node.js documentation under the list of core modules.

**Common OS Module Methods:**

* `os.freemem()` → Returns the amount of free system memory.
* `os.totalmem()` → Returns the total system memory.
* `os.userInfo()` → Provides information about the current user.
* `os.uptime()` → Returns the system uptime.

---

### 3. Loading the OS Module

To use the OS module, load it using `require()` just like other Node.js modules.

-------------------code----------------------
const os = require('os');
-------------------code----------------------

---

### 4. Using OS Methods

You can call the methods and log the results to the console.

-------------------code----------------------
const totalMemory = os.totalmem();
const freeMemory = os.freemem();

console.log('Total Memory: ' + totalMemory);
console.log('Free Memory: ' + freeMemory);
-------------------code----------------------

However, this uses string concatenation, which can be simplified using **template strings**.

---

### 5. Template Strings (ES6 / ECMAScript 2015)

**Purpose:**
Template strings provide a cleaner way to include variables inside strings without concatenation.

**Syntax:**

* Use backticks (`` ` ``) instead of quotes.
* Use `${variableName}` as placeholders inside the string.

**Example:**

-------------------code----------------------
console.log(`Total Memory: ${totalMemory}`);
console.log(`Free Memory: ${freeMemory}`);
-------------------code----------------------

**Explanation:**

* Backtick (`` ` ``) is located before the number **1** key on the keyboard.
* `${}` allows embedding dynamic values directly inside a string.

---

### 6. Running the Application

1. Save the file as `app.js`.
2. Run it in the terminal:

   -------------------code----------------------
   node app.js
   -------------------code----------------------
3. The console will display the total and free memory of your machine.

---

### 7. Why This Matters

Before Node.js, JavaScript could only run in browsers and had no access to system-level information such as memory or file data.
With Node.js, JavaScript runs **outside the browser** (on the server or local environment), allowing:

* Access to the file system.
* Network operations (e.g., building web servers).
* Interaction with the operating system.

---

### 8. Summary

* The **`os`** module provides system-level information.
* **`require('os')`** is used to load it.
* **Template strings** (from ES6) simplify string formatting.
* Node.js expands JavaScript’s capability beyond browsers, enabling system and server-side operations.

---

*** 9- File System Module ***
**Lecture Notes: Working with Files in Node.js**

---

### 1. Overview

This lecture explains how to work with files and directories in Node.js using the **File System (fs)** module. It also introduces the difference between **synchronous (blocking)** and **asynchronous (non-blocking)** methods.

---

### 2. The File System Module (fs)

* Node.js provides a built-in module called **`fs`** (File System) for working with files and directories.
* This module includes many methods for reading, writing, deleting, and managing files.
* You can find the documentation for the `fs` module in the official Node.js documentation.

**Importing the Module:**

-------------------code----------------------
const fs = require('fs');
-------------------code----------------------

---

### 3. Synchronous vs Asynchronous Methods

Most operations in the `fs` module are available in two versions:

* **Synchronous (blocking)** → Methods ending with `Sync`, such as `readFileSync()`, `accessSync()`, etc.
* **Asynchronous (non-blocking)** → Methods without the `Sync` suffix, such as `readFile()`, `access()`, etc.

**Key Point:**

* In real-world applications, **always use asynchronous methods** to prevent blocking the single Node.js thread.
* Blocking the thread means other clients cannot be served simultaneously, which harms performance in web applications.

---

### 4. Example: Reading a Directory

#### 4.1 Synchronous Version

The synchronous form is easier to understand but should be avoided in production.

**Example:**

-------------------code----------------------
const fs = require('fs');

const files = fs.readdirSync('./');
console.log(files);
-------------------code----------------------

**Explanation:**

* `fs.readdirSync('./')` reads the contents of the current directory (`./`).
* It returns an array of strings containing the names of all files and folders.
* This operation blocks the thread until it completes.

**Output Example:**

-------------------code----------------------
[ 'app.js', 'package.json', 'node_modules' ]
-------------------code----------------------

---

#### 4.2 Asynchronous Version

The asynchronous version is non-blocking and should be preferred.

**Example:**

-------------------code----------------------
const fs = require('fs');

fs.readdir('./', (error, files) => {
  if (error) {
    console.log('Error:', error);
  } else {
    console.log('Result:', files);
  }
});
-------------------code----------------------

**Explanation:**

* The first argument (`'./'`) is the path of the directory to read.
* The second argument is a **callback function** that Node calls once the operation is complete.
* The callback receives two parameters:

  * `error`: contains an error object if something went wrong.
  * `files`: contains the result (array of file and folder names) if successful.
* Only one of these parameters will have a value at a time.

---

### 5. Handling Errors

If an invalid path is provided, an error will occur.

**Example:**

-------------------code----------------------
fs.readdir('$', (error, files) => {
  if (error) console.log('Error:', error);
  else console.log('Result:', files);
});
-------------------code----------------------

**Output:**

-------------------code----------------------
Error: ENOENT: no such file or directory, scandir '$'
-------------------code----------------------

**Note:**
This simple error logging is only for demonstration. A complete section on **error handling** will be covered later in the course.

---

### 6. Summary

* To work with files or directories in Node.js, use the **`fs`** module.
* Most methods come in **synchronous** and **asynchronous** pairs.
* **Always prefer asynchronous methods** to prevent blocking the Node.js event loop.
* The **`readdir()`** method reads the contents of a directory.
* Asynchronous methods require a **callback** function to handle results and errors.

---
