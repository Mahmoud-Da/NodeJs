*** 1- Synchronous vs Asynchronous Code ***
Here’s a clean, well-organized version of your lecture notes:

---

### **Lecture Notes: Introduction to Asynchronous Programming in Node.js**

#### **1. Review of RESTful APIs**

* In the previous section, we built RESTful APIs using Express.
* We used a simple in-memory array to manage data.
* Real-world applications use **databases** instead of arrays.

---

#### **2. Purpose of This Section**

Before learning how to connect Node.js to a database, it’s essential to understand **asynchronous programming**—a core concept in Node.

---

#### **3. Project Setup**

1. Create a new folder: `async-demo`
2. Initialize a Node project:

   -------------------code----------------------
   npm init -y
   -------------------code----------------------
3. Open the folder in a code editor.
4. Create a new file: `index.js`

---

#### **4. Synchronous (Blocking) Code**

Example:

-------------------code----------------------
console.log('Before');
console.log('After');
-------------------code----------------------

* Execution is **sequential**.
* Each line waits for the previous one to complete.
* This type of execution is called **synchronous** or **blocking**.

---

#### **5. Asynchronous (Non-Blocking) Code**

Example:

-------------------code----------------------
console.log('Before');

setTimeout(() => {
  console.log('Reading a user from a database...');
}, 2000);

console.log('After');
-------------------code----------------------

**Explanation:**

* `setTimeout()` schedules a task to execute after 2 seconds.
* It does **not** block the code.
* Output order:

  -------------------code----------------------
  Before
  After
  (2-second delay)
  Reading a user from a database...
  -------------------code----------------------
* The function inside `setTimeout()` executes **later**, allowing the program to continue running other tasks.

---

#### **6. Key Concept**

* `setTimeout()` is an **asynchronous** or **non-blocking** function.
* It **schedules** a future task instead of **waiting** for it.
* Control immediately returns to the next line.

---

#### **7. Thread Model**

* Node.js runs in a **single thread**.
* Asynchronous does **not** mean **multi-threaded** or **concurrent**.
* The single thread:

  1. Executes synchronous code.
  2. Schedules asynchronous tasks.
  3. Executes them when ready.

---

#### **8. Restaurant Analogy**

* **Synchronous Restaurant:**
  The waiter takes your order and waits in the kitchen until it’s ready before serving another customer.
* **Asynchronous Restaurant:**
  The waiter takes your order, gives it to the kitchen, and moves to serve the next table while waiting for the food to be ready.
* In both cases, there’s only **one waiter** (thread).

---

#### **9. Why This Matters**

* In Node.js, operations involving **disk** or **network access** are asynchronous.
* Understanding asynchronous behavior is essential for:

  * Writing efficient Node.js applications.
  * Maintaining clean and readable code.
  * Avoiding blocking the main thread.

---

#### **10. What’s Next**

In the following lessons, you will learn:

* Different patterns for writing asynchronous code.
* How to handle asynchronous operations cleanly and maintainably.

*** 2- Patterns for Dealing with Asynchronous Code ***
**Lecture Notes: Asynchronous Programming – Understanding Callback Structure**

**1. Refactoring the Program**

* The instructor demonstrates how to make the program more realistic by moving certain lines of code into a new function called `getUser`.
* The goal of `getUser` is to simulate fetching a user from a database.

**Example structure:**

-------------------code----------------------
function getUser(id) {
  // Simulated database call
  setTimeout(() => {
    return { id: id, githubUsername: "mosh" };
  }, 2000);
}
-------------------code----------------------

* The function takes an `id` parameter.
* It should return a user object containing properties like:

  * `id`
  * `githubUsername`

**2. Problem: Returning Values from Asynchronous Code**

* The instructor calls the function as follows:

  -------------------code----------------------
  const user = getUser(1);
  console.log(user);
  -------------------code----------------------
* The output is:

  -------------------code----------------------
  before
  undefined
  after
  -------------------code----------------------
* This happens because the `setTimeout` function delays execution, so the `return` statement inside it runs *after* `getUser` has already finished.

**3. Key Concept**

* When a function includes asynchronous behavior (like reading from a database or calling an API), the return value is **not immediately available**.
* `setTimeout` is used here to simulate that delay.
* Therefore, trying to return the result directly from the asynchronous function will result in `undefined`.

**4. Why the Return Doesn’t Work**

* The function `getUser` executes `setTimeout` and schedules a task for later.
* The main program continues running before the delayed task finishes.
* By the time the inner function returns the user object, the outer `getUser` function has already returned.

**5. Simulating Immediate vs Delayed Return**

* Returning a simple value like `1` works immediately because it’s synchronous.
* But returning data that depends on asynchronous operations (like database reads) requires a different approach.

**6. Ways to Handle Asynchronous Code**
There are three main patterns to handle asynchronous results in JavaScript:

1. **Callbacks** – Pass a function that will be called once the asynchronous operation completes.
2. **Promises** – Use `.then()` and `.catch()` to handle asynchronous results in a cleaner way.
3. **Async/Await** – A syntactical improvement over promises that allows writing asynchronous code in a synchronous style.

**7. Summary**

* The example introduces the challenge of handling asynchronous results.
* Returning values directly from asynchronous functions doesn’t work because the result isn’t ready immediately.
* Next, the instructor will introduce **callbacks** as the first solution to access the result of an asynchronous operation.

*** 3- Callbacks ***
**Lecture Notes: Asynchronous Programming – Callbacks in JavaScript**

**1. Review of Previous Lesson**

* Previously, it was shown that returning a value directly from an asynchronous function like `getUser` does not work because the result is not immediately available.
* In this lecture, the focus is on using **callbacks** to handle asynchronous results.

---

**2. Modifying the getUser Function**

* The `getUser` function is updated to accept a **callback** parameter.
* A **callback** is a function that is called once an asynchronous operation (such as fetching data) is complete.

**Example:**

-------------------code----------------------
function getUser(id, callback) {
  setTimeout(() => {
    console.log('Reading a user from a database...');
    callback({ id: id, githubUsername: 'mosh' });
  }, 2000);
}
-------------------code----------------------

**Explanation:**

* The second parameter `callback` is a function passed in by the caller.
* Inside `setTimeout`, once the simulated delay ends, the callback is invoked with the `user` object.
* Instead of returning data, we *call* the callback function to deliver the result.

---

**3. Using the Callback**

* Since `getUser` no longer returns a value, the main program passes a callback function to handle the result.

**Example:**

-------------------code----------------------
console.log('Before');
getUser(1, function(user) {
  console.log('User', user);
});
console.log('After');
-------------------code----------------------

**Output:**

-------------------code----------------------
Before
After
Reading a user from a database...
User { id: 1, githubUsername: 'mosh' }
-------------------code----------------------

**Explanation:**

* The asynchronous code (`setTimeout`) runs after the main thread continues.
* “Before” and “After” are printed first, followed by the asynchronous result.

---

**4. Arrow Function Syntax**

* The callback function can also be written with arrow syntax for brevity:

-------------------code----------------------
getUser(1, user => {
  console.log('User', user);
});
-------------------code----------------------

---

**5. Exercise: Creating an Asynchronous getRepositories Function**

* **Objective:** Simulate fetching GitHub repositories for a user after retrieving their username.

**Step 1: Create a synchronous version**

-------------------code----------------------
function getRepositories(username) {
  return ['repo1', 'repo2', 'repo3'];
}
-------------------code----------------------

**Step 2: Convert to asynchronous**

* Use `setTimeout` to simulate a 2-second API call.
* Add a callback parameter to handle the result asynchronously.

**Example Solution:**

-------------------code----------------------
function getRepositories(username, callback) {
  setTimeout(() => {
    console.log('Calling GitHub API...');
    callback(['repo1', 'repo2', 'repo3']);
  }, 2000);
}
-------------------code----------------------

---

**6. Integrating Both Asynchronous Functions**

* After fetching the user, call `getRepositories` inside the callback.

**Example:**

-------------------code----------------------
console.log('Before');
getUser(1, user => {
  getRepositories(user.githubUsername, repos => {
    console.log('Repos', repos);
  });
});
console.log('After');
-------------------code----------------------

**Output:**

-------------------code----------------------
Before
After
Reading a user from a database...
Calling GitHub API...
Repos [ 'repo1', 'repo2', 'repo3' ]
-------------------code----------------------

---

**7. Key Takeaways**

* **Callbacks** are functions passed as arguments to be executed later, once asynchronous data becomes available.
* Returning values directly from asynchronous functions does not work; you must use a callback or other async mechanisms.
* Nesting callbacks (e.g., calling `getRepositories` inside `getUser`) can make code less readable, a situation often called **callback hell**.
* Future lessons will introduce **Promises** and **async/await** to make handling asynchronous code more elegant.


*** 4- Callback Hell ***
**Lecture Notes: Asynchronous Programming – Callback Hell**

**1. Review of Current Code**

* The current implementation uses callbacks to handle asynchronous operations:

  * `getUser()` retrieves a user.
  * Inside its callback, `getRepositories()` is called.
  * Then, inside that callback, another function (e.g., `getCommits()`) could be called.

**Example:**

-------------------code----------------------
getUser(1, user => {
  getRepositories(user.githubUsername, repos => {
    getCommits(repos[0], commits => {
      console.log(commits);
    });
  });
});
-------------------code----------------------

**2. The Problem: Nested Callback Structure**

* Each asynchronous step is nested inside the previous one.
* As more asynchronous operations are added, the indentation grows deeper, making the code harder to read and maintain.
* This pattern is known as **callback hell** or the **Christmas tree problem** because the code visually resembles the shape of a tree due to indentation.

---

**3. Comparison with Synchronous Code**
If all the same operations were **synchronous**, the flow of the program would look simple and linear:

**Synchronous Example:**

-------------------code----------------------
console.log('Before');

const user = getUser(1);
const repos = getRepositories(user.githubUsername);
const commits = getCommits(repos[0]);
console.log(commits);

console.log('After');
-------------------code----------------------

**Characteristics:**

* The code runs top to bottom in a predictable order.
* The logic is easy to follow because each line executes only after the previous one finishes.
* There is no nesting or callback structure.

---

**4. Why Asynchronous Code Becomes Complicated**

* In asynchronous programming, each operation (like a database query or API call) takes time to complete.
* Instead of blocking the execution of the program, JavaScript uses callbacks to handle results when they are ready.
* As more asynchronous steps are added, callbacks begin to nest within one another, creating complex and difficult-to-read structures.

---

**5. Terminology**

* **Callback Hell:** The problem of deeply nested callbacks that make asynchronous code hard to read, debug, and maintain.
* **Christmas Tree Problem:** Another term for callback hell, describing the visual shape of heavily indented callback structures.

---

**6. Key Takeaways**

* Callback-based asynchronous programming often leads to complex nesting as the number of dependent operations increases.
* Synchronous code is easier to read because it runs sequentially.
* The nested callback issue becomes more pronounced in real-world applications that involve multiple asynchronous operations.
* In the next lecture, the instructor will introduce a **solution to callback hell**, which involves using **Promises** to simplify asynchronous code.


*** 5- Named Functions to Rescue ***
**Lecture Notes: Asynchronous Programming – Avoiding Callback Hell with Named Functions**

**1. The Problem Recap**

* In the previous lecture, we saw how deeply nested callbacks make code hard to read and maintain.
* This pattern, known as *callback hell*, often appears when asynchronous operations depend on one another (e.g., fetching users, repositories, and commits).

---

**2. The Simple Solution: Replacing Anonymous Functions with Named Functions**

* The technique to reduce nesting is to replace **anonymous callback functions** with **named functions**.
* Anonymous functions are functions passed directly as arguments without names:

  -------------------code----------------------
  getRepositories(user.githubUsername, function(repos) {
    getCommits(repos[0], function(commits) {
      console.log(commits);
    });
  });
  -------------------code----------------------
* By giving each function a name, we can move it out of the nested structure and pass it as a reference instead.

---

**3. Step-by-Step Refactoring**

**Step 1: Replace the innermost anonymous function**

* The last callback handles commits. Replace it with a named function called `displayCommits`:

  -------------------code----------------------
  function displayCommits(commits) {
    console.log(commits);
  }
  -------------------code----------------------
* Then replace the inline callback with this named function:

  -------------------code----------------------
  getCommits(repo, displayCommits);
  -------------------code----------------------
* Note: We pass the function **reference**, not a call (no parentheses).

---

**Step 2: Replace the middle-level callback**

* The callback in `getRepositories` retrieves commits for a user’s repositories.

  -------------------code----------------------
  function getCommitsForUser(repos) {
    getCommits(repos[0], displayCommits);
  }
  -------------------code----------------------
* Now replace the inline callback with this named function:

  -------------------code----------------------
  getRepositories(user.githubUsername, getCommitsForUser);
  -------------------code----------------------

---

**Step 3: Replace the outermost callback**

* The outer callback in `getUser` retrieves repositories for a user.

  -------------------code----------------------
  function getRepositoriesForUser(user) {
    getRepositories(user.githubUsername, getCommitsForUser);
  }
  -------------------code----------------------
* Replace the anonymous callback in the main code:

  -------------------code----------------------
  getUser(1, getRepositoriesForUser);
  -------------------code----------------------

---

**4. Final Code Structure**

-------------------code----------------------
getUser(1, getRepositoriesForUser);

function getRepositoriesForUser(user) {
  getRepositories(user.githubUsername, getCommitsForUser);
}

function getCommitsForUser(repos) {
  getCommits(repos[0], displayCommits);
}

function displayCommits(commits) {
  console.log(commits);
}
-------------------code----------------------

**Result:**

* The logic is the same, but the structure is now flat and readable.
* Each function clearly represents one step in the sequence of asynchronous operations.

---

**5. Advantages of This Approach**

* Reduces visual nesting (no “Christmas tree” indentation).
* Makes the code easier to read, follow, and debug.
* Each step of the process is modular and reusable.

---

**6. Limitations**

* While this approach improves readability, it still requires managing multiple callbacks manually.
* Complex applications with many dependent asynchronous calls can still become difficult to handle.

---

**7. Next Step**

* A more powerful and elegant solution for handling asynchronous operations is using **Promises**.
* Promises provide a structured way to chain asynchronous actions without deeply nested callbacks.

*** 6- Promises ***
**Lecture Notes: Asynchronous Programming – Understanding JavaScript Promises**

**1. Introduction to Promises**

* A **promise** is an object that represents the eventual result of an asynchronous operation.
* When an asynchronous operation completes, it can either:

  * Produce a **value** (success)
  * Produce an **error** (failure)

**2. States of a Promise**
A promise can be in one of three states:

1. **Pending** – The initial state when the asynchronous operation has started but not yet completed.
2. **Fulfilled (Resolved)** – The asynchronous operation completed successfully and returned a value.
3. **Rejected** – The asynchronous operation failed and returned an error.

---

**3. Creating a Promise**

* A promise is created using the `Promise` constructor:

-------------------code----------------------
const p = new Promise((resolve, reject) => {
  // Asynchronous operation
});
-------------------code----------------------

* The constructor takes a function with two parameters:

  * **resolve** – a function used to return a successful result.
  * **reject** – a function used to return an error.

**Example (Basic Promise):**

-------------------code----------------------
const p = new Promise((resolve, reject) => {
  resolve(1); // Successful result
  // reject(new Error('Something went wrong')); // Failure example
});
-------------------code----------------------

---

**4. Consuming a Promise**

* To use the result of a promise, call:

  * `.then()` to handle success
  * `.catch()` to handle errors

**Example:**

-------------------code----------------------
p
  .then(result => console.log(result)) // Called when resolved
  .catch(error => console.log(error.message)); // Called when rejected
-------------------code----------------------

**Output:**

-------------------code----------------------
1
-------------------code----------------------

---

**5. Adding Asynchronous Behavior**

* To simulate asynchronous work, use `setTimeout` inside the promise:

-------------------code----------------------
const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(1); // Return result after 2 seconds
  }, 2000);
});
-------------------code----------------------

**Result:**

* The code waits 2 seconds before printing the result:

-------------------code----------------------
1
-------------------code----------------------

---

**6. Handling Errors**

* If something goes wrong, use `reject` instead of `resolve`:

-------------------code----------------------
const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(new Error('Something failed'));
  }, 2000);
});
-------------------code----------------------

**Consuming the Promise with Error Handling:**

-------------------code----------------------
p
  .then(result => console.log(result))
  .catch(error => console.log(error.message));
-------------------code----------------------

**Output:**

-------------------code----------------------
Something failed
-------------------code----------------------

---

**7. Summary of Promise Behavior**

* **Creation:**
  A promise starts in the *pending* state when created.
* **Resolution:**
  If the async task succeeds → state becomes *fulfilled* → `resolve()` is called.
* **Rejection:**
  If the async task fails → state becomes *rejected* → `reject()` is called.
* **Consumption:**
  Use `.then()` to handle success and `.catch()` to handle errors.

---

**8. Key Takeaways**

* Promises make asynchronous code easier to manage and read compared to nested callbacks.
* A promise “promises” to eventually return a result (success or failure).
* The `.then()` and `.catch()` methods allow you to handle results and errors cleanly.
* **Best Practice:** Instead of passing callbacks, modify asynchronous functions to return a promise.

---

**Next Lecture Preview**

* The next topic will demonstrate how to modify existing asynchronous callback functions so they return promises, allowing cleaner and more maintainable code.


*** 7- Replacing Callbacks with Promises ***
**Lecture Notes: Converting Asynchronous Functions to Promises**

---

### **Overview**

In this lecture, the focus is on resolving the *callback hell* problem by converting asynchronous functions that use callbacks into functions that return *Promises*. This approach simplifies asynchronous code and improves readability.

---

### **Callback Hell Problem**

Previously, asynchronous operations were handled using callbacks, leading to nested and hard-to-maintain code (callback hell).
To fix this, we modify asynchronous functions to return *Promises* instead of accepting callbacks.

---

### **Promise Basics**

* A *Promise* is an object representing the eventual completion or failure of an asynchronous operation.
* A Promise is created using the constructor:

  -------------------code----------------------
  new Promise((resolve, reject) => {
      // asynchronous operation
  });
  -------------------code----------------------
* **resolve:** called when the asynchronous operation completes successfully.
* **reject:** called when the asynchronous operation fails.

---

### **Step-by-Step Conversion Example**

#### **1. Original Function**

-------------------code----------------------
function getUser(id, callback) {
    setTimeout(() => {
        console.log('Reading a user from a database...');
        callback({ id: id, gitHubUsername: 'mosh' });
    }, 2000);
}
-------------------code----------------------

This function uses a callback to return the result after an asynchronous operation.

---

#### **2. Modified Function (Returning a Promise)**

-------------------code----------------------
function getUser(id) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log('Reading a user from a database...');
            resolve({ id: id, gitHubUsername: 'mosh' });
        }, 2000);
    });
}
-------------------code----------------------

**Changes made:**

* Removed the callback parameter.
* Returned a new Promise.
* Moved asynchronous work (`setTimeout`) inside the Promise constructor.
* Used `resolve()` to send the result to the consumer.

---

### **Exercise**

Modify the following two functions using the same approach:

1. **getRepositories**

   -------------------code----------------------
   function getRepositories(username, callback) {
       setTimeout(() => {
           console.log('Calling GitHub API...');
           callback(['repo1', 'repo2', 'repo3']);
       }, 2000);
   }
   -------------------code----------------------

2. **getCommits**

   -------------------code----------------------
   function getCommits(repo, callback) {
       setTimeout(() => {
           console.log('Calling GitHub API...');
           callback(['commit']);
       }, 2000);
   }
   -------------------code----------------------

**Steps:**

* Remove the callback parameter.
* Return a new Promise.
* Use `resolve()` to return the final result.

---

### **Final Summary**

After modification:

* None of the asynchronous functions use callbacks.
* Each function now returns a Promise.
* This makes it possible to consume them using `.then()` and `.catch()` for cleaner asynchronous code.

---

### **Next Lecture Preview**

The next lecture will demonstrate how to **consume these Promises** using the `.then()` method for chaining and better control flow.

*** 8- Consuming Promises ***
**Lecture Notes: Rewriting Asynchronous Code Using Promises**

---

### **Overview**

In this lecture, the callback-based asynchronous code is rewritten using *Promises* to achieve a cleaner and more maintainable structure. This approach eliminates nested callbacks (callback hell) and introduces promise chaining for sequential asynchronous operations.

---

### **Using Promises Instead of Callbacks**

#### **1. Basic Promise Usage**

When calling an asynchronous function like `getUser`, which returns a promise, we can handle the result using the `.then()` method and handle errors using `.catch()`.

-------------------code----------------------
getUser(1)
  .then(user => console.log(user))
  .catch(err => console.log(err.message));
-------------------code----------------------

**Explanation:**

* `then()` is used to access the result of a resolved promise.
* `catch()` is used to handle any error that occurs during the asynchronous operations.

---

### **Simplifying the Code**

Previously:

-------------------code----------------------
const promise = getUser(1);
promise.then(user => console.log(user));
-------------------code----------------------

Simplified:

-------------------code----------------------
getUser(1)
  .then(user => console.log(user));
-------------------code----------------------

Here, the `.then()` method is chained directly to the function call, making the code shorter and cleaner.

---

### **Chaining Promises for Sequential Operations**

#### **Example Workflow**

1. Get a user from the database.
2. Get the repositories for that user.
3. Get the commits for the first repository.

#### **Code Implementation**

-------------------code----------------------
getUser(1)
  .then(user => getRepositories(user.gitHubUsername))
  .then(repos => getCommits(repos[0]))
  .then(commits => console.log(commits))
  .catch(err => console.log('Error:', err.message));
-------------------code----------------------

**Explanation of Each Step:**

* **`getUser(1)`**
  Returns a promise that resolves to a *user object*.

* **`.then(user => getRepositories(user.gitHubUsername))`**
  The `then` callback receives the user object and calls `getRepositories`, which returns another promise.
  Because `.then()` returns a new promise, we can chain another `.then()`.

* **`.then(repos => getCommits(repos[0]))`**
  Once repositories are available, we call `getCommits` for the first repository.
  This also returns a promise that resolves to a list of commits.

* **`.then(commits => console.log(commits))`**
  Finally, when commits are retrieved, they are displayed in the console.

* **`.catch(err => console.log('Error:', err.message))`**
  If any of these operations fail, this single `catch` handles the error from any point in the chain.

---

### **Output Sequence**

When running `node index.js`, the output sequence shows:

1. Reading a user from the database (after 2 seconds)
2. Calling the GitHub API to get repositories (after another 2 seconds)
3. Getting commits for the first repository (after another 2 seconds)
4. Displaying the list of commits in the console

---

### **Comparison: Callbacks vs Promises**

| **Callback-based Implementation** | **Promise-based Implementation** |
| --------------------------------- | -------------------------------- |
| Nested structure (callback hell)  | Flat, readable chain             |
| Hard to maintain and debug        | Easier to follow and handle      |
| Multiple error handlers           | Single `.catch()` handles all    |

---

### **Best Practice**

Always include a `.catch()` block at the end of a promise chain to handle unexpected errors during asynchronous operations.

---

### **Summary**

* Promises simplify asynchronous code by replacing nested callbacks with chained operations.
* The `.then()` method handles successful results.
* The `.catch()` method handles all errors in one place.
* Promise chaining enables readable and maintainable asynchronous workflows.

In the next lecture, the code will be made even simpler using *async and await*.

*** 9- Creating Settled Promises ***
**Lecture Notes: The Promise API in JavaScript**

---

### **Overview**

In this lecture, we explore the **Promise API** in JavaScript more deeply.
Specifically, we learn how to create **already resolved** or **already rejected** promises using static methods of the `Promise` class.
This approach is useful for testing or simulating asynchronous operations without performing real asynchronous work.

---

### **1. Setting Up the Playground**

Create a new file named **`promise-api.js`** to practice using promise methods.

-------------------code----------------------
touch promise-api.js
-------------------code----------------------

This file will serve as a sandbox to experiment with different promise behaviors.

---

### **2. Creating an Already Resolved Promise**

Sometimes, you want to simulate a successful asynchronous operation — for example, when testing a function that depends on a resolved promise.

You can use **`Promise.resolve()`** to create an already resolved promise.

-------------------code----------------------
const p = Promise.resolve({ id: 1, name: 'Mosh' });

p.then(result => console.log(result));
-------------------code----------------------

**Explanation:**

* `Promise.resolve(value)` creates a promise that is already resolved with the provided value.
* The `value` can be a primitive, object, or any data.
* The `.then()` method is used to access the resolved value.

**Example Output:**

-------------------code----------------------
{ id: 1, name: 'Mosh' }
-------------------code----------------------

This promise does not wait; it is immediately resolved.

---

### **3. Creating an Already Rejected Promise**

To simulate an error or failed operation, use **`Promise.reject()`**.

-------------------code----------------------
const p = Promise.reject(new Error('Something failed'));

p.catch(error => console.log(error));
-------------------code----------------------

**Explanation:**

* `Promise.reject(reason)` creates a promise that is immediately rejected.
* The `reason` should describe why the operation failed.
* The `.catch()` method handles the rejection.

**Example Output:**

-------------------code----------------------
Error: Something failed
    at Object.<anonymous> (promise-api.js:2:23)
    ...
-------------------code----------------------

---

### **4. Importance of Using Error Objects**

When rejecting promises, it is best practice to use an **Error object** rather than a simple string.

#### **Using an Error Object**

-------------------code----------------------
Promise.reject(new Error('Something failed'));
-------------------code----------------------

**Output:**
Includes both the error message and a **call stack**, which helps with debugging.

#### **Using a String**

-------------------code----------------------
Promise.reject('Something failed');
-------------------code----------------------

**Output:**

-------------------code----------------------
Something failed
-------------------code----------------------

In this case, no call stack is included, making it harder to trace the source of the error.

---

### **5. Summary of Static Methods**

| **Method**               | **Description**                     | **Returns**                              | **Handled With** |
| ------------------------ | ----------------------------------- | ---------------------------------------- | ---------------- |
| `Promise.resolve(value)` | Creates an already resolved promise | A promise with the given value           | `.then()`        |
| `Promise.reject(reason)` | Creates an already rejected promise | A rejected promise with the given reason | `.catch()`       |

---

### **6. Best Practices**

* Use `Promise.resolve()` when you need an immediately resolved promise (for example, in unit tests or simulations).
* Use `Promise.reject()` to simulate errors.
* Always use an **Error object** when rejecting a promise to retain the call stack for debugging.

---

### **Key Takeaway**

The `Promise` class provides convenient static methods — `resolve()` and `reject()` — that help create pre-set promises for testing and error handling scenarios.
Using `Error` objects ensures meaningful debugging information is available when a promise fails.

*** 10- Running Promises in Parallel ***
**Lecture Notes: Running Multiple Asynchronous Operations in Parallel with Promises**

---

### **Overview**

This lecture explains how to run multiple asynchronous operations in parallel using the `Promise.all()` and `Promise.race()` methods. These techniques allow for efficient management of concurrent asynchronous tasks such as multiple API calls.

---

### **1. Simulating Parallel Asynchronous Operations**

#### **Creating Two Promises**

-------------------code----------------------
const p1 = new Promise((resolve) => {
  setTimeout(() => {
    console.log('Asynchronous operation 1');
    resolve(1);
  }, 2000);
});

const p2 = new Promise((resolve) => {
  setTimeout(() => {
    console.log('Asynchronous operation 2');
    resolve(2);
  }, 2000);
});
-------------------code----------------------

**Explanation:**

* Each promise simulates an asynchronous operation using `setTimeout`.
* `p1` and `p2` might represent API calls to Facebook and Twitter.
* Both promises resolve after 2 seconds with different values.

---

### **2. Using `Promise.all()`**

#### **Purpose**

`Promise.all()` runs multiple asynchronous operations in parallel and returns a single promise that resolves **when all input promises are resolved**.

#### **Implementation**

-------------------code----------------------
Promise.all([p1, p2])
  .then(result => console.log(result))
  .catch(error => console.log('Error:', error.message));
-------------------code----------------------

**Explanation:**

* Accepts an array of promises (`[p1, p2]`).
* Returns a new promise that resolves when *all* input promises are resolved.
* The result is an **array** containing the values of each resolved promise.

**Output Example:**

-------------------code----------------------
Asynchronous operation 1
Asynchronous operation 2
[1, 2]
-------------------code----------------------

---

### **3. Important Clarifications**

#### **Single Thread Execution**

JavaScript is **single-threaded**, meaning it does not execute operations truly in parallel.
However, it can **initiate multiple asynchronous operations** almost simultaneously.

* The first operation starts.
* The thread is released and begins the next operation immediately.
* Both operations run independently without waiting for each other.

#### **Sequential vs Parallel**

* **Sequential:** Each operation starts after the previous one finishes.
* **Parallel:** All operations are initiated around the same time and resolve independently.

---

### **4. Handling Promise Rejection**

If any promise in `Promise.all()` is rejected, the final promise returned by `Promise.all()` will also be **rejected**.

#### **Example**

-------------------code----------------------
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error('Something failed')), 2000);
});

const p2 = new Promise(resolve => {
  setTimeout(() => resolve(2), 2000);
});

Promise.all([p1, p2])
  .then(result => console.log(result))
  .catch(error => console.log('Error:', error.message));
-------------------code----------------------

**Output:**

-------------------code----------------------
Error: Something failed
-------------------code----------------------

**Explanation:**
Even though `p2` resolves successfully, the rejection of `p1` causes the overall `Promise.all()` to reject.

---

### **5. Using `Promise.race()`**

#### **Purpose**

`Promise.race()` runs multiple asynchronous operations in parallel but resolves **as soon as one of them is fulfilled** (or rejects as soon as one fails).

#### **Example**

-------------------code----------------------
const p1 = new Promise(resolve => {
  setTimeout(() => {
    console.log('Asynchronous operation 1');
    resolve(1);
  }, 2000);
});

const p2 = new Promise(resolve => {
  setTimeout(() => {
    console.log('Asynchronous operation 2');
    resolve(2);
  }, 3000);
});

Promise.race([p1, p2])
  .then(result => console.log('Result:', result))
  .catch(error => console.log('Error:', error.message));
-------------------code----------------------

**Output Example:**

-------------------code----------------------
Asynchronous operation 1
Result: 1
Asynchronous operation 2
-------------------code----------------------

**Explanation:**

* Both promises start almost at the same time.
* The first promise to resolve determines the result of `Promise.race()`.
* The final result is **not an array**—it’s the value of the first fulfilled promise.

---

### **6. Summary**

| **Method**       | **Behavior**                   | **Resolves When**                          | **Result**                     | **Rejects When**          |
| ---------------- | ------------------------------ | ------------------------------------------ | ------------------------------ | ------------------------- |
| `Promise.all()`  | Runs all promises concurrently | All promises are fulfilled                 | Array of all results           | Any promise rejects       |
| `Promise.race()` | Runs all promises concurrently | The first promise is fulfilled or rejected | Value of first settled promise | The first promise rejects |

---

### **7. Best Practices**

* Use **`Promise.all()`** when you need *all* results before proceeding (e.g., multiple API calls that all must succeed).
* Use **`Promise.race()`** when you only need *the first* result (e.g., loading from the fastest server).
* Always include `.catch()` to handle potential rejections safely.

---

### **Key Takeaway**

JavaScript’s `Promise.all()` and `Promise.race()` enable running asynchronous tasks efficiently and handling their outcomes collectively or selectively—allowing for more flexible and performant asynchronous workflows.

*** 11- Async and Await ***
**Lecture Notes: Async and Await in JavaScript**

---

### **Overview**

This lecture introduces **async and await**, a modern JavaScript feature that allows writing asynchronous code that looks and behaves like synchronous code.
It is built on top of promises and provides a cleaner, more readable syntax compared to callbacks or chained `.then()` calls.

---

### **1. Rewriting Promises Using Async/Await**

#### **Original Promise-based Approach**

-------------------code----------------------
getUser(1)
  .then(user => getRepositories(user.gitHubUsername))
  .then(repos => getCommits(repos[0]))
  .then(commits => console.log(commits))
  .catch(err => console.log('Error:', err.message));
-------------------code----------------------

#### **Async/Await Approach**

-------------------code----------------------
async function displayCommits() {
  const user = await getUser(1);
  const repos = await getRepositories(user.gitHubUsername);
  const commits = await getCommits(repos[0]);
  console.log(commits);
}

displayCommits();
-------------------code----------------------

**Explanation:**

* The `await` keyword pauses the execution of the function until the promise resolves.
* Code execution appears **synchronous** but runs asynchronously under the hood.
* Each line returns a resolved value directly, eliminating the need for `.then()` chaining.

---

### **2. Using `async` Keyword**

* The `await` keyword **must** be used inside a function declared with `async`.
* Example:

-------------------code----------------------
async function displayCommits() { ... }
-------------------code----------------------

* An `async` function always **returns a promise**.
  If it does not explicitly return a value, it returns a promise that resolves to `undefined` (void).

---

### **3. How Async/Await Works Internally**

* Internally, `async`/`await` is syntactic sugar over promises.
* The JavaScript engine executes the code asynchronously:

  1. When `await getUser(1)` is executed, the thread is released for other work.
  2. Once the promise resolves, execution resumes and the result is stored.
  3. The same happens for the next awaited functions (`getRepositories` and `getCommits`).

**Key Point:** Code looks synchronous, but execution is non-blocking.

---

### **4. Error Handling**

* With promises, errors are handled using `.catch()`.
* With async/await, errors are handled using a **try-catch block**:

-------------------code----------------------
async function displayCommits() {
  try {
    const user = await getUser(1);
    const repos = await getRepositories(user.gitHubUsername);
    const commits = await getCommits(repos[0]);
    console.log(commits);
  } catch (error) {
    console.log('Error:', error.message);
  }
}
-------------------code----------------------

**Example of Simulating an Error:**

* Modify `getRepositories` to reject:

-------------------code----------------------
return Promise.reject(new Error('Could not get the repos'));
-------------------code----------------------

* The catch block in `displayCommits` will handle it:

-------------------code----------------------
Error: Could not get the repos
-------------------code----------------------

---

### **5. Benefits of Async/Await**

* Makes asynchronous code **easier to read** and maintain.
* Eliminates **callback hell** and deeply nested `.then()` chains.
* Handles errors cleanly with `try-catch`.
* Internally uses promises, so fully compatible with existing promise-based functions.

---

### **6. Summary**

| Concept        | Explanation                                                                     |
| -------------- | ------------------------------------------------------------------------------- |
| `async`        | Declares a function as asynchronous; allows use of `await` inside it.           |
| `await`        | Pauses execution until a promise resolves; returns the resolved value.          |
| Error Handling | Use `try-catch` instead of `.catch()`.                                          |
| Returns        | Async functions always return a promise, even if no explicit value is returned. |
| Under the Hood | Async/await is syntactic sugar over promises; execution remains asynchronous.   |

**Key Takeaway:**
Async/await allows writing asynchronous code in a **linear, readable style** while maintaining non-blocking behavior and robust error handling.

why the function dont need await when calling?
-------------------code----------------------
async function displayCommits() {
  try {
    const user = await getUser(1);
    const repos = await getRepositories(user.gitHubUsername);
    const commits = await getCommits(repos[0]);
    console.log(commits);
  } catch (error) {
    console.log("Error:", error.message);
  }
}
-------------------code----------------------

Excellent question — this is a subtle but important point about how `async` functions work in JavaScript.

Let’s unpack it step by step.

---

### **1. What happens when you call an async function**

When you define an `async` function like this:

-------------------code----------------------
async function displayCommits() { ... }
-------------------code----------------------

and then call it:

-------------------code----------------------
displayCommits();
-------------------code----------------------

it **immediately returns a promise** — it doesn’t block or wait for anything.

In other words:

-------------------code----------------------
const result = displayCommits();
console.log(result); // Promise {<pending>}
-------------------code----------------------

Even though the function body *looks* synchronous because of `await`, the execution of that body happens asynchronously. The returned promise will be **fulfilled or rejected** when the function completes or throws an error.

---

### **2. Why we don’t need `await` when calling it**

You don’t need to use `await displayCommits()` unless you actually **need to wait for its completion** before continuing with the next line of code.

For example:

-------------------code----------------------
displayCommits();
console.log('This runs immediately after calling displayCommits');
-------------------code----------------------

This is perfectly fine — the message logs right away, and then `displayCommits` runs in the background.

But if you wanted to wait for it to finish (for instance, inside another async function), then you would use `await`:

-------------------code----------------------
async function run() {
  await displayCommits();
  console.log('displayCommits finished!');
}
run();
-------------------code----------------------

---

### **3. Summary Table**

| Situation                                                 | Code Example                             | Explanation                                        |
| --------------------------------------------------------- | ---------------------------------------- | -------------------------------------------------- |
| You just want to **start** the async task                 | `displayCommits();`                      | Fire-and-forget. The function runs asynchronously. |
| You need to **wait for it to complete** before continuing | `await displayCommits();`                | Only valid inside another async function.          |
| You want to **handle the result or errors manually**      | `displayCommits().then(...).catch(...);` | Works just like a normal promise.                  |

---

### **4. Analogy**

Think of `displayCommits()` as starting a background job that returns a “ticket” (a promise).
You can either:

* Ignore the ticket (`displayCommits();`)
* Wait for it to finish (`await displayCommits();`)
* Or attach callbacks (`displayCommits().then(...).catch(...);`)

---

### **5. In your example**

You don’t need `await` because you’re not waiting for the function’s completion — you’re just starting it.
If you wanted to execute something *after* it’s done, you’d use one of the waiting methods above.

---


- show a short example where using `await` **does** make a difference in output order?

Here’s a simple example showing the difference between calling an async function **with** and **without** `await`:

---

### **Example Code**

-------------------code----------------------
async function delayLog(message, delay) {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(message);
      resolve();
    }, delay);
  });
}

async function example() {
  console.log("Start");

  // Call async function WITHOUT await
  delayLog("No await → this runs in background", 2000);

  console.log("Middle (runs immediately)");

  // Call async function WITH await
  await delayLog("With await → waits before continuing", 2000);

  console.log("End (runs after await finishes)");
}

example();
-------------------code----------------------

---

### **Output Explanation**

When you run this code, you’ll see something like:

-------------------code----------------------
Start
Middle (runs immediately)
No await → this runs in background
With await → waits before continuing
End (runs after await finishes)
-------------------code----------------------

---

### **Step-by-step**

1. `delayLog("No await...")` starts an async task but **does not wait** — execution continues right away.
2. `"Middle (runs immediately)"` is logged next.
3. When we reach `await delayLog("With await...")`, the function **pauses** until that async operation finishes.
4. After the 2-second delay, it logs `"With await → waits before continuing"`.
5. Finally, it logs `"End"` once everything has finished.

---

### **Conclusion**

* Without `await`: the function runs asynchronously in the background (fire-and-forget).
* With `await`: JavaScript pauses the current async function until the awaited task finishes.

Would you like me to add another version of this example showing how the same behavior looks when using `.then()` instead of `await`?
