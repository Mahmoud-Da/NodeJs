*** 1- Validation ***
**Lecture Title:** Validation in Mongoose  

**Overview:**  
This lecture explains how to implement validation in Mongoose, focusing on the `required` validator. It also discusses how validation works, error handling, and the difference between Mongoose and MongoDB validations.  

---

### 1. Default Behavior
- By default, all schema properties are **optional**.
- Example: If you create a course without a `name` or `price`, MongoDB allows it.  
- Validation is not enforced at the MongoDB level by default.

---

### 2. Implementing Required Validator
- Modify the schema to make a property required.
-------------------code----------------------
const courseSchema = new mongoose.Schema({
  name: { type: String, required: true },
  author: String,
  tags: [String],
  date: { type: Date, default: Date.now },
  isPublished: Boolean,
  price: Number
});
-------------------code----------------------
- If a course is saved without a `name`, Mongoose will throw a validation error.

---

### 3. Handling Validation Errors
- Saving a document returns a **promise**.
- Use `try-catch` to handle promise rejections:
-------------------code----------------------
async function createCourse() {
  try {
    const course = new Course();
    await course.save();
  } catch (ex) {
    console.log(ex.message);
  }
}
-------------------code----------------------
- Error Example:
-------------------code----------------------
Course validation failed: Path `name` is required.
-------------------code----------------------

---

### 4. Manual Validation
- You can manually trigger validation without saving:
-------------------code----------------------
await course.validate();
-------------------code----------------------
- Returns a promise of `void`.  
- If invalid, it throws an exception.

---

### 5. Callback-Based Validation
- Mongoose `validate` can also use a **callback** to detect errors:
-------------------code----------------------
course.validate((err) => {
  if (err) console.log(err.message);
});
-------------------code----------------------
- Returns a Boolean-like result through the callback.

---

### 6. Key Points About Mongoose Validation
- Validation occurs **only in Mongoose**, not at MongoDB level.
- MongoDB itself does not enforce required fields.
- Mongoose validations ensure documents are valid before saving.

---

### 7. Using Validation with REST APIs
- In REST APIs, you can use libraries like **Joi** to validate client input.
- Mongoose validation acts as a **second layer**:
  - Prevents invalid documents due to programming errors.
  - Ensures data integrity in the database even if the client sends correct data.

---

### 8. Summary
- Default schema properties are optional.  
- Use Mongoose validators like `required` to enforce constraints.  
- Always handle rejected promises when saving documents.  
- Manual validation is possible with `validate()`.  
- Validation in Mongoose complements client-side validation libraries like Joi.  

**Next Lecture:** Built-in validators in Mongoose.  

*** 2- Built-in Validators ***
---

### **Mongoose Built-in Validators**

#### **1. Required Validator**

* The `required` property ensures that a field must have a value.
* It can be set to:

  * A **boolean**: makes the field always required.
  * A **function** returning a boolean: makes the field **conditionally required**.

**Example:**

-------------------code----------------------
price: {
  type: Number,
  required: function() { return this.isPublished; }
}
-------------------code----------------------

* Here, `price` is required **only if** `isPublished` is `true`.
* **Important:**
  Do **not** use an arrow function (`=>`) because arrow functions don’t have their own `this`.
  They capture `this` from the outer scope, which would not refer to the Mongoose document instance.

**Example test result:**

* If `isPublished = true` and `price` is missing → validation error: *"Path `price` is required."*
* If `name` is also missing → another validation error for name.

---

#### **2. String Validators**

For string-type fields, Mongoose provides several built-in validators:

| Validator   | Description                          | Example                              |
| ----------- | ------------------------------------ | ------------------------------------ |
| `minlength` | Minimum allowed length               | `minlength: 5`                       |
| `maxlength` | Maximum allowed length               | `maxlength: 255`                     |
| `match`     | Regular expression pattern matching  | `match: /pattern/`                   |
| `enum`      | Restricts value to a predefined list | `enum: ['web', 'mobile', 'network']` |

**Example:**

-------------------code----------------------
category: {
  type: String,
  required: true,
  enum: ['web', 'mobile', 'network']
}
-------------------code----------------------

**Test Example:**

-------------------code----------------------
category: '-'
-------------------code----------------------

Output:

-------------------code----------------------
category: '-' is not a valid enum value for path 'category'.
-------------------code----------------------

---

#### **3. Number Validators**

For numeric fields:

| Validator | Description   | Example    |
| --------- | ------------- | ---------- |
| `min`     | Minimum value | `min: 10`  |
| `max`     | Maximum value | `max: 200` |

**Example:**

-------------------code----------------------
price: {
  type: Number,
  min: 10,
  max: 200
}
-------------------code----------------------

---

#### **4. Date Validators**

* Date fields can also use `min` and `max` validators to ensure the value falls within a specific range.

---

### **Summary**

* `required`: ensures a value is provided (can be conditional via a function).
* String validators: `minlength`, `maxlength`, `match`, `enum`.
* Number validators: `min`, `max`.
* Date validators: `min`, `max`.
* Avoid using arrow functions when referencing `this` in validators.

---

Next lecture: **Custom Validators in Mongoose**.


*** 3- Custom Validators ***
---

### **Custom Validators in Mongoose**

#### **1. When to Use Custom Validators**

* Built-in validators (e.g., `required`, `min`, `max`, `enum`) are often sufficient, but sometimes custom rules are needed.
* Example case: enforcing that an array (like `tags`) must have **at least one element**.
* The `required` validator alone cannot handle this because an empty array `[]` still passes validation.

---

#### **2. Defining a Custom Validator**

To define a custom validator, use the `validate` property in your schema field definition.

**Example:**

-------------------code----------------------
tags: {
  type: Array,
  validate: {
    validator: function(v) {
      return v && v.length > 0;
    },
    message: 'A course should have at least one tag.'
  }
}
-------------------code----------------------

**Explanation:**

* `validate` is set to an **object** that includes:

  * `validator`: a function defining the validation logic.

    * `v` represents the field’s value.
    * It returns `true` if valid, `false` otherwise.
  * `message`: a custom error message displayed if validation fails.
* The condition `v && v.length > 0` ensures that:

  * The field is not `null` or `undefined`.
  * The array is not empty.

---

#### **3. Testing the Validator**

**Scenario 1 – Empty array:**

-------------------code----------------------
tags: []
-------------------code----------------------

**Output:**

-------------------code----------------------
A course should have at least one tag.
-------------------code----------------------

**Scenario 2 – Property excluded (not set):**

-------------------code----------------------
// tags not defined
-------------------code----------------------

**Output:**

-------------------code----------------------
A course should have at least one tag.
-------------------code----------------------

* Mongoose initializes an undefined array field as an empty array, so it triggers the same validation error.

**Scenario 3 – Null value:**

-------------------code----------------------
tags: null
-------------------code----------------------

**Without handling null:**

-------------------code----------------------
Cannot read property 'length' of null
-------------------code----------------------

**With corrected logic (v && v.length > 0):**

-------------------code----------------------
A course should have at least one tag.
-------------------code----------------------

---

### **4. Summary**

* Use **custom validators** for complex validation logic not covered by built-in options.
* Syntax:

  -------------------code----------------------
  validate: {
    validator: function(v) { /* logic */ },
    message: 'Custom error message'
  }
  -------------------code----------------------
* Always handle possible `null` or `undefined` values to avoid runtime errors.
* Common use cases:

  * Arrays requiring at least one element.
  * Strings requiring specific formatting beyond regex.
  * Relationships or dependent validations between fields.

---

Next lecture: **Asynchronous Custom Validators**.

*** 4- Async Validators ***
---

### **Asynchronous Validators in Mongoose**

#### **1. When to Use Async Validators**

* Sometimes validation depends on external data sources such as:

  * A **database query**
  * A **remote HTTP service**
  * The **file system**
* In such cases, the validator cannot return a result immediately — it must wait for an asynchronous operation to complete.

---

#### **2. Converting a Synchronous Validator to an Asynchronous One**

To make a validator asynchronous:

1. **Set the `isAsync` property to `true`.**
2. **Modify the validator function** to accept a **second parameter** — a **callback function**.
3. Perform the asynchronous task, then **invoke the callback** with the result.

---

#### **3. Example Implementation**

**Original (Synchronous) Validator:**

-------------------code----------------------
validate: {
  validator: function(v) {
    return v && v.length > 0;
  },
  message: 'A course should have at least one tag.'
}
-------------------code----------------------

**Converted to Asynchronous Validator:**

-------------------code----------------------
validate: {
  isAsync: true,
  validator: function(v, callback) {
    setTimeout(() => {
      const result = v && v.length > 0;
      callback(result);
    }, 4000); // Simulating async operation (4 seconds)
  },
  message: 'A course should have at least one tag.'
}
-------------------code----------------------

- we have error 
-------------------code----------------------
index4.js:23
          callback(result);
          ^

TypeError: callback is not a function

-------------------code----------------------

That happens because the isAsync option was deprecated starting from Mongoose v5.0, and removed in newer versions (v6 and above).
In modern Mongoose, async validators should return a Promise instead of using the old callback style.

Fixed Version (Modern Syntax)
-------------------code----------------------
validate: {
  validator: async function (v) {
    return new Promise((resolve) => {
      setTimeout(() => {
        const result = v && v.length > 0;
        resolve(result);
      }, 4000); // Simulating async operation (4 seconds)
    });
  },
  message: "A course should have at least one tag.",
},

-------------------code----------------------

---

#### **4. How It Works**

* The `setTimeout()` function simulates an asynchronous process such as:

  * Fetching data from a database.
  * Making a network request.
  * Reading from a file.
* After the async work completes, the **callback** is called with:

  * `true` → validation passes.
  * `false` → validation fails and the error message is shown.

---

#### **5. Example Test Run**

**Scenario:**

-------------------code----------------------
tags: []
-------------------code----------------------

**Terminal Output (after 4 seconds delay):**

-------------------code----------------------
A course should have at least one tag.
-------------------code----------------------

---

### **6. Summary**

* **Use async validators** when your validation logic depends on asynchronous operations.
* **Steps to implement:**

  1. Add `isAsync: true`.
  2. Use a callback function in your validator.
  3. Perform the async operation and call the callback with the result.
* This pattern ensures that Mongoose waits for the async validation result before saving the document.

---

Next lecture: **Getting Access to Individual Validation Errors**.

*** 5- Validation Errors ***
---

### **Understanding Validation Error Objects in Mongoose**

#### **1. Overview**

* When Mongoose validation fails, an **exception** is thrown.
* This exception includes detailed information about each invalid field.
* Inside the `catch` block, the error object contains a property called **`errors`**, which holds a set of **validation error objects**, one per invalid field.

---

#### **2. Example Setup**

**Course Object Example:**

-------------------code----------------------
const course = new Course({
  category: '-', // invalid value (enum error)
  tags: []       // invalid value (custom validator)
});
-------------------code----------------------

When validation fails, Mongoose throws an error object like this:

-------------------code----------------------
ValidationError: Course validation failed
-------------------code----------------------

This object has an **`errors`** property:

-------------------code----------------------
err.errors
-------------------code----------------------

Each property inside `err.errors` corresponds to a specific field that failed validation, such as:

* `err.errors.category`
* `err.errors.tags`

---

#### **3. Inspecting Validation Error Details**

**Iterating Over Errors:**

-------------------code----------------------
for (field in err.errors) {
  const validationError = err.errors[field];
  console.log(validationError);
}
-------------------code----------------------

Each `validationError` object contains several useful properties:

| Property     | Description                       | Example                                    |
| ------------ | --------------------------------- | ------------------------------------------ |
| `message`    | The error message                 | `"A course should have at least one tag."` |
| `name`       | Type of error object              | `"ValidatorError"`                         |
| `properties` | Detailed info about the validator | Contains `type`, `path`, and `value`       |
| `kind`       | Type of validation rule           | `"enum"`, `"user defined"`, etc.           |
| `path`       | Field name that failed validation | `"category"` or `"tags"`                   |
| `value`      | Invalid value passed              | `"-"` or `null`                            |

---

#### **4. Example Output Analysis**

For the invalid course object above:

* **Error 1 – `category`:**

  -------------------code----------------------
  message: '-' is not a valid enum value for path 'category'
  kind: 'enum'
  path: 'category'
  value: '-'
  -------------------code----------------------
* **Error 2 – `tags`:**

  -------------------code----------------------
  message: 'A course should have at least one tag.'
  kind: 'user defined'
  path: 'tags'
  value: null
  -------------------code----------------------

---

#### **5. Extracting Only the Error Messages**

To get only the messages for display or logging:

-------------------code----------------------
for (field in err.errors) {
  console.log(err.errors[field].message);
}
-------------------code----------------------

**Output:**

-------------------code----------------------
'-' is not a valid enum value for path 'category'
A course should have at least one tag.
-------------------code----------------------

---

### **6. Summary**

* Mongoose groups all validation errors under the `errors` object.
* Each field that fails validation produces a `ValidatorError` object.
* Key details include:

  * `message`: human-readable error
  * `kind`: type of validation (e.g., `enum`, `user defined`)
  * `path`: name of the field
  * `value`: invalid value
* To show user-friendly messages, simply access the `message` property for each error.

---

Next lecture: **Schema Types in Mongoose**.

*** 6- SchemaType Options ***
---

### **Additional Schema Type Properties in Mongoose**

#### **1. Schema Type Object Recap**

* In Mongoose, each property in a schema can be defined using either:

  * A simple type (e.g., `String`, `Number`, etc.), or
  * A **schema type object**, which allows specifying additional options and validators.

**Example:**

-------------------code----------------------
category: { type: String, required: true }
-------------------code----------------------

This object form supports multiple useful options beyond `type`, `required`, and `enum`.

---

### **2. String-Specific Properties**

Mongoose provides extra configuration options for **string** fields:

| Property    | Description                                    | Example           |
| ----------- | ---------------------------------------------- | ----------------- |
| `lowercase` | Converts the string to lowercase before saving | `lowercase: true` |
| `uppercase` | Converts the string to uppercase before saving | `uppercase: true` |
| `trim`      | Removes leading and trailing whitespace        | `trim: true`      |

**Example:**

-------------------code----------------------
category: {
  type: String,
  lowercase: true,
  trim: true
}
-------------------code----------------------

**Demonstration:**

* If you set:

  -------------------code----------------------
  category: ' Web '
  -------------------code----------------------
* The saved result in the database will be:

  -------------------code----------------------
  category: 'web'
  -------------------code----------------------
* These transformations are handled automatically by Mongoose.

---

### **3. Getters and Setters**

These functions allow you to customize how data is **stored** and **retrieved**.

#### **Setter**

* Executed **before saving** the value to the database.
* Commonly used to modify or sanitize the value before storage.

#### **Getter**

* Executed **when reading** the value from the database.
* Useful for formatting or transforming stored values when accessed.

---

#### **Example: Rounding Prices**

-------------------code----------------------
price: {
  type: Number,
  get: v => Math.round(v),
  set: v => Math.round(v)
}
-------------------code----------------------

**Behavior:**

* When saving `price: 15.8`, it will store `16`.
* When reading a previously stored value (e.g., `15.8`), it will return `16` through the getter.

---

#### **Demonstration Steps:**

1. **Save a Course**

   -------------------code----------------------
   price: 15.8
   -------------------code----------------------

   **Result in database:** `price = 16`

2. **Manually edit the document** in MongoDB to `15.8`.

3. **Read the document using Mongoose.**

   * Output: `price = 16`
     (The getter function automatically rounded the value.)

---

### **4. Notes**

* `lowercase`, `uppercase`, and `trim` apply only to **string** fields.
* `get` and `set` can be used on **any type of field**.
* Use getters for data formatting and setters for data consistency.
* Both can be combined with validation logic or other schema options.

---

### **5. Summary**

| Feature     | Applies To | Purpose                                   |
| ----------- | ---------- | ----------------------------------------- |
| `lowercase` | String     | Converts value to lowercase before saving |
| `uppercase` | String     | Converts value to uppercase before saving |
| `trim`      | String     | Removes leading/trailing spaces           |
| `get`       | Any type   | Format/transform value when **reading**   |
| `set`       | Any type   | Modify/transform value when **saving**    |

**Key takeaway:**
Schema type properties like `lowercase`, `trim`, `get`, and `set` help ensure data is clean, consistent, and formatted correctly both when stored and retrieved.

---

Next lecture: **Schema Type Options — Immutable Properties and Aliases**.
