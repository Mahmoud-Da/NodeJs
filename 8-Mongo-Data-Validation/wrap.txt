*** 1- Validation ***
**Lecture Title:** Validation in Mongoose  

**Overview:**  
This lecture explains how to implement validation in Mongoose, focusing on the `required` validator. It also discusses how validation works, error handling, and the difference between Mongoose and MongoDB validations.  

---

### 1. Default Behavior
- By default, all schema properties are **optional**.
- Example: If you create a course without a `name` or `price`, MongoDB allows it.  
- Validation is not enforced at the MongoDB level by default.

---

### 2. Implementing Required Validator
- Modify the schema to make a property required.
-------------------code----------------------
const courseSchema = new mongoose.Schema({
  name: { type: String, required: true },
  author: String,
  tags: [String],
  date: { type: Date, default: Date.now },
  isPublished: Boolean,
  price: Number
});
-------------------code----------------------
- If a course is saved without a `name`, Mongoose will throw a validation error.

---

### 3. Handling Validation Errors
- Saving a document returns a **promise**.
- Use `try-catch` to handle promise rejections:
-------------------code----------------------
async function createCourse() {
  try {
    const course = new Course();
    await course.save();
  } catch (ex) {
    console.log(ex.message);
  }
}
-------------------code----------------------
- Error Example:
-------------------code----------------------
Course validation failed: Path `name` is required.
-------------------code----------------------

---

### 4. Manual Validation
- You can manually trigger validation without saving:
-------------------code----------------------
await course.validate();
-------------------code----------------------
- Returns a promise of `void`.  
- If invalid, it throws an exception.

---

### 5. Callback-Based Validation
- Mongoose `validate` can also use a **callback** to detect errors:
-------------------code----------------------
course.validate((err) => {
  if (err) console.log(err.message);
});
-------------------code----------------------
- Returns a Boolean-like result through the callback.

---

### 6. Key Points About Mongoose Validation
- Validation occurs **only in Mongoose**, not at MongoDB level.
- MongoDB itself does not enforce required fields.
- Mongoose validations ensure documents are valid before saving.

---

### 7. Using Validation with REST APIs
- In REST APIs, you can use libraries like **Joi** to validate client input.
- Mongoose validation acts as a **second layer**:
  - Prevents invalid documents due to programming errors.
  - Ensures data integrity in the database even if the client sends correct data.

---

### 8. Summary
- Default schema properties are optional.  
- Use Mongoose validators like `required` to enforce constraints.  
- Always handle rejected promises when saving documents.  
- Manual validation is possible with `validate()`.  
- Validation in Mongoose complements client-side validation libraries like Joi.  

**Next Lecture:** Built-in validators in Mongoose.  

*** 2- Built-in Validators ***
---

### **Mongoose Built-in Validators**

#### **1. Required Validator**

* The `required` property ensures that a field must have a value.
* It can be set to:

  * A **boolean**: makes the field always required.
  * A **function** returning a boolean: makes the field **conditionally required**.

**Example:**

-------------------code----------------------
price: {
  type: Number,
  required: function() { return this.isPublished; }
}
-------------------code----------------------

* Here, `price` is required **only if** `isPublished` is `true`.
* **Important:**
  Do **not** use an arrow function (`=>`) because arrow functions don’t have their own `this`.
  They capture `this` from the outer scope, which would not refer to the Mongoose document instance.

**Example test result:**

* If `isPublished = true` and `price` is missing → validation error: *"Path `price` is required."*
* If `name` is also missing → another validation error for name.

---

#### **2. String Validators**

For string-type fields, Mongoose provides several built-in validators:

| Validator   | Description                          | Example                              |
| ----------- | ------------------------------------ | ------------------------------------ |
| `minlength` | Minimum allowed length               | `minlength: 5`                       |
| `maxlength` | Maximum allowed length               | `maxlength: 255`                     |
| `match`     | Regular expression pattern matching  | `match: /pattern/`                   |
| `enum`      | Restricts value to a predefined list | `enum: ['web', 'mobile', 'network']` |

**Example:**

-------------------code----------------------
category: {
  type: String,
  required: true,
  enum: ['web', 'mobile', 'network']
}
-------------------code----------------------

**Test Example:**

-------------------code----------------------
category: '-'
-------------------code----------------------

Output:

-------------------code----------------------
category: '-' is not a valid enum value for path 'category'.
-------------------code----------------------

---

#### **3. Number Validators**

For numeric fields:

| Validator | Description   | Example    |
| --------- | ------------- | ---------- |
| `min`     | Minimum value | `min: 10`  |
| `max`     | Maximum value | `max: 200` |

**Example:**

-------------------code----------------------
price: {
  type: Number,
  min: 10,
  max: 200
}
-------------------code----------------------

---

#### **4. Date Validators**

* Date fields can also use `min` and `max` validators to ensure the value falls within a specific range.

---

### **Summary**

* `required`: ensures a value is provided (can be conditional via a function).
* String validators: `minlength`, `maxlength`, `match`, `enum`.
* Number validators: `min`, `max`.
* Date validators: `min`, `max`.
* Avoid using arrow functions when referencing `this` in validators.

---

Next lecture: **Custom Validators in Mongoose**.


*** 3- Custom Validators ***
---

### **Custom Validators in Mongoose**

#### **1. When to Use Custom Validators**

* Built-in validators (e.g., `required`, `min`, `max`, `enum`) are often sufficient, but sometimes custom rules are needed.
* Example case: enforcing that an array (like `tags`) must have **at least one element**.
* The `required` validator alone cannot handle this because an empty array `[]` still passes validation.

---

#### **2. Defining a Custom Validator**

To define a custom validator, use the `validate` property in your schema field definition.

**Example:**

-------------------code----------------------
tags: {
  type: Array,
  validate: {
    validator: function(v) {
      return v && v.length > 0;
    },
    message: 'A course should have at least one tag.'
  }
}
-------------------code----------------------

**Explanation:**

* `validate` is set to an **object** that includes:

  * `validator`: a function defining the validation logic.

    * `v` represents the field’s value.
    * It returns `true` if valid, `false` otherwise.
  * `message`: a custom error message displayed if validation fails.
* The condition `v && v.length > 0` ensures that:

  * The field is not `null` or `undefined`.
  * The array is not empty.

---

#### **3. Testing the Validator**

**Scenario 1 – Empty array:**

-------------------code----------------------
tags: []
-------------------code----------------------

**Output:**

-------------------code----------------------
A course should have at least one tag.
-------------------code----------------------

**Scenario 2 – Property excluded (not set):**

-------------------code----------------------
// tags not defined
-------------------code----------------------

**Output:**

-------------------code----------------------
A course should have at least one tag.
-------------------code----------------------

* Mongoose initializes an undefined array field as an empty array, so it triggers the same validation error.

**Scenario 3 – Null value:**

-------------------code----------------------
tags: null
-------------------code----------------------

**Without handling null:**

-------------------code----------------------
Cannot read property 'length' of null
-------------------code----------------------

**With corrected logic (v && v.length > 0):**

-------------------code----------------------
A course should have at least one tag.
-------------------code----------------------

---

### **4. Summary**

* Use **custom validators** for complex validation logic not covered by built-in options.
* Syntax:

  -------------------code----------------------
  validate: {
    validator: function(v) { /* logic */ },
    message: 'Custom error message'
  }
  -------------------code----------------------
* Always handle possible `null` or `undefined` values to avoid runtime errors.
* Common use cases:

  * Arrays requiring at least one element.
  * Strings requiring specific formatting beyond regex.
  * Relationships or dependent validations between fields.

---

Next lecture: **Asynchronous Custom Validators**.

*** 4- Async Validators ***
---

### **Asynchronous Validators in Mongoose**

#### **1. When to Use Async Validators**

* Sometimes validation depends on external data sources such as:

  * A **database query**
  * A **remote HTTP service**
  * The **file system**
* In such cases, the validator cannot return a result immediately — it must wait for an asynchronous operation to complete.

---

#### **2. Converting a Synchronous Validator to an Asynchronous One**

To make a validator asynchronous:

1. **Set the `isAsync` property to `true`.**
2. **Modify the validator function** to accept a **second parameter** — a **callback function**.
3. Perform the asynchronous task, then **invoke the callback** with the result.

---

#### **3. Example Implementation**

**Original (Synchronous) Validator:**

-------------------code----------------------
validate: {
  validator: function(v) {
    return v && v.length > 0;
  },
  message: 'A course should have at least one tag.'
}
-------------------code----------------------

**Converted to Asynchronous Validator:**

-------------------code----------------------
validate: {
  isAsync: true,
  validator: function(v, callback) {
    setTimeout(() => {
      const result = v && v.length > 0;
      callback(result);
    }, 4000); // Simulating async operation (4 seconds)
  },
  message: 'A course should have at least one tag.'
}
-------------------code----------------------

- we have error 
-------------------code----------------------
index4.js:23
          callback(result);
          ^

TypeError: callback is not a function

-------------------code----------------------

That happens because the isAsync option was deprecated starting from Mongoose v5.0, and removed in newer versions (v6 and above).
In modern Mongoose, async validators should return a Promise instead of using the old callback style.

Fixed Version (Modern Syntax)
-------------------code----------------------
validate: {
  validator: async function (v) {
    return new Promise((resolve) => {
      setTimeout(() => {
        const result = v && v.length > 0;
        resolve(result);
      }, 4000); // Simulating async operation (4 seconds)
    });
  },
  message: "A course should have at least one tag.",
},

-------------------code----------------------

---

#### **4. How It Works**

* The `setTimeout()` function simulates an asynchronous process such as:

  * Fetching data from a database.
  * Making a network request.
  * Reading from a file.
* After the async work completes, the **callback** is called with:

  * `true` → validation passes.
  * `false` → validation fails and the error message is shown.

---

#### **5. Example Test Run**

**Scenario:**

-------------------code----------------------
tags: []
-------------------code----------------------

**Terminal Output (after 4 seconds delay):**

-------------------code----------------------
A course should have at least one tag.
-------------------code----------------------

---

### **6. Summary**

* **Use async validators** when your validation logic depends on asynchronous operations.
* **Steps to implement:**

  1. Add `isAsync: true`.
  2. Use a callback function in your validator.
  3. Perform the async operation and call the callback with the result.
* This pattern ensures that Mongoose waits for the async validation result before saving the document.

---

Next lecture: **Getting Access to Individual Validation Errors**.
