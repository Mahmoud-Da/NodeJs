*** 1- Introduction ***
**Lecture Notes: Authentication and Authorization in Vid.ly Application**

---

### 1. Overview

Up to this point, the **Vid.ly** application includes API endpoints to manage:

* Genres
* Movies
* Customers
* Rentals

The next step is to implement **authentication** and **authorization**, which are essential for most real-world applications.

---

### 2. Authentication vs. Authorization

| Concept            | Definition                                                                                          | Example                                   |
| ------------------ | --------------------------------------------------------------------------------------------------- | ----------------------------------------- |
| **Authentication** | The process of verifying the user’s identity — confirming that the user is who they claim to be.    | Logging in using a username and password. |
| **Authorization**  | The process of determining if an authenticated user has permission to perform a specific operation. | Allowing only admin users to delete data. |

---

### 3. Application Requirements

1. **Authenticated users** (logged-in users) can perform operations that modify data.

   * Example: Creating or updating a movie or genre.
2. **Anonymous users** (not logged in) can only **read** data.
3. **Admin users** have additional permissions:

   * They can **delete** data (second level of authorization).

---

### 4. Endpoints to Implement

To support authentication and authorization, two new endpoints are needed:

| Purpose                 | HTTP Method | Endpoint      | Description                    |
| ----------------------- | ----------- | ------------- | ------------------------------ |
| **Register a new user** | `POST`      | `/api/users`  | Creates a new user (signup)    |
| **Log in a user**       | `POST`      | `/api/logins` | Authenticates an existing user |

---

### 5. Why Use POST for Login?

* Even though logging in doesn’t create or update an existing record in the traditional sense, in **RESTful design**, login can be modeled as creating a new **login request** or **login command**.
* Thus, `POST /api/logins` is appropriate.
* You may optionally store login records in MongoDB (e.g., for audit purposes).

---

### 6. Exercise: Implement User Registration API

Implement an endpoint to **register new users**.

**Endpoint:**
`POST /api/users`

**User Schema Fields:**

* `name`: String
* `email`: String
* `password`: String

**Special Requirement:**

* In the schema definition, set the **email** field to be **unique**.

  -------------------code----------------------
  email: {
    type: String,
    unique: true
  }
  -------------------code----------------------

  This ensures that no two users can register with the same email address.

---

### 7. Summary

* Authentication = verifying identity.
* Authorization = verifying permission.
* Only authenticated users can modify data.
* Only admin users can delete data.
* Two main endpoints: `/api/users` (register) and `/api/logins` (login).
* Use `POST` for both operations.
* Ensure unique email addresses in MongoDB using the `unique` property.

---

Next step: Implement the **register new users API** in code.


*** 2- Creating the User Model ***
**Lecture Notes: Creating the User Model in Vid.ly Application**

---

### 1. Objective

In this lecture, we define a new **User model** in Mongoose to handle user data for registration and authentication.

---

### 2. File Setup

* Navigate to the **models** folder.
* Create a new file named **`user.js`**.
* To save time, copy the existing structure from **`genre.js`** and modify it.

---

### 3. Defining the User Schema

Instead of defining the schema as a separate constant, the schema object is defined inline when calling the `mongoose.model()` method.
This makes the file cleaner and more compact.

**Example structure:**

-------------------code----------------------
const mongoose = require('mongoose');
const Joi = require('joi');

const User = mongoose.model('User', new mongoose.Schema({
  name: {
    type: String,
    required: true,
    minlength: 5,
    maxlength: 50
  },
  email: {
    type: String,
    required: true,
    minlength: 5,
    maxlength: 255,
    unique: true
  },
  password: {
    type: String,
    required: true,
    minlength: 5,
    maxlength: 1024
  }
}));
-------------------code----------------------

**Notes:**

* **`name`**: required, between 5–50 characters.
* **`email`**: required, between 5–255 characters, and must be **unique**.
* **`password`**: required, between 5–1024 characters.

  * The higher max length is chosen because hashed passwords are long strings.
  * The plain text password sent by the user will later be hashed before being stored.

---

### 4. Validation Function

Create a validation function using Joi to validate incoming user data before saving to the database.

**Function:**

-------------------code----------------------
function validateUser(user) {
  const schema = Joi.object({
    name: Joi.string().min(5).max(50).required(),
    email: Joi.string().min(5).max(255).required().email(),
    password: Joi.string().min(5).max(255).required()
  });

  return schema.validate(user);
}
-------------------code----------------------

**Explanation:**

* Validates that:

  * `name` is between 5 and 50 characters.
  * `email` is valid and between 5 and 255 characters.
  * `password` is between 5 and 255 characters.
* The `password` here is **plain text**; it will be **hashed** later before being stored in MongoDB.

---

### 5. Exporting the Model and Validation Function

Export both the `User` model and `validateUser` function for use in the routes.

**Export:**

-------------------code----------------------
exports.User = User;
exports.validate = validateUser;
-------------------code----------------------

---

### 6. Summary

* Created **user.js** in the models folder.
* Defined a **User model** with properties: `name`, `email`, and `password`.
* Ensured the **email** is unique in the database.
* Added a **Joi validation** function for user input.
* Exported the model and validation function.

---

### 7. Next Step

In the next lecture, a **route** will be added to **register new users** using this `User` model.


*** 3- Registering Users ***
**Lecture Notes: Creating the User Registration Route in Vid.ly Application**

---

### 1. Objective

In this lecture, the goal is to **create a new API route to register users** in the application.
This route will handle user validation, prevent duplicate registrations, and save new users in MongoDB.

---

### 2. Setting Up the Route File

* Navigate to the **routes** folder.
* Create a new file named **`users.js`**.
* To save time, copy the **require statements** and the **first route** from `genres.js` and modify them for users.

**Required Modules:**

-------------------code----------------------
const mongoose = require('mongoose');
const express = require('express');
const router = express.Router();
const { User, validate } = require('../models/user');
-------------------code----------------------

---

### 3. Defining the POST Route

The route will handle **POST requests** for registering new users.

**Basic structure:**

-------------------code----------------------
router.post('/', async (req, res) => {
  // validation, duplicate check, saving new user
});
-------------------code----------------------

Finally, export the router:

-------------------code----------------------
module.exports = router;
-------------------code----------------------

---

### 4. Registering the Route in index.js

To make the new route accessible, update the main entry file (`index.js`):

-------------------code----------------------
const users = require('./routes/users');
app.use('/api/users', users);
-------------------code----------------------

This tells Express to use the users router for any endpoint starting with `/api/users`.

---

### 5. Implementing the Registration Logic

Inside `users.js`, implement the route logic.

**Steps:**

#### a. Validate the Request

Use the `validate` function from the user model to check if the input is valid.

-------------------code----------------------
const { error } = validate(req.body);
if (error) return res.status(400).send(error.details[0].message);
-------------------code----------------------

If the input data (name, email, or password) is invalid, return a **400 Bad Request**.

---

#### b. Check for Existing User

Before creating a new user, ensure that the email is not already registered.

-------------------code----------------------
let user = await User.findOne({ email: req.body.email });
if (user) return res.status(400).send('User already registered.');
-------------------code----------------------

* `findOne()` looks up a document based on a field (email in this case).
* If a user is found, return a 400 error.

---

#### c. Create and Save the User

If validation passes and the user does not exist, create a new user object.

-------------------code----------------------
user = new User({
  name: req.body.name,
  email: req.body.email,
  password: req.body.password
});
await user.save();
res.send(user);
-------------------code----------------------

* The user is saved to the database.
* The response returns the saved user object.

---

### 6. Testing the Route with Postman

**Endpoint:**
`POST http://localhost:3000/api/users`

**Request Body (JSON):**

-------------------code----------------------
{
  "name": "Mosh",
  "email": "programmingwithmosh@gmail.com",
  "password": "12345"
}
-------------------code----------------------

**Test Results:**

1. **Invalid Input** → returns `400 Bad Request` with the validation error message.

   * Example: “Name length must be at least 5 characters long.”
2. **Invalid Email** → returns `400 Bad Request`.
3. **Missing Password** → returns `400 Bad Request`.
4. **Valid Input** → returns `200 OK` with a user object containing `id`, `name`, `email`, and `password`.
5. **Duplicate Registration** → returns `400 Bad Request` with the message “User already registered.”

---

### 7. Next Step

Currently, the response includes the **password** field, which should not be returned to the client.
In the **next lecture**, the response will be modified to **exclude sensitive data** such as the password.

---

### 8. Summary

* Created `users.js` route for registering users.
* Validated request data using Joi.
* Checked if the user already exists with `findOne()`.
* Saved new users in MongoDB.
* Tested using Postman to ensure all validations work correctly.
* Next step: sanitize response to hide sensitive information.


## This error is happening because **your version of the MongoDB Node.js driver (used by Mongoose)** is **too old** for the version of MongoDB server you’re connecting to.

MongoDB 5.0+ and later versions (especially 7.x) **removed support for the old “OP_QUERY” wire protocol**, and older MongoDB drivers still use it internally.
So, when Mongoose tries to list collection indexes, MongoDB throws:

> `Unsupported OP_QUERY command: listIndexes. The client driver may require an upgrade.`

---

### **What’s Happening**

Your stack looks something like this:

* **Mongoose** (older version, possibly 5.x or early 6.x)
* **MongoDB Server** (modern, likely 6.x or 7.x)
* Mongoose internally uses an old MongoDB Node driver that calls a deprecated “OP_QUERY” command.
* The MongoDB server refuses it.

---

### **Solution**

#### 1. Upgrade Mongoose to the latest version

Run this command in your project root:

-------------------code----------------------
npm install mongoose@latest
-------------------code----------------------

That will automatically bring in a newer MongoDB Node.js driver compatible with MongoDB 7.x.

---

#### 2. (Optional but Recommended) Also update the MongoDB Node.js driver

You can explicitly update it too, though Mongoose will include it:

-------------------code----------------------
npm install mongodb@latest
-------------------code----------------------

---

#### 3. Verify your versions

After installing, check:

-------------------code----------------------
npm list mongoose mongodb
-------------------code----------------------

You should see something like:

-------------------code----------------------
mongoose@8.x.x
mongodb@6.x.x
-------------------code----------------------

These are fully compatible with MongoDB 7+.

---

#### 4. Restart the server

After updates, restart nodemon:

-------------------code----------------------
rs
-------------------code----------------------

or manually stop and rerun:

-------------------code----------------------
nodemon index.js
-------------------code----------------------

---

### **If You’re Using an Older MongoDB Server (e.g., 4.x)**

Make sure your MongoDB service version matches the driver:

* Old driver → old server
* New driver → new server

But since you’re on a modern local or Atlas instance, upgrading Mongoose is the correct fix.

---

### **Summary**

| Issue                                                   | Cause                                                 | Fix                                                    |
| ------------------------------------------------------- | ----------------------------------------------------- | ------------------------------------------------------ |
| `MongoError: Unsupported OP_QUERY command: listIndexes` | Old MongoDB driver using deprecated OP_QUERY protocol | Upgrade Mongoose (and optionally the `mongodb` driver) |

---

**Command Summary:**

-------------------code----------------------
npm install mongoose@latest mongodb@latest
nodemon index.js
-------------------code----------------------

That will fix the error and let your app connect to MongoDB properly.


## The error

-------------------code----------------------
Error: The provided mongoose instance is invalid
-------------------code----------------------

means **Fawn** (a library for handling MongoDB transactions) couldn’t recognize the Mongoose instance you passed to it with:

-------------------code----------------------
Fawn.init(mongoose);
-------------------code----------------------

This usually happens for **one of the following reasons:**

---

### 1. Mongoose isn’t imported correctly

Make sure you’re using **CommonJS require**, not ES modules.
Correct:

-------------------code----------------------
const mongoose = require('mongoose');
-------------------code----------------------

Wrong:

-------------------code----------------------
import mongoose from 'mongoose';
-------------------code----------------------

Fawn doesn’t work well with ES modules.

---

### 2. Fawn is initialized before the MongoDB connection

You must **connect to MongoDB first** before calling `Fawn.init(mongoose)`.

Correct order:

-------------------code----------------------
const mongoose = require('mongoose');
const Fawn = require('fawn');

mongoose.connect('mongodb://127.0.0.1/vidly')
  .then(() => console.log('Connected to MongoDB...'))
  .catch(err => console.error('Could not connect to MongoDB...', err));

Fawn.init(mongoose);
-------------------code----------------------

---

### 3. Incompatibility between Fawn and new Mongoose versions

Fawn is **outdated** and not fully compatible with **Mongoose 7 or 8+**.
Since you’re using a recent Node.js version (v24) and likely Mongoose 8, Fawn won’t work properly.

---

Recommended fix (modern way)

Instead of using Fawn, you can use **Mongoose’s built-in transactions**, which are safer and officially supported:

-------------------code----------------------
const session = await mongoose.startSession();
session.startTransaction();

try {
  await rental.save({ session });
  movie.numberInStock--;
  await movie.save({ session });

  await session.commitTransaction();
  session.endSession();
} catch (ex) {
  await session.abortTransaction();
  session.endSession();
  throw ex;
}
-------------------code----------------------

---

### Temporary workaround (if you want Fawn to work)

You can downgrade Mongoose to an older version that still supports Fawn:

-------------------code----------------------
npm install mongoose@5.13.15
-------------------code----------------------

Then restart your server:

-------------------code----------------------
npx nodemon index.js
-------------------code----------------------

---
*** 4- Using Lodash ***
### Lecture Notes: Using Lodash and Improving User Response Handling

#### 1. Goal

In this lecture, we modify the **POST method** in our users module to:

* Control what data is sent back to the client.
* Exclude sensitive fields like passwords.
* Introduce **Lodash**, a utility library for working with objects, arrays, and other data types.

---

#### 2. Excluding Sensitive Properties

We have two ways to return filtered user data to the client:

1. **Manually construct a custom object**

   -------------------code----------------------
   res.send({
     name: user.name,
     email: user.email
   });
   -------------------code----------------------

   This works, but it becomes repetitive when we have many properties.

2. **Using Lodash for cleaner code**
   Lodash provides a utility method called `pick()` that allows us to create a new object containing only the desired properties.

---

#### 3. Installing Lodash

In the terminal, run:

-------------------code----------------------
npm install lodash
-------------------code----------------------

*(Version used: 4.17.4)*

---

#### 4. Importing Lodash

At the top of the **users** module:

-------------------code----------------------
const _ = require('lodash');
-------------------code----------------------

By convention, Lodash is stored in a variable named `_` because it’s short and clear.

---

#### 5. Using `_.pick()`

The `pick` method allows us to extract only specific properties from an object.

Example:

-------------------code----------------------
_.pick(user, ['name', 'email']);
-------------------code----------------------

This returns a new object containing only the `name` and `email` properties from `user`.

We can use this instead of manually creating an object.

So, in the response:

-------------------code----------------------
res.send(_.pick(user, ['_id', 'name', 'email']));
-------------------code----------------------

This ensures the password and other internal fields are excluded.

---

#### 6. Using `_.pick()` for Request Body

We can also use it to sanitize incoming data before saving to the database:

-------------------code----------------------
let user = new User(_.pick(req.body, ['name', 'email', 'password']));
-------------------code----------------------

This helps prevent malicious users from adding unexpected properties to the request body.

---

#### 7. Testing

* Run the application:

  -------------------code----------------------
  nodemon index.js
  -------------------code----------------------
* Send a **POST request** using Postman.
* The response should include only:

  -------------------code----------------------
  {
    "_id": "...",
    "name": "...",
    "email": "..."
  }
  -------------------code----------------------

  No password or version fields appear in the response.

---

#### 8. Enforcing Password Complexity (Optional)

If you want to enforce password strength, you can use an additional NPM package:

-------------------code----------------------
npm install joi-password-complexity
-------------------code----------------------

It allows you to configure:

* Minimum and maximum length
* Required uppercase/lowercase letters
* Number of digits, etc.

Example usage (optional for now):

-------------------code----------------------
const passwordComplexity = require('joi-password-complexity');
-------------------code----------------------

---

#### 9. Next Step

Currently, passwords are stored as plain text, which is a major security issue.
In the next lecture, password **hashing** will be implemented to securely store them in the database.

---

### Summary

* Installed and used **Lodash** for cleaner object handling.
* Used `_.pick()` to select safe fields for database input and client output.
* Prepared the ground for **password hashing** in the next lecture.


*** 5- Hashing Passwords ***
### Lecture Notes: Hashing Passwords with bcrypt

#### 1. Purpose

In this lecture, we learn how to **securely store user passwords** by hashing them using the **bcrypt** library.
Hashing protects passwords by converting them into an irreversible encrypted format.

---

#### 2. Installing bcrypt

Run the following command in the terminal:

-------------------code----------------------
npm install bcrypt
-------------------code----------------------

*(Version used: 1.0.3)*

bcrypt is a widely used and trusted library for password hashing in Node.js.

---

#### 3. Creating a Playground File

To understand how bcrypt works, create a new file named `hash.js`.

At the top of the file:

-------------------code----------------------
const bcrypt = require('bcrypt');
-------------------code----------------------

---

#### 4. Understanding Salt

A **salt** is a random string added to a password before hashing to ensure that:

* Even if two users have the same password, their hashes will be different.
* Attackers cannot easily match hashed passwords using precomputed tables.

Example:

* Password: `1234`
* Salt: a random string added before hashing.
* Result: different hashes each time, even for the same password.

---

#### 5. Generating a Salt

Use the asynchronous method `bcrypt.genSalt()`:

-------------------code----------------------
async function run() {
  const salt = await bcrypt.genSalt(10); // 10 = number of rounds
  console.log(salt);
}

run();
-------------------code----------------------

Notes:

* The higher the number of rounds, the stronger and slower the hashing process.
* Default value: **10**
* Always use the **asynchronous version** to avoid blocking Node.js’s single thread.

---

#### 6. Hashing a Password

Once the salt is generated, use it to hash a password:

-------------------code----------------------
async function run() {
  const salt = await bcrypt.genSalt(10);
  const hashed = await bcrypt.hash('1234', salt);

  console.log(salt);
  console.log(hashed);
}

run();
-------------------code----------------------

Output:

* The first line shows the generated salt.
* The second line shows the hashed password, which includes the salt.

The salt is embedded inside the hashed password so bcrypt can extract it later when verifying user credentials.

---

#### 7. Integrating Hashing into User Registration

After testing, move this logic into the **user registration route** (`users.js`).

At the top of the file:

-------------------code----------------------
const bcrypt = require('bcrypt');
-------------------code----------------------

Inside the route handler:

-------------------code----------------------
const salt = await bcrypt.genSalt(10);
user.password = await bcrypt.hash(user.password, salt);
await user.save();
-------------------code----------------------

Now, passwords will be stored in their hashed form in the database.

---

#### 8. Cleaning Up Old Users

Before testing, delete the existing users collection because the old records contain plain text passwords:

* Open MongoDB Compass.
* Delete the **users** collection.

---

#### 9. Testing the Implementation

1. Run the server:

   -------------------code----------------------
   nodemon index.js
   -------------------code----------------------
2. Send a **POST** request in **Postman** to register a new user.
3. Check MongoDB Compass:

   * The new user’s password should appear as a **hashed string**, not plain text.

---

#### 10. Summary

* Installed and used bcrypt to hash passwords.
* Learned about **salt** and how it enhances password security.
* Integrated hashing into user registration.
* Verified that passwords are now securely stored in the database.

---

#### 11. Next Step

The next lecture will cover **authenticating users**, which involves verifying plain text passwords against the stored hashed passwords using bcrypt’s comparison method.


## why if i make the number larger of the salt it takes too much time
Excellent question — and very important for understanding **how password hashing works securely.**

Let’s break it down clearly.

---

### 1. What `bcrypt.genSalt(10)` Does

When you call:

-------------------code----------------------
bcrypt.genSalt(10);
-------------------code----------------------

the number you pass (`10`) is called the **cost factor** or **number of rounds**.

This number controls **how many times bcrypt internally runs its hashing algorithm** on the password.
It doesn’t mean “10 random characters” — it means **how computationally expensive the hashing process will be.**

---

### 2. Why a Larger Number Takes More Time

Each time you increase the cost factor by 1,
bcrypt **doubles** the amount of computation needed.

So roughly:

* `10` → baseline speed (used by most apps)
* `11` → ~2× slower than 10
* `12` → ~4× slower than 10
* `13` → ~8× slower than 10
* and so on...

That’s because bcrypt uses an **exponential scaling algorithm**.
The more rounds, the more CPU cycles are required to calculate the hash.

---

### 3. Why That’s Actually a Good Thing

This delay is **intentional and desirable** — it makes it much harder for attackers to guess or brute-force passwords.

If a hacker tries to crack passwords by testing millions of guesses, bcrypt’s computational cost slows them down drastically.

---

### 4. Choosing the Right Number

Typical values:

* **10** → standard for production use (fast and secure)
* **12** → more secure, slightly slower
* **14+** → for high-security systems, but hashing can take noticeable time (hundreds of milliseconds per password)

You should choose a number that:

* Is **slow enough** to deter attackers
* But **fast enough** to not annoy legitimate users during login or signup

---

### 5. Summary

| Cost Factor | Approx Relative Time | Notes                      |
| ----------- | -------------------- | -------------------------- |
| 8           | Fast, less secure    | For testing only           |
| 10          | Standard             | Common default             |
| 12          | Strong security      | Slower but safe            |
| 14+         | Very secure          | Might delay authentication |

---

So in short:

> Increasing the number in `bcrypt.genSalt()` makes the hashing **computationally harder**,
> which is **why it takes more time** — and also **why it’s more secure**.

