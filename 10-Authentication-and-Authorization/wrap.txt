*** 1- Introduction ***
**Lecture Notes: Authentication and Authorization in Vid.ly Application**

---

### 1. Overview

Up to this point, the **Vid.ly** application includes API endpoints to manage:

* Genres
* Movies
* Customers
* Rentals

The next step is to implement **authentication** and **authorization**, which are essential for most real-world applications.

---

### 2. Authentication vs. Authorization

| Concept            | Definition                                                                                          | Example                                   |
| ------------------ | --------------------------------------------------------------------------------------------------- | ----------------------------------------- |
| **Authentication** | The process of verifying the user’s identity — confirming that the user is who they claim to be.    | Logging in using a username and password. |
| **Authorization**  | The process of determining if an authenticated user has permission to perform a specific operation. | Allowing only admin users to delete data. |

---

### 3. Application Requirements

1. **Authenticated users** (logged-in users) can perform operations that modify data.

   * Example: Creating or updating a movie or genre.
2. **Anonymous users** (not logged in) can only **read** data.
3. **Admin users** have additional permissions:

   * They can **delete** data (second level of authorization).

---

### 4. Endpoints to Implement

To support authentication and authorization, two new endpoints are needed:

| Purpose                 | HTTP Method | Endpoint      | Description                    |
| ----------------------- | ----------- | ------------- | ------------------------------ |
| **Register a new user** | `POST`      | `/api/users`  | Creates a new user (signup)    |
| **Log in a user**       | `POST`      | `/api/logins` | Authenticates an existing user |

---

### 5. Why Use POST for Login?

* Even though logging in doesn’t create or update an existing record in the traditional sense, in **RESTful design**, login can be modeled as creating a new **login request** or **login command**.
* Thus, `POST /api/logins` is appropriate.
* You may optionally store login records in MongoDB (e.g., for audit purposes).

---

### 6. Exercise: Implement User Registration API

Implement an endpoint to **register new users**.

**Endpoint:**
`POST /api/users`

**User Schema Fields:**

* `name`: String
* `email`: String
* `password`: String

**Special Requirement:**

* In the schema definition, set the **email** field to be **unique**.

  -------------------code----------------------
  email: {
    type: String,
    unique: true
  }
  -------------------code----------------------

  This ensures that no two users can register with the same email address.

---

### 7. Summary

* Authentication = verifying identity.
* Authorization = verifying permission.
* Only authenticated users can modify data.
* Only admin users can delete data.
* Two main endpoints: `/api/users` (register) and `/api/logins` (login).
* Use `POST` for both operations.
* Ensure unique email addresses in MongoDB using the `unique` property.

---

Next step: Implement the **register new users API** in code.


*** 2- Creating the User Model ***
**Lecture Notes: Creating the User Model in Vid.ly Application**

---

### 1. Objective

In this lecture, we define a new **User model** in Mongoose to handle user data for registration and authentication.

---

### 2. File Setup

* Navigate to the **models** folder.
* Create a new file named **`user.js`**.
* To save time, copy the existing structure from **`genre.js`** and modify it.

---

### 3. Defining the User Schema

Instead of defining the schema as a separate constant, the schema object is defined inline when calling the `mongoose.model()` method.
This makes the file cleaner and more compact.

**Example structure:**

-------------------code----------------------
const mongoose = require('mongoose');
const Joi = require('joi');

const User = mongoose.model('User', new mongoose.Schema({
  name: {
    type: String,
    required: true,
    minlength: 5,
    maxlength: 50
  },
  email: {
    type: String,
    required: true,
    minlength: 5,
    maxlength: 255,
    unique: true
  },
  password: {
    type: String,
    required: true,
    minlength: 5,
    maxlength: 1024
  }
}));
-------------------code----------------------

**Notes:**

* **`name`**: required, between 5–50 characters.
* **`email`**: required, between 5–255 characters, and must be **unique**.
* **`password`**: required, between 5–1024 characters.

  * The higher max length is chosen because hashed passwords are long strings.
  * The plain text password sent by the user will later be hashed before being stored.

---

### 4. Validation Function

Create a validation function using Joi to validate incoming user data before saving to the database.

**Function:**

-------------------code----------------------
function validateUser(user) {
  const schema = Joi.object({
    name: Joi.string().min(5).max(50).required(),
    email: Joi.string().min(5).max(255).required().email(),
    password: Joi.string().min(5).max(255).required()
  });

  return schema.validate(user);
}
-------------------code----------------------

**Explanation:**

* Validates that:

  * `name` is between 5 and 50 characters.
  * `email` is valid and between 5 and 255 characters.
  * `password` is between 5 and 255 characters.
* The `password` here is **plain text**; it will be **hashed** later before being stored in MongoDB.

---

### 5. Exporting the Model and Validation Function

Export both the `User` model and `validateUser` function for use in the routes.

**Export:**

-------------------code----------------------
exports.User = User;
exports.validate = validateUser;
-------------------code----------------------

---

### 6. Summary

* Created **user.js** in the models folder.
* Defined a **User model** with properties: `name`, `email`, and `password`.
* Ensured the **email** is unique in the database.
* Added a **Joi validation** function for user input.
* Exported the model and validation function.

---

### 7. Next Step

In the next lecture, a **route** will be added to **register new users** using this `User` model.


*** 3- Registering Users ***
**Lecture Notes: Creating the User Registration Route in Vid.ly Application**

---

### 1. Objective

In this lecture, the goal is to **create a new API route to register users** in the application.
This route will handle user validation, prevent duplicate registrations, and save new users in MongoDB.

---

### 2. Setting Up the Route File

* Navigate to the **routes** folder.
* Create a new file named **`users.js`**.
* To save time, copy the **require statements** and the **first route** from `genres.js` and modify them for users.

**Required Modules:**

-------------------code----------------------
const mongoose = require('mongoose');
const express = require('express');
const router = express.Router();
const { User, validate } = require('../models/user');
-------------------code----------------------

---

### 3. Defining the POST Route

The route will handle **POST requests** for registering new users.

**Basic structure:**

-------------------code----------------------
router.post('/', async (req, res) => {
  // validation, duplicate check, saving new user
});
-------------------code----------------------

Finally, export the router:

-------------------code----------------------
module.exports = router;
-------------------code----------------------

---

### 4. Registering the Route in index.js

To make the new route accessible, update the main entry file (`index.js`):

-------------------code----------------------
const users = require('./routes/users');
app.use('/api/users', users);
-------------------code----------------------

This tells Express to use the users router for any endpoint starting with `/api/users`.

---

### 5. Implementing the Registration Logic

Inside `users.js`, implement the route logic.

**Steps:**

#### a. Validate the Request

Use the `validate` function from the user model to check if the input is valid.

-------------------code----------------------
const { error } = validate(req.body);
if (error) return res.status(400).send(error.details[0].message);
-------------------code----------------------

If the input data (name, email, or password) is invalid, return a **400 Bad Request**.

---

#### b. Check for Existing User

Before creating a new user, ensure that the email is not already registered.

-------------------code----------------------
let user = await User.findOne({ email: req.body.email });
if (user) return res.status(400).send('User already registered.');
-------------------code----------------------

* `findOne()` looks up a document based on a field (email in this case).
* If a user is found, return a 400 error.

---

#### c. Create and Save the User

If validation passes and the user does not exist, create a new user object.

-------------------code----------------------
user = new User({
  name: req.body.name,
  email: req.body.email,
  password: req.body.password
});
await user.save();
res.send(user);
-------------------code----------------------

* The user is saved to the database.
* The response returns the saved user object.

---

### 6. Testing the Route with Postman

**Endpoint:**
`POST http://localhost:3000/api/users`

**Request Body (JSON):**

-------------------code----------------------
{
  "name": "Mosh",
  "email": "programmingwithmosh@gmail.com",
  "password": "12345"
}
-------------------code----------------------

**Test Results:**

1. **Invalid Input** → returns `400 Bad Request` with the validation error message.

   * Example: “Name length must be at least 5 characters long.”
2. **Invalid Email** → returns `400 Bad Request`.
3. **Missing Password** → returns `400 Bad Request`.
4. **Valid Input** → returns `200 OK` with a user object containing `id`, `name`, `email`, and `password`.
5. **Duplicate Registration** → returns `400 Bad Request` with the message “User already registered.”

---

### 7. Next Step

Currently, the response includes the **password** field, which should not be returned to the client.
In the **next lecture**, the response will be modified to **exclude sensitive data** such as the password.

---

### 8. Summary

* Created `users.js` route for registering users.
* Validated request data using Joi.
* Checked if the user already exists with `findOne()`.
* Saved new users in MongoDB.
* Tested using Postman to ensure all validations work correctly.
* Next step: sanitize response to hide sensitive information.


## This error is happening because **your version of the MongoDB Node.js driver (used by Mongoose)** is **too old** for the version of MongoDB server you’re connecting to.

MongoDB 5.0+ and later versions (especially 7.x) **removed support for the old “OP_QUERY” wire protocol**, and older MongoDB drivers still use it internally.
So, when Mongoose tries to list collection indexes, MongoDB throws:

> `Unsupported OP_QUERY command: listIndexes. The client driver may require an upgrade.`

---

### **What’s Happening**

Your stack looks something like this:

* **Mongoose** (older version, possibly 5.x or early 6.x)
* **MongoDB Server** (modern, likely 6.x or 7.x)
* Mongoose internally uses an old MongoDB Node driver that calls a deprecated “OP_QUERY” command.
* The MongoDB server refuses it.

---

### **Solution**

#### 1. Upgrade Mongoose to the latest version

Run this command in your project root:

-------------------code----------------------
npm install mongoose@latest
-------------------code----------------------

That will automatically bring in a newer MongoDB Node.js driver compatible with MongoDB 7.x.

---

#### 2. (Optional but Recommended) Also update the MongoDB Node.js driver

You can explicitly update it too, though Mongoose will include it:

-------------------code----------------------
npm install mongodb@latest
-------------------code----------------------

---

#### 3. Verify your versions

After installing, check:

-------------------code----------------------
npm list mongoose mongodb
-------------------code----------------------

You should see something like:

-------------------code----------------------
mongoose@8.x.x
mongodb@6.x.x
-------------------code----------------------

These are fully compatible with MongoDB 7+.

---

#### 4. Restart the server

After updates, restart nodemon:

-------------------code----------------------
rs
-------------------code----------------------

or manually stop and rerun:

-------------------code----------------------
nodemon index.js
-------------------code----------------------

---

### **If You’re Using an Older MongoDB Server (e.g., 4.x)**

Make sure your MongoDB service version matches the driver:

* Old driver → old server
* New driver → new server

But since you’re on a modern local or Atlas instance, upgrading Mongoose is the correct fix.

---

### **Summary**

| Issue                                                   | Cause                                                 | Fix                                                    |
| ------------------------------------------------------- | ----------------------------------------------------- | ------------------------------------------------------ |
| `MongoError: Unsupported OP_QUERY command: listIndexes` | Old MongoDB driver using deprecated OP_QUERY protocol | Upgrade Mongoose (and optionally the `mongodb` driver) |

---

**Command Summary:**

-------------------code----------------------
npm install mongoose@latest mongodb@latest
nodemon index.js
-------------------code----------------------

That will fix the error and let your app connect to MongoDB properly.


## The error

-------------------code----------------------
Error: The provided mongoose instance is invalid
-------------------code----------------------

means **Fawn** (a library for handling MongoDB transactions) couldn’t recognize the Mongoose instance you passed to it with:

-------------------code----------------------
Fawn.init(mongoose);
-------------------code----------------------

This usually happens for **one of the following reasons:**

---

### 1. Mongoose isn’t imported correctly

Make sure you’re using **CommonJS require**, not ES modules.
Correct:

-------------------code----------------------
const mongoose = require('mongoose');
-------------------code----------------------

Wrong:

-------------------code----------------------
import mongoose from 'mongoose';
-------------------code----------------------

Fawn doesn’t work well with ES modules.

---

### 2. Fawn is initialized before the MongoDB connection

You must **connect to MongoDB first** before calling `Fawn.init(mongoose)`.

Correct order:

-------------------code----------------------
const mongoose = require('mongoose');
const Fawn = require('fawn');

mongoose.connect('mongodb://127.0.0.1/vidly')
  .then(() => console.log('Connected to MongoDB...'))
  .catch(err => console.error('Could not connect to MongoDB...', err));

Fawn.init(mongoose);
-------------------code----------------------

---

### 3. Incompatibility between Fawn and new Mongoose versions

Fawn is **outdated** and not fully compatible with **Mongoose 7 or 8+**.
Since you’re using a recent Node.js version (v24) and likely Mongoose 8, Fawn won’t work properly.

---

Recommended fix (modern way)

Instead of using Fawn, you can use **Mongoose’s built-in transactions**, which are safer and officially supported:

-------------------code----------------------
const session = await mongoose.startSession();
session.startTransaction();

try {
  await rental.save({ session });
  movie.numberInStock--;
  await movie.save({ session });

  await session.commitTransaction();
  session.endSession();
} catch (ex) {
  await session.abortTransaction();
  session.endSession();
  throw ex;
}
-------------------code----------------------

---

### Temporary workaround (if you want Fawn to work)

You can downgrade Mongoose to an older version that still supports Fawn:

-------------------code----------------------
npm install mongoose@5.13.15
-------------------code----------------------

Then restart your server:

-------------------code----------------------
npx nodemon index.js
-------------------code----------------------

---
*** 4- Using Lodash ***
### Lecture Notes: Using Lodash and Improving User Response Handling

#### 1. Goal

In this lecture, we modify the **POST method** in our users module to:

* Control what data is sent back to the client.
* Exclude sensitive fields like passwords.
* Introduce **Lodash**, a utility library for working with objects, arrays, and other data types.

---

#### 2. Excluding Sensitive Properties

We have two ways to return filtered user data to the client:

1. **Manually construct a custom object**

   -------------------code----------------------
   res.send({
     name: user.name,
     email: user.email
   });
   -------------------code----------------------

   This works, but it becomes repetitive when we have many properties.

2. **Using Lodash for cleaner code**
   Lodash provides a utility method called `pick()` that allows us to create a new object containing only the desired properties.

---

#### 3. Installing Lodash

In the terminal, run:

-------------------code----------------------
npm install lodash
-------------------code----------------------

*(Version used: 4.17.4)*

---

#### 4. Importing Lodash

At the top of the **users** module:

-------------------code----------------------
const _ = require('lodash');
-------------------code----------------------

By convention, Lodash is stored in a variable named `_` because it’s short and clear.

---

#### 5. Using `_.pick()`

The `pick` method allows us to extract only specific properties from an object.

Example:

-------------------code----------------------
_.pick(user, ['name', 'email']);
-------------------code----------------------

This returns a new object containing only the `name` and `email` properties from `user`.

We can use this instead of manually creating an object.

So, in the response:

-------------------code----------------------
res.send(_.pick(user, ['_id', 'name', 'email']));
-------------------code----------------------

This ensures the password and other internal fields are excluded.

---

#### 6. Using `_.pick()` for Request Body

We can also use it to sanitize incoming data before saving to the database:

-------------------code----------------------
let user = new User(_.pick(req.body, ['name', 'email', 'password']));
-------------------code----------------------

This helps prevent malicious users from adding unexpected properties to the request body.

---

#### 7. Testing

* Run the application:

  -------------------code----------------------
  nodemon index.js
  -------------------code----------------------
* Send a **POST request** using Postman.
* The response should include only:

  -------------------code----------------------
  {
    "_id": "...",
    "name": "...",
    "email": "..."
  }
  -------------------code----------------------

  No password or version fields appear in the response.

---

#### 8. Enforcing Password Complexity (Optional)

If you want to enforce password strength, you can use an additional NPM package:

-------------------code----------------------
npm install joi-password-complexity
-------------------code----------------------

It allows you to configure:

* Minimum and maximum length
* Required uppercase/lowercase letters
* Number of digits, etc.

Example usage (optional for now):

-------------------code----------------------
const passwordComplexity = require('joi-password-complexity');
-------------------code----------------------

---

#### 9. Next Step

Currently, passwords are stored as plain text, which is a major security issue.
In the next lecture, password **hashing** will be implemented to securely store them in the database.

---

### Summary

* Installed and used **Lodash** for cleaner object handling.
* Used `_.pick()` to select safe fields for database input and client output.
* Prepared the ground for **password hashing** in the next lecture.


*** 5- Hashing Passwords ***
### Lecture Notes: Hashing Passwords with bcrypt

#### 1. Purpose

In this lecture, we learn how to **securely store user passwords** by hashing them using the **bcrypt** library.
Hashing protects passwords by converting them into an irreversible encrypted format.

---

#### 2. Installing bcrypt

Run the following command in the terminal:

-------------------code----------------------
npm install bcrypt
-------------------code----------------------

*(Version used: 1.0.3)*

bcrypt is a widely used and trusted library for password hashing in Node.js.

---

#### 3. Creating a Playground File

To understand how bcrypt works, create a new file named `hash.js`.

At the top of the file:

-------------------code----------------------
const bcrypt = require('bcrypt');
-------------------code----------------------

---

#### 4. Understanding Salt

A **salt** is a random string added to a password before hashing to ensure that:

* Even if two users have the same password, their hashes will be different.
* Attackers cannot easily match hashed passwords using precomputed tables.

Example:

* Password: `1234`
* Salt: a random string added before hashing.
* Result: different hashes each time, even for the same password.

---

#### 5. Generating a Salt

Use the asynchronous method `bcrypt.genSalt()`:

-------------------code----------------------
async function run() {
  const salt = await bcrypt.genSalt(10); // 10 = number of rounds
  console.log(salt);
}

run();
-------------------code----------------------

Notes:

* The higher the number of rounds, the stronger and slower the hashing process.
* Default value: **10**
* Always use the **asynchronous version** to avoid blocking Node.js’s single thread.

---

#### 6. Hashing a Password

Once the salt is generated, use it to hash a password:

-------------------code----------------------
async function run() {
  const salt = await bcrypt.genSalt(10);
  const hashed = await bcrypt.hash('1234', salt);

  console.log(salt);
  console.log(hashed);
}

run();
-------------------code----------------------

Output:

* The first line shows the generated salt.
* The second line shows the hashed password, which includes the salt.

The salt is embedded inside the hashed password so bcrypt can extract it later when verifying user credentials.

---

#### 7. Integrating Hashing into User Registration

After testing, move this logic into the **user registration route** (`users.js`).

At the top of the file:

-------------------code----------------------
const bcrypt = require('bcrypt');
-------------------code----------------------

Inside the route handler:

-------------------code----------------------
const salt = await bcrypt.genSalt(10);
user.password = await bcrypt.hash(user.password, salt);
await user.save();
-------------------code----------------------

Now, passwords will be stored in their hashed form in the database.

---

#### 8. Cleaning Up Old Users

Before testing, delete the existing users collection because the old records contain plain text passwords:

* Open MongoDB Compass.
* Delete the **users** collection.

---

#### 9. Testing the Implementation

1. Run the server:

   -------------------code----------------------
   nodemon index.js
   -------------------code----------------------
2. Send a **POST** request in **Postman** to register a new user.
3. Check MongoDB Compass:

   * The new user’s password should appear as a **hashed string**, not plain text.

---

#### 10. Summary

* Installed and used bcrypt to hash passwords.
* Learned about **salt** and how it enhances password security.
* Integrated hashing into user registration.
* Verified that passwords are now securely stored in the database.

---

#### 11. Next Step

The next lecture will cover **authenticating users**, which involves verifying plain text passwords against the stored hashed passwords using bcrypt’s comparison method.


## why if i make the number larger of the salt it takes too much time
Excellent question — and very important for understanding **how password hashing works securely.**

Let’s break it down clearly.

---

### 1. What `bcrypt.genSalt(10)` Does

When you call:

-------------------code----------------------
bcrypt.genSalt(10);
-------------------code----------------------

the number you pass (`10`) is called the **cost factor** or **number of rounds**.

This number controls **how many times bcrypt internally runs its hashing algorithm** on the password.
It doesn’t mean “10 random characters” — it means **how computationally expensive the hashing process will be.**

---

### 2. Why a Larger Number Takes More Time

Each time you increase the cost factor by 1,
bcrypt **doubles** the amount of computation needed.

So roughly:

* `10` → baseline speed (used by most apps)
* `11` → ~2× slower than 10
* `12` → ~4× slower than 10
* `13` → ~8× slower than 10
* and so on...

That’s because bcrypt uses an **exponential scaling algorithm**.
The more rounds, the more CPU cycles are required to calculate the hash.

---

### 3. Why That’s Actually a Good Thing

This delay is **intentional and desirable** — it makes it much harder for attackers to guess or brute-force passwords.

If a hacker tries to crack passwords by testing millions of guesses, bcrypt’s computational cost slows them down drastically.

---

### 4. Choosing the Right Number

Typical values:

* **10** → standard for production use (fast and secure)
* **12** → more secure, slightly slower
* **14+** → for high-security systems, but hashing can take noticeable time (hundreds of milliseconds per password)

You should choose a number that:

* Is **slow enough** to deter attackers
* But **fast enough** to not annoy legitimate users during login or signup

---

### 5. Summary

| Cost Factor | Approx Relative Time | Notes                      |
| ----------- | -------------------- | -------------------------- |
| 8           | Fast, less secure    | For testing only           |
| 10          | Standard             | Common default             |
| 12          | Strong security      | Slower but safe            |
| 14+         | Very secure          | Might delay authentication |

---

So in short:

> Increasing the number in `bcrypt.genSalt()` makes the hashing **computationally harder**,
> which is **why it takes more time** — and also **why it’s more secure**.

*** 6- Authenticating Users ***
### Lecture Notes — Authentication Route (`os.js`) Setup

#### 1. Creating the Authentication Route File

* Inside the **routes** folder, create a new file named **`os.js`** (or `logins.js`, but `os.js` is more common).
* Copy the structure from **`users.js`** and paste it into `os.js` to save time.

#### 2. Importing and Registering the Route

* Open **`index.js`** and import the new module:

  -------------------code----------------------
  const os = require('./routes/os');
  -------------------code----------------------
* Register the route:

  -------------------code----------------------
  app.use('/api/os', os);
  -------------------code----------------------
* This means any request sent to `/api/os` or its subroutes will be handled by the **os router**.

#### 3. Adjusting the Validation Function

* The validation function imported from the user module checks for:

  * `name`
  * `email`
  * `password`
* However, for login, only **email** and **password** are needed.
* Therefore:

  * Remove the imported validation function.
  * Define a new **validate function** directly inside `os.js`:

    -------------------code----------------------
    function validate(req) {
      const schema = {
        email: Joi.string().min(5).max(255).required().email(),
        password: Joi.string().min(5).max(255).required()
      };
      return Joi.validate(req, schema);
    }
    -------------------code----------------------

#### 4. Validating User Existence

* After validating input, check if a user exists with the given email:

  -------------------code----------------------
  const user = await User.findOne({ email: req.body.email });
  if (!user) return res.status(400).send('Invalid email or password.');
  -------------------code----------------------
* **Why 400 and not 404?**

  * Returning 404 (Not Found) reveals that the email is invalid.
  * To prevent information leakage, use a **generic error message** for both wrong email and wrong password.

#### 5. Validating the Password

* Use **bcrypt** to compare the plain text password with the stored hash:

  -------------------code----------------------
  const validPassword = await bcrypt.compare(req.body.password, user.password);
  if (!validPassword) return res.status(400).send('Invalid email or password.');
  -------------------code----------------------
* `bcrypt.compare()`:

  * Takes the plain password and the hashed password.
  * Extracts the salt from the stored hash.
  * Re-hashes the plain password using that salt.
  * Returns `true` if they match.

#### 6. Successful Login

* If both checks pass:

  -------------------code----------------------
  res.send(true);
  -------------------code----------------------
* (Later, this will be replaced with generating and returning a JSON Web Token (JWT)).

---

### Summary of `os.js`

-------------------code----------------------
const express = require('express');
const router = express.Router();
const Joi = require('joi');
const bcrypt = require('bcrypt');
const { User } = require('../models/user');

router.post('/', async (req, res) => {
  const { error } = validate(req.body);
  if (error) return res.status(400).send(error.details[0].message);

  const user = await User.findOne({ email: req.body.email });
  if (!user) return res.status(400).send('Invalid email or password.');

  const validPassword = await bcrypt.compare(req.body.password, user.password);
  if (!validPassword) return res.status(400).send('Invalid email or password.');

  res.send(true);
});

function validate(req) {
  const schema = {
    email: Joi.string().min(5).max(255).required().email(),
    password: Joi.string().min(5).max(255).required()
  };
  return Joi.validate(req, schema);
}

module.exports = router;
-------------------code----------------------

---

*** 7- Testing the Authentication ***
### Lecture Notes: Testing the Authentication Endpoint

#### 1. Testing the “Create User” Endpoint

* Begin by testing the **user registration** endpoint.
* To save time when testing later:

  * Save the request in your API testing tool (like Postman).
  * Give it a name, e.g., **“Register User”**.
  * Create a new **collection** called **“vidly”**.
  * This allows you to reuse the saved request easily without recreating it each time.

#### 2. Setting Up for Authentication Testing

* Open a **new tab** in the API testing tool.
* Send a **POST** request to:

  -------------------code----------------------
  http://localhost/api/auth
  -------------------code----------------------
* In the **body**, send a JSON object with the following fields:

  -------------------code----------------------
  {
    "email": "programmingwithmosh10@gmail.com",
    "password": "12345"
  }
  -------------------code----------------------

#### 3. Fixing the “Joy is not defined” Error

* When sending the request, if it **hangs** or throws an error in the terminal:

  -------------------code----------------------
  Joy is not defined
  -------------------code----------------------
* Cause: The `Joi` library (used for input validation) was referenced but **not imported**.
* Fix:

  * At the top of `os.js`, add:

    -------------------code----------------------
    const Joi = require("joi");
    -------------------code----------------------

#### 4. Retesting After the Fix

* Send the request again after importing Joi.
* Expected result:

  * Response status: **200 OK**
  * Response body:

    -------------------code----------------------
    true
    -------------------code----------------------
  * This confirms successful authentication.

#### 5. Testing Invalid Credentials

* Try changing the password:

  * Example: `"password": "wrongpass"`
  * Response: **400 Bad Request**
  * Message: `"Invalid email or password"`
* Try changing the email:

  * Example: `"email": "wrongemail@gmail.com"`
  * Response: **400 Bad Request**
  * Same generic message to prevent leaking which field is incorrect.

#### 6. Summary of Behavior

* Valid credentials → `200 OK` with `true` response.
* Invalid credentials → `400 Bad Request` with `"Invalid email or password"`.
* The endpoint now works correctly and handles errors securely.

#### 7. Next Step

* In the next lecture, the instructor will modify the authentication response to include a **JSON Web Token (JWT)** instead of a simple boolean response.

*** 8- JSON Web Tokens ***
### Lecture Notes: JSON Web Tokens (JWT)

#### 1. Purpose of Modifying the Response

* The authentication endpoint currently returns a simple `true` value upon success.
* This needs to be replaced with a **JSON Web Token (JWT)**.
* A JWT acts as an **identifier** for the user — similar to a **driver’s license** or **passport**.

#### 2. Concept of a JSON Web Token

* When a user logs in:

  1. The **server** generates a JWT.
  2. The **client** (browser or mobile app) receives it and stores it.
  3. For future API calls, the client sends this token to the server as proof of identity.

* This token allows the client to access protected endpoints without needing to log in again.

#### 3. Storage on the Client

* **For web applications (React, Angular, etc.):**
  Use **local storage** in the browser to store the JWT.
* **For mobile applications:**
  Use the platform’s equivalent secure storage mechanism.

#### 4. Example of a JWT

* Go to **[jwt.io](https://jwt.io)** — a site with a JWT debugger.
* The **encoded section** displays the JWT as a long string.
* When decoded, it becomes a **JSON object**.
* The JWT is divided into **three parts**, each color-coded:

  1. **Header (red)**
  2. **Payload (purple)**
  3. **Signature (blue)**

#### 5. Structure of a JWT

1. **Header**

   * Contains metadata about the token:

     -------------------code----------------------
     {
       "alg": "HS256",
       "typ": "JWT"
     }
     -------------------code----------------------
   * `alg` → the algorithm used for encoding.
   * `typ` → token type, which is always `"JWT"`.
   * Usually handled automatically — developers rarely modify it.

2. **Payload**

   * The main data section, containing **public information about the user**:

     -------------------code----------------------
     {
       "sub": "user_id",
       "name": "John Doe",
       "admin": true
     }
     -------------------code----------------------
   * Similar to a passport containing personal information (name, birth date, etc.).
   * Can include:

     * User ID (`sub`)
     * User name
     * Whether the user is an admin, etc.
   * This allows the server to read user details **without querying the database** every time.

3. **Signature**

   * Ensures the token has **not been altered**.
   * Created by combining:

     * The encoded header and payload.
     * A **secret (private key)** known **only to the server**.
   * If the token is modified (e.g., setting `admin: true` manually), the signature becomes **invalid**, and the server **rejects** it.

#### 6. Security and Validation

* JWTs are **tamper-proof** because of their digital signature.
* Even if a user modifies the payload, they cannot recreate a valid signature without the **server’s private key**.
* Therefore:

  * Any tampered token will be **rejected** by the server.
  * The server can always verify the integrity of a JWT.

#### 7. Summary

* A **JWT** securely represents a user’s identity.
* It has **three parts**: header, payload, and signature.
* It enables **stateless authentication**, meaning the server doesn’t need to keep a session for each user.
* The next step will be implementing JWT generation on the server and sending it to the client upon login.

*** 9- Generating Authentication Tokens ***

### Lecture Notes: Generating JSON Web Tokens (JWT) in Node.js

#### 1. Installing the JWT Library

* On the [jwt.io](https://jwt.io) website, you can see libraries for working with JWTs in different programming languages (e.g., .NET, Python, Node.js).
* In Node.js, install the JWT package by running in the terminal:

  -------------------code----------------------
  npm install jsonwebtoken@8.1.1
  -------------------code----------------------

#### 2. Importing the Library

* In the **auth module**, import the library at the top of the file:

  -------------------code----------------------
  const jwt = require('jsonwebtoken');
  -------------------code----------------------

#### 3. Creating a Token

* Inside the route handler (the authentication endpoint), create a JWT **before returning the response**.
* Use the `jwt.sign()` method:

  -------------------code----------------------
  const token = jwt.sign({ _id: user._id }, 'jwtPrivateKey');
  -------------------code----------------------

  * **First argument (payload):**

    * The data you want to include inside the token.
    * In this example, it is an object containing one property:

      -------------------code----------------------
      { _id: user._id }
      -------------------code----------------------
    * This allows the client or the server to identify the user based on their database ID.

  * **Second argument (private key):**

    * A secret key used to generate the **digital signature**.
    * For now, it’s hardcoded as `'jwtPrivateKey'`.
    * In real-world applications, you **must not store secrets in the source code**.
    * Later, this key will be stored in an **environment variable** for security.

#### 4. Returning the Token

* Once the token is created, send it as the response to the client:

  -------------------code----------------------
  res.send(token);
  -------------------code----------------------
* This token will be used by the client for future API calls to authenticate requests.

#### 5. Testing the Token

* Open **Postman** (or any API testing tool).
* Send a valid **email** and **password** to the `/api/auth` endpoint.
* The response should contain a long string — this is your JWT.

#### 6. Inspecting the Token

* Copy the token and visit **[jwt.io](https://jwt.io)**.
* In the **debugger** section:

  * Delete the existing example token.
  * Paste your generated token.
* You will see the **decoded payload**, which includes:

  -------------------code----------------------
  {
    "_id": "userObjectIdFromMongoDB",
    "iat": 1731000000
  }
  -------------------code----------------------

  * `_id`: The MongoDB user ID.
  * `iat`: “Issued At” — a timestamp showing when the token was created.
  * This helps determine the token’s age and validity period.

#### 7. Summary

* Installed and imported the `jsonwebtoken` library.
* Created a JWT with `jwt.sign()` using a payload and private key.
* Returned the generated token to the client.
* Verified the token’s contents on **jwt.io**.
* Next step: **Move the private key to an environment variable** for improved security.


*** 10- Storing Secrets in Environment Variables ***
### Lecture Notes: Managing Secrets with Environment Variables using Config

#### 1. Purpose

* The goal is to **remove hardcoded secrets** (like the JWT private key) from the source code.
* Storing secrets in the code is a **security risk**, as anyone with access to the source can view them.
* Instead, secrets should be stored in **environment variables** and accessed using the **Config** module.

---

#### 2. Installing the Config Module

* Install the package in the terminal:

  -------------------code----------------------
  npm install config@1.29.4
  -------------------code----------------------

---

#### 3. Creating the Configuration Folder and Files

* Create a folder named **`config`** in the project root.

##### (a) default.json

* Inside the config folder, create a file named **`default.json`**.
* This file defines the **template** for your application settings:

  -------------------code----------------------
  {
    "jwtPrivateKey": ""
  }
  -------------------code----------------------
* The value is left empty — it will be provided later via an environment variable.

##### (b) custom-environment-variables.json

* Create another file named **`custom-environment-variables.json`**.
* This file maps configuration keys to **environment variables**.
* Copy the same structure from `default.json`, then update it:

  -------------------code----------------------
  {
    "jwtPrivateKey": "vidly_jwtPrivateKey"
  }
  -------------------code----------------------
* **Naming convention:**

  * Prefix the variable with your application name (e.g., `vidly_`) to prevent conflicts with variables from other applications.

---

#### 4. Updating the Auth Module (auth.js)

##### (a) Import the Config Module

Add this line at the top:

-------------------code----------------------
const config = require('config');
-------------------code----------------------

##### (b) Use the Config Value Instead of a Hardcoded Secret

Replace the hardcoded key in the `jwt.sign()` method:

-------------------code----------------------
const token = jwt.sign({ _id: user._id }, config.get('jwtPrivateKey'));
-------------------code----------------------

* `config.get('jwtPrivateKey')` retrieves the secret value from the environment variable.

---

#### 5. Verifying the Environment Variable at Startup

* Open **index.js** (main entry point).
* Import the Config module at the top:

  -------------------code----------------------
  const config = require('config');
  -------------------code----------------------
* Add a check to ensure the environment variable is set:

  -------------------code----------------------
  if (!config.get('jwtPrivateKey')) {
    console.error('FATAL ERROR: jwtPrivateKey is not defined.');
    process.exit(1);
  }
  -------------------code----------------------
* Explanation:

  * `process.exit(1)` stops the application when the key is missing.
  * Exit code `1` means **failure**, while `0` indicates **success**.

---

#### 6. Testing the Setup

1. **Run the Application Without Setting the Variable**

   -------------------code----------------------
   nodemon index.js
   -------------------code----------------------

   * Output:

     -------------------code----------------------
     FATAL ERROR: jwtPrivateKey is not defined.
     app crashed waiting for file changes before starting...
     -------------------code----------------------
   * Although `nodemon` continues running, the actual Node process has **stopped**, so the server won’t respond to HTTP requests.

2. **Manually Set the Environment Variable**

   * On **Mac/Linux**:

     -------------------code----------------------
     export vidly_jwtPrivateKey=mySecureKey
     -------------------code----------------------
   * On **Windows (Command Prompt)**:

     -------------------code----------------------
     set vidly_jwtPrivateKey=mySecureKey
     -------------------code----------------------

3. **Run the Application Again**

   -------------------code----------------------
   node index.js
   -------------------code----------------------

   * Output:

     -------------------code----------------------
     Connected to MongoDB...
     -------------------code----------------------
   * The app starts successfully.

4. **Test Authentication in Postman**

   * Send a valid login request.
   * You’ll receive a valid JWT, **signed using the private key stored in the environment variable**.

---

#### 7. Summary

* Installed and configured the **Config** module to manage settings.
* Defined a **default.json** for configuration structure and a **custom-environment-variables.json** for mapping.
* Updated the **auth module** to use `config.get()` instead of hardcoding secrets.
* Added a **startup validation** in `index.js` to ensure the environment variable exists.
* Verified the setup by running the app and generating a valid JWT signed with the environment-stored key.


### which approach is better using env file or this config ?
both `.env` files and the **config** package can manage environment-specific settings and secrets, but they serve slightly different purposes and offer different advantages. Here’s a detailed comparison to help you choose the right approach for your case.

---

### **1. Overview**

| Feature           | `.env` File (dotenv)                                | `config` Package                                                           |
| ----------------- | --------------------------------------------------- | -------------------------------------------------------------------------- |
| **Purpose**       | Store environment variables in a single `.env` file | Manage structured configuration (defaults, overrides, environment mapping) |
| **Access Method** | `process.env.VARIABLE_NAME`                         | `config.get('settingName')`                                                |
| **Format**        | Simple key-value pairs                              | JSON-based structured configuration                                        |
| **Use Case**      | Small or simple apps                                | Medium–large apps with multiple environments                               |

---

### **2. `.env` File (dotenv)**

#### **How It Works**

* You create a `.env` file in your project root:

  -------------------code----------------------env
  PORT=3000
  JWT_PRIVATE_KEY=mySecureKey
  DB_URL=mongodb://localhost/myapp
  -------------------code----------------------
* Load it with:

  -------------------code----------------------
  require('dotenv').config();
  const key = process.env.JWT_PRIVATE_KEY;
  -------------------code----------------------

#### **Pros**

* **Simple and lightweight.** Easy to understand and implement.
* **Works well for small or single-environment projects.**
* **Commonly used with frameworks** like Express, NestJS, and React.
* **Compatible with most hosting platforms** (e.g., Vercel, Render, Heroku) that use environment variables natively.

#### **Cons**

* **No built-in structure or validation.**

  * It’s just flat key-value pairs — you can’t easily group settings or check types.
* **No layered configuration.**

  * You can’t easily have different defaults for `development`, `staging`, `production`.
* **No automatic environment-specific overrides.**

  * You must manually change `.env` or manage multiple files like `.env.dev`, `.env.prod`.

---

### **3. `config` Package**

#### **How It Works**

* You define JSON config files (e.g., `default.json`, `production.json`) under a `config/` directory:

  -------------------code----------------------
  // default.json
  {
    "jwtPrivateKey": "",
    "db": {
      "host": "localhost",
      "name": "vidly"
    }
  }
  -------------------code----------------------
* Then you map environment variables in `custom-environment-variables.json`:

  -------------------code----------------------
  {
    "jwtPrivateKey": "vidly_jwtPrivateKey"
  }
  -------------------code----------------------
* Access values with:

  -------------------code----------------------
  const config = require('config');
  const key = config.get('jwtPrivateKey');
  -------------------code----------------------

#### **Pros**

* **Structured configuration.**

  * You can organize settings hierarchically (e.g., `db.host`, `db.name`).
* **Environment-specific overrides.**

  * Use files like `production.json` or `development.json` to automatically switch config per environment.
* **Integration with environment variables.**

  * Combines both JSON config and environment variable mapping cleanly.
* **Centralized and maintainable.**

  * Excellent for large projects with many configurable options.

#### **Cons**

* **Slightly more setup overhead.**

  * You must maintain multiple config files.
* **Less standard in simple setups.**

  * Some deployment platforms expect `.env` usage by default.
* **Not as portable** to other environments that rely purely on `process.env`.

---

### **4. Recommended Use Cases**

| Use Case                                             | Recommended Approach                                            |
| ---------------------------------------------------- | --------------------------------------------------------------- |
| Small personal project                               | `.env` (simpler setup)                                          |
| Medium/large Node.js API                             | `config` (better organization and structure)                    |
| Multi-environment deployment (dev/staging/prod)      | `config`                                                        |
| Serverless / cloud deployment (Heroku, Vercel, etc.) | `.env` or native environment variables                          |
| App where secrets rotate dynamically                 | `.env` or managed secrets via cloud (AWS Secrets Manager, etc.) |

---

### **5. Combined Best Practice**

In modern Node.js projects, a **hybrid approach** is often ideal:

* Use the **`config` package** for structured app configuration (e.g., DB host, feature flags).
* Use **environment variables** (possibly loaded from `.env`) for **sensitive data** like API keys or private tokens.

Example hybrid setup:

first install
-------------------code----------------------
npm install dotenv
-------------------code----------------------

-------------------code----------------------
// config/default.json
{
  "db": {
    "host": "localhost",
    "name": "vidly"
  },
  "jwtPrivateKey": ""
}

// config/custom-environment-variables.json
{
  "jwtPrivateKey": "VIDLY_JWT_PRIVATE_KEY"
}

// .env
VIDLY_JWT_PRIVATE_KEY=mySecureKey
-------------------code----------------------

And in `index.js`:

-------------------code----------------------
require('dotenv').config();
const config = require('config');
const key = config.get('jwtPrivateKey');
-------------------code----------------------

---

### **6. Summary**

| Criteria                              | Winner                                  |
| ------------------------------------- | --------------------------------------- |
| **Ease of use**                       | `.env`                                  |
| **Scalability**                       | `config`                                |
| **Security**                          | Both (when used properly with env vars) |
| **Best for large enterprise apps**    | `config`                                |
| **Best for small or hosted projects** | `.env`                                  |

---

**In your case (Vidly project)** — since it’s a backend application with structured settings (DB, JWT key, etc.) —
**Using the `config` package** is the better and more scalable choice.
But for simplicity or deployment convenience, you can still load sensitive values from `.env` into config, achieving the best of both.

*** 11- Setting Response Headers  ***
### Lecture Notes: Returning JWT in HTTP Headers upon Registration

---

#### **1. Current Implementation**

* When a user logs in, the server **generates a JSON Web Token (JWT)** and **returns it in the response body**.
* Goal: Improve this behavior to automatically log in users immediately after registration.

---

#### **2. New Requirement**

* Upon registration, users should be **automatically logged in** (receive a JWT).
* This simulates a **local application environment** (like Vidly in a local video store) where:

  * Users are internal employees.
  * Email verification is not necessary.

---

#### **3. Implementation Steps**

1. **Locate the Registration Endpoint**

   * In the **users module**, find the POST method handling user registration.
   * Currently, it returns a JSON object with user details.

2. **Generate the JWT**

   * Instead of only returning user info, **generate a JWT** before sending the response.
   * Copy the JWT creation logic from the **auth module**:

     -------------------code----------------------
     const token = jwt.sign({ _id: user._id }, config.get('jwtPrivateKey'));
     -------------------code----------------------

3. **Set JWT in Response Header**

   * Rather than including the token in the response body, add it as a **custom HTTP header**:

     -------------------code----------------------
     res.header('x-auth-token', token).send({
       _id: user._id,
       name: user.name,
       email: user.email
     });
     -------------------code----------------------
   * Custom headers should begin with the prefix `X-` (e.g., `X-Auth-Token`).

---

#### **4. Required Imports**

At the top of the **users.js** file:

-------------------code----------------------
const jwt = require('jsonwebtoken');
const config = require('config');
-------------------code----------------------

---

#### **5. Testing the Implementation**

1. Start the server with **nodemon** to automatically reload on code changes:

   -------------------code----------------------
   nodemon index.js
   -------------------code----------------------
2. In **Postman**:

   * Send a `POST` request to the user registration endpoint.
   * Use a **new email** each time to avoid duplicate user errors.
3. Check the response:

   * **Body:** User data (same as before).
   * **Headers:** A new header named `x-auth-token` containing the JWT.

---

#### **6. Client-Side Behavior**

* The client can now:

  1. Read the `x-auth-token` header from the response.
  2. Store it locally (e.g., in `localStorage` or cookies).
  3. Include it in subsequent API requests for authentication.

---

#### **7. Summary**

* Returning JWTs in **headers** keeps the response cleaner.
* Automatic login after registration enhances user experience for trusted environments.
* Using `X-Auth-Token` standardizes custom authentication headers.

*** 12- Encapsulating Logic in Mongoose Models ***
### Lecture Notes: Encapsulating JSON Web Token (JWT) Logic in the User Model

---

#### **Problem Overview**

* In the current implementation:

  * The `users` module (line 22) and the `auth` module (line 21) both generate a **JSON Web Token (JWT)** using the same logic.
  * The payload of the JWT currently includes only the user’s **ID**.
  * In the future, more properties (e.g., **name**, **email**, **role**) may need to be added to the payload.

* **Issue:**
  Each time we modify the payload, we must update multiple modules (auth, users, etc.).
  This is **error-prone** and **violates the DRY (Don’t Repeat Yourself)** principle.

---

#### **Goal**

Encapsulate the JWT generation logic in a **single place** to ensure maintainability and reusability.

---

#### **Initial (Incorrect) Approach**

* A beginner might think of creating a utility function like:

  -------------------code----------------------
  function generateAuthToken() { ... }
  -------------------code----------------------

  and import it wherever needed.

* While this works, it leads to **scattered functions** across the codebase and poor organization.

---

#### **Better Approach: Information Expert Principle**

* **Definition:**
  The object that has enough information to perform a specific task should be responsible for it.

* **Analogy:**
  A **chef** cooks because they have the necessary knowledge and tools — not the waiter.
  Likewise, the **user object** has all the necessary information for generating its own JWT.

---

#### **Implementation Steps**

1. **Identify the responsible object**
   → The **User** object is the best candidate since it holds user-related data.

2. **Move the token generation logic into the User model**

   **Before:**
   JWT logic exists in both `auth.js` and `users.js`.

   **After:**
   The logic resides as a **method inside the user schema**.

---

#### **Code Changes**

##### **1. Define a schema constant**

In `user.js`:

-------------------code----------------------
const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  password: String
});
-------------------code----------------------

##### **2. Add a method to the schema**

-------------------code----------------------
userSchema.methods.generateAuthToken = function() {
  const token = jwt.sign(
    { _id: this._id },
    config.get('jwtPrivateKey')
  );
  return token;
};
-------------------code----------------------

> **Notes:**
>
> * Use a **regular function**, not an arrow function.
> * `this` refers to the user instance.
> * Arrow functions don’t bind their own `this`.

##### **3. Create the model**

-------------------code----------------------
const User = mongoose.model('User', userSchema);
-------------------code----------------------

##### **4. Refactor other modules**

* **In `auth.js`:**

  -------------------code----------------------
  const token = user.generateAuthToken();
  -------------------code----------------------

* **In `users.js`:**

  -------------------code----------------------
  const token = user.generateAuthToken();
  -------------------code----------------------

* Remove duplicate JWT logic and `require` statements from these modules.

##### **5. Import necessary dependencies in `user.js`:**

-------------------code----------------------
const jwt = require('jsonwebtoken');
const config = require('config');
-------------------code----------------------

---

#### **Testing**

1. Register a new user.
2. Observe JWT generation.
3. If an error appears (e.g., `jwt is not defined`), ensure imports are placed correctly in `user.js`.

**After fixing imports:**

* The user registers successfully.
* JWT is generated correctly and returned in the response.

---

#### **Key Takeaways**

* Centralizing logic simplifies maintenance.
* Follow the **Information Expert Principle**: let the object with the right data handle the relevant logic.
* Avoid code duplication between modules.
* Use **regular functions** for object methods when referencing `this`.

---

#### **Final Structure**

-------------------code----------------------
models/
 └── user.js       ← contains schema + generateAuthToken method
routes/
 ├── auth.js       ← uses user.generateAuthToken()
 └── users.js      ← uses user.generateAuthToken()
-------------------code----------------------

This organization ensures cleaner, modular, and more maintainable code.

*** 13- Authorization Middleware ***
### Lecture Notes: Implementing Authentication Middleware in Express

---

#### **Goal**

Protect all routes that **modify data** (e.g., POST, PUT, DELETE) by ensuring they are accessible **only to authenticated users**.

---

#### **1. The Problem**

* Currently, routes like the `POST /api/genres` endpoint can be accessed by anyone.
* We want only **authenticated users** (those with a valid JSON Web Token) to be able to create, update, or delete data.

---

#### **2. Initial Implementation Idea**

* In the route handler (e.g., `genres.js`), we could manually:

  1. Read the request headers.
  2. Extract the token from `x-auth-token`.
  3. Validate the token.
  4. Allow or deny access based on validation results.

**Example (conceptual):**

-------------------code----------------------
const token = req.header('x-auth-token');
if (!token) return res.status(401).send('Access denied. No token provided.');
-------------------code----------------------

However, repeating this logic in every route that modifies data leads to **code duplication** and **poor maintainability**.

---

#### **3. Solution: Use Middleware**

* **Middleware functions** in Express allow us to encapsulate reusable logic that executes before route handlers.
* We can create a **custom authentication middleware** that:

  * Checks for the presence of a token.
  * Verifies the token’s validity.
  * Adds the decoded user info to the request object.
  * Either terminates the request or passes control to the next handler.

---

#### **4. Implementation Steps**

##### **Step 1: Create a Middleware Folder**

Structure:

-------------------code----------------------
project/
 ├── middleware/
 │    └── auth.js
 ├── routes/
 │    └── genres.js
 ├── models/
 │    └── user.js
-------------------code----------------------

##### **Step 2: Define the Auth Middleware**

In `middleware/auth.js`:

-------------------code----------------------
const jwt = require('jsonwebtoken');
const config = require('config');

module.exports = function (req, res, next) {
  const token = req.header('x-auth-token');
  if (!token) return res.status(401).send('Access denied. No token provided.');

  try {
    const decoded = jwt.verify(token, config.get('jwtPrivateKey'));
    req.user = decoded; // Attach the decoded payload (e.g., user ID) to the request
    next(); // Pass control to the next middleware or route handler
  } 
  catch (ex) {
    res.status(400).send('Invalid token.');
  }
};
-------------------code----------------------

**Notes:**

* Use `401` for missing token → unauthorized access.
* Use `400` for invalid token → bad request.
* The `try...catch` block ensures that invalid tokens don’t crash the server.
* The decoded payload is stored as `req.user`, so route handlers can easily access it.

---

#### **5. Applying the Middleware**

In `routes/genres.js`:

-------------------code----------------------
const auth = require('../middleware/auth');

router.post('/', auth, async (req, res) => {
  // Only authenticated users can reach this point
  const genre = new Genre({ name: req.body.name });
  await genre.save();
  res.send(genre);
});
-------------------code----------------------

* The `auth` middleware runs **before** the route handler.
* If the token is invalid or missing, the route handler never executes.

---

#### **6. Token Generation Recap**

In the `user.js` model, we already have the following method:

-------------------code----------------------
userSchema.methods.generateAuthToken = function () {
  const token = jwt.sign({ _id: this._id }, config.get('jwtPrivateKey'));
  return token;
};
-------------------code----------------------

* The payload of the JWT includes user data such as `_id`.
* When decoded in the middleware, this becomes `req.user`, allowing downstream code to know which user made the request.

---

#### **7. Middleware Behavior Summary**

| Condition         | Action          | Status Code | Message                             |
| ----------------- | --------------- | ----------- | ----------------------------------- |
| No token provided | Request denied  | 401         | “Access denied. No token provided.” |
| Invalid token     | Request denied  | 400         | “Invalid token.”                    |
| Valid token       | Request allowed | —           | —                                   |

---

#### **8. Key Concepts**

* **Middleware Function:**
  Executes before route handlers; can either terminate the request or call `next()` to continue the pipeline.

* **Token Verification:**
  Ensures that only legitimate users (with valid JWTs) can modify resources.

* **Error Handling:**
  Always handle missing or invalid tokens to prevent server crashes and improve client-side debugging.

---

#### **9. Final Structure Overview**

-------------------code----------------------
models/
 └── user.js          ← defines generateAuthToken()
middleware/
 └── auth.js          ← verifies JWT and protects routes
routes/
 └── genres.js        ← uses auth middleware for protected endpoints
-------------------code----------------------

---

#### **10. Summary**

By creating a reusable authentication middleware:

* We centralize JWT verification logic.
* We avoid duplicating code in multiple route files.
* We ensure all modifying operations are protected by authentication checks.
* This leads to cleaner, safer, and more maintainable Express applications.


*** 14- Protecting Routes ***
### Lecture Notes: Applying Authentication Middleware Selectively in Express

---

#### **1. Background**

* Previously, we created an authentication middleware (`auth.js`) that verifies JSON Web Tokens (JWTs) and ensures that only authenticated users can access protected API endpoints.
* Now we must decide **where and how** to apply this middleware within our Express application.

---

#### **2. Applying Middleware Globally vs. Selectively**

* In `index.js`, middleware functions can be applied globally using:

  -------------------code----------------------
  app.use(auth);
  -------------------code----------------------

  This would execute the middleware **before every route handler**.

* **However**, not all API endpoints require authentication:

  * **Public endpoints:**

    * Registering a new user
    * Logging in
    * Retrieving a list of genres or customers
  * **Protected endpoints:**

    * Creating, updating, or deleting data

* Therefore, applying `auth` globally is not ideal.
  Instead, we should apply it **selectively** to specific routes that modify data.

---

#### **3. Selective Application Example**

##### **In `genres.js`:**

* Import the `auth` middleware at the top:

  -------------------code----------------------
  const auth = require('../middleware/auth');
  -------------------code----------------------

* Use it in the route definition:

  -------------------code----------------------
  router.post('/', auth, async (req, res) => {
    const genre = new Genre({ name: req.body.name });
    await genre.save();
    res.send(genre);
  });
  -------------------code----------------------

**Explanation:**

* The `router.post()` method accepts multiple arguments:

  1. The **route path** (`'/'`).
  2. One or more **middleware functions** (e.g., `auth`).
  3. The **route handler** function that executes if all previous middleware succeed.

* Here, `auth` will run **before** the route handler.
  If authentication fails, the route handler never executes.

---

#### **4. Testing the Middleware**

**Step 1: Missing Token**

* Send a `POST` request to `/api/genres` without any headers.
* Response:

  -------------------code----------------------
  Status: 401 Unauthorized
  Message: Access denied. No token provided.
  -------------------code----------------------

**Step 2: Invalid Token**

* In Postman, go to the **Headers** tab.
* Add:

  -------------------code----------------------
  Key: X-Auth-Token
  Value: <invalid-token>
  -------------------code----------------------
* Send the request.
* Response:

  -------------------code----------------------
  Status: 400 Bad Request
  Message: Invalid token.
  -------------------code----------------------

**Step 3: Valid Token**

* Get a valid JWT from the registration or login endpoint.
* Add it to the headers:

  -------------------code----------------------
  Key: X-Auth-Token
  Value: <valid-token>
  -------------------code----------------------
* Send the request without a valid body.
* Response:

  -------------------code----------------------
  Status: 400 Bad Request
  Reason: Missing required data (e.g., name property).
  -------------------code----------------------
* Add a proper request body:

  -------------------code----------------------
  {
    "name": "new genre"
  }
  -------------------code----------------------
* Send again.
* Response:

  -------------------code----------------------
  Status: 200 OK
  Body: { "_id": "123...", "name": "new genre" }
  -------------------code----------------------

---

#### **5. Summary of Responses**

| Situation                 | Status | Message                           | Explanation                              |
| ------------------------- | ------ | --------------------------------- | ---------------------------------------- |
| No token provided         | 401    | Access denied. No token provided. | Request lacks authentication token       |
| Invalid token provided    | 400    | Invalid token.                    | Token is malformed or expired            |
| Valid token, missing data | 400    | Bad request (e.g., missing name)  | Authentication passed, but input invalid |
| Valid token and data      | 200    | Success (returns created data)    | Authorized and valid request             |

---

#### **6. Exercise**

Apply the `auth` middleware to **all route handlers** that modify data, such as:

* `router.put()` for updating a resource
* `router.delete()` for removing a resource
* Any `router.post()` that creates a new entry

Example:

-------------------code----------------------
router.put('/:id', auth, async (req, res) => { ... });
router.delete('/:id', auth, async (req, res) => { ... });
-------------------code----------------------

---

#### **7. Key Takeaways**

* Use authentication middleware **selectively**, not globally.
* Public routes should remain accessible without authentication.
* Protected routes should always include the `auth` middleware.
* Middleware order matters: it must precede the route handler in the route definition.
* Testing through tools like Postman helps verify correct status codes and behavior.

---

#### **8. Final Structure Example**

-------------------code----------------------
middleware/
 └── auth.js          ← JWT verification logic
routes/
 ├── genres.js        ← POST/PUT/DELETE use auth middleware
 ├── users.js         ← Register endpoint (public)
 └── auth.js          ← Login endpoint (public)
-------------------code----------------------

This approach ensures that only authorized users can perform data modifications while keeping essential endpoints publicly accessible.

*** 15- Getting the Current User ***
### Lecture Notes: Getting the Currently Logged-In User in Express

---

#### **1. Overview**

In many web applications, it is common to need information about the **currently logged-in user** — for example, to display their profile or account data.
In this lecture, we will implement an API endpoint to retrieve that user’s information securely.

---

#### **2. Current Situation**

* In the `users` module, there is currently only one route handler for **creating a new user** (a `POST` request).
* We now need to add a **GET** endpoint that returns the data of the currently authenticated user.

---

#### **3. Security Considerations**

* One possible approach is to create a route like:

  -------------------code----------------------
  router.get('/:id', async (req, res) => { ... });
  -------------------code----------------------

  This would require the client to send the user ID in the request path.

* However, this can pose **security risks**:

  * A user could send another person’s ID and access information they shouldn’t see.
  * For example, sending `/api/users/123` might expose private data.

* To avoid this, we use a **“me”** endpoint:

  -------------------code----------------------
  GET /api/users/me
  -------------------code----------------------

  * The client does **not** send the user ID.
  * The server extracts the ID from the **JSON Web Token (JWT)**, ensuring the request truly belongs to the logged-in user.
  * This approach is safer and more common in production applications.

---

#### **4. Implementation Steps**

##### **Step 1: Add the Route Handler**

In `users.js`:

-------------------code----------------------
router.get('/me', auth, async (req, res) => {
  const user = await User.findById(req.user._id).select('-password');
  res.send(user);
});
-------------------code----------------------

##### **Explanation:**

* `'/me'` → defines a custom endpoint for the current user.
* `auth` → applies the authentication middleware to ensure only logged-in users can access it.
* `req.user._id` → comes from the JWT payload decoded in the `auth` middleware.
* `.select('-password')` → excludes the password field before sending data to the client.

---

#### **5. Loading the Middleware**

On top of `users.js`:

-------------------code----------------------
const auth = require('../middleware/auth');
-------------------code----------------------

**Note on Terminology:**

* `auth` here stands for **authorization**, not authentication.

  * **Authentication** verifies a user’s credentials (e.g., username/password).
  * **Authorization** determines whether an authenticated user can access a specific resource.

---

#### **6. How It Works**

1. A client sends a request to `/api/users/me`.
2. The `auth` middleware runs first:

   * It looks for a valid token in the request header (`x-auth-token`).
   * If the token is missing or invalid, the request is rejected with:

     -------------------code----------------------
     401 Access denied. No token provided.
     -------------------code----------------------
3. If the token is valid:

   * The middleware decodes it, attaches the user information to `req.user`.
   * The request continues to the route handler.
4. In the handler:

   * The user is fetched from the database using the ID from `req.user`.
   * Sensitive fields (like `password`) are excluded.
   * The user object is returned as the response.

---

#### **7. Testing the Endpoint**

**Step 1: Without a Token**

* Method: `GET`
* URL: `http://localhost:3000/api/users/me`
* No token in headers.
* **Response:**

  -------------------code----------------------
  Status: 401 Unauthorized
  Message: Access denied. No token provided.
  -------------------code----------------------

**Step 2: With a Valid Token**

* Go to the **Headers** tab in Postman.
* Add:

  -------------------code----------------------
  Key: x-auth-token
  Value: <valid JWT token>
  -------------------code----------------------
* Send the request again.
* **Response:**

  -------------------code----------------------
  {
    "_id": "671e92b3f5a8b2c0c8a5c233",
    "name": "John Doe",
    "email": "john@example.com"
  }
  -------------------code----------------------

  The `password` field is excluded from the output.

---

#### **8. Summary of Key Points**

| Concept            | Description                           |
| ------------------ | ------------------------------------- |
| **Endpoint**       | `/api/users/me`                       |
| **Method**         | `GET`                                 |
| **Access Control** | Protected by `auth` middleware        |
| **Purpose**        | Return the current user’s info        |
| **Data Source**    | JWT token (contains the user’s ID)    |
| **Sensitive Data** | Excluded using `.select('-password')` |

---

#### **9. Security Benefits**

* Users cannot request information for other users.
* The user ID comes from a verified JWT, preventing tampering.
* No sensitive data (like passwords) is exposed.
* The same logic can later be reused for role-based access control (admin routes, etc.).

---

#### **10. Final Code Structure**

-------------------code----------------------
models/
 └── user.js          ← defines user schema and generateAuthToken()
middleware/
 └── auth.js          ← verifies JWT and sets req.user
routes/
 └── users.js         ← includes '/me' route for current user
-------------------code----------------------

---

#### **11. Summary**

By adding a secure `/api/users/me` endpoint and using the `auth` middleware, the application can safely return information about the currently logged-in user without requiring a user ID in the request. This enhances both **security** and **user experience**.


*** 16- Logging Out Users ***
### Lecture Notes: Logging Out Users and Token Storage Best Practices

---

#### 1. No Need for a Logout Route on the Server

* In the authentication module, a route is defined for **authenticating users**.
* However, there is **no need to create a separate route for logging out** users.
* Reason: The server **does not store tokens**; thus, there’s nothing to delete or invalidate server-side.

---

#### 2. Logout Implementation on the Client

* The **logout process** should be implemented entirely on the **client side**.
* When the user logs out, the client should **delete the authentication token** (e.g., from localStorage, sessionStorage, or cookies).
* Once the token is deleted, the user can no longer access protected API endpoints.

---

#### 3. Why Tokens Should Not Be Stored on the Server

* **Tokens act like keys** that grant access to protected resources.
* If stored on the server (for example, in a database):

  * A hacker who gains database access could **steal all tokens**.
  * The attacker could then **impersonate users** without needing their passwords.
* Therefore, storing tokens on the server is a **serious security risk**.

---

#### 4. Exception: If Tokens Must Be Stored

* Only store tokens server-side if **absolutely necessary** and if you **know what you are doing**.
* In such cases, **encrypt or hash** the tokens before saving them.
* Never store tokens in **plain text**, as it’s equivalent to keeping unprotected copies of user IDs or passports.

---

#### 5. Security Analogy

* Storing tokens in a database is like collecting everyone’s **driver’s licenses or passports** in one location.
* If someone accesses that location, they can **impersonate any user** easily.

---

#### 6. HTTPS Requirement for Token Transmission

* Always use **HTTPS** when sending tokens from client to server.
* This ensures that data is **encrypted during transmission**, protecting against **man-in-the-middle (MITM)** attacks.
* Without HTTPS, an attacker could intercept and read the token in transit.

---

#### 7. Summary

* **Logout**: Implement on client-side by deleting the token.
* **Token Storage**: Never store tokens on the server; if you must, encrypt them.
* **Transmission Security**: Always use HTTPS to protect token integrity.

This approach keeps your application secure and ensures tokens remain confidential.

### **HTTPS is not something you add directly in your application source code** (like in Express routes or middleware).

Here’s the breakdown:

---

### 1. HTTPS Is Configured at the Server or Infrastructure Level

You don’t add HTTPS logic *inside* your Node.js code.
Instead, you configure it in **the server environment** or **reverse proxy** layer, for example:

* **Nginx** or **Apache** (most common)
* **Cloud services** (like AWS, GCP, Vercel, or Render)
* **Load balancers** that handle SSL termination

These are responsible for:

* Holding your **SSL/TLS certificate** and private key
* Encrypting traffic between the client and the server

Your Node.js app just receives decrypted HTTP requests after that layer handles encryption.

---

### 2. When You *Can* Use HTTPS in Node.js Code (for Testing or Simple Deployments)

If you are **not using Nginx or a proxy**, you can run your app directly with HTTPS using Node’s `https` module.

Example:

-------------------code----------------------
const https = require("https");
const fs = require("fs");
const express = require("express");
const app = express();

const options = {
  key: fs.readFileSync("private.key"),
  cert: fs.readFileSync("certificate.crt"),
};

https.createServer(options, app).listen(443, () => {
  console.log("Secure server running on port 443...");
});
-------------------code----------------------

But this approach is usually for **development** or **small-scale** servers — in production,
it’s much better to terminate HTTPS at the proxy (like Nginx).

---

### 3. In Production (Best Practice)

Typical production setup:

* Client ↔ **HTTPS** ↔ Nginx (SSL termination) ↔ **HTTP** ↔ Node.js app

This means:

* Nginx handles the HTTPS layer (encryption/decryption)
* Node.js continues to run a normal HTTP Express app

---

### Summary

| Setting                | Where HTTPS is Configured   | Example                           |
| ---------------------- | --------------------------- | --------------------------------- |
| **Development**        | Node.js (`https` module)    | Directly in code                  |
| **Production**         | Server / Proxy (e.g. Nginx) | Via SSL certificate configuration |
| **App Code (Express)** | No change needed            | Express handles requests normally |

---

Would you like me to show you an example of how to configure HTTPS using **Nginx + Express** (the standard production method)?
