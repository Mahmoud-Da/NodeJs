*** 1- What is Automated Testing ***
# Automated Testing

## Lecture Notes

### 1. Common Questions About Automated Testing

Developers often ask:

* What is automated testing?
* Is it a replacement for manual testing?
* Do I really need it?
* How should I do it?
* Should I use test-driven development (TDD) or write application code first?
* What exactly should I test?

These questions form the foundation of this course, and each will be answered step by step.

---

## 2. What Is Automated Testing?

Automated testing is the practice of writing code that tests our application code and running those tests automatically.

In any project, your source code will consist of:

* **Application (production) code**
* **Test code**

---

## 3. Manual Testing vs Automated Testing

### Manual Testing Workflow

To test a function manually:

1. Launch the application in the browser.
2. Possibly log in.
3. Navigate to the page where the function is used.
4. Fill a form and submit it.
5. Observe the output on screen.
6. Repeat all steps for every different input you want to test.

This approach:

* Is slow and repetitive.
* Takes several minutes per test.
* Becomes impossible to scale as your application grows.
* Must be repeated for dozens or hundreds of functions.

### Automated Testing Workflow

With automated testing:

* You directly call the function in code.
* You pass various inputs programmatically.
* You verify (assert) the returned outputs.
* You can run all tests automatically whenever:

  * You change your code.
  * You commit to source control.
  * You deploy your application.

This approach:

* Tests all execution paths in less than a second.
* Supports hundreds or thousands of tests.
* Takes only a few seconds to run the entire test suite.

---

## 4. Why Automated Testing Matters

Automated testing:

* Saves enormous time.
* Improves reliability.
* Ensures you do not break existing features when adding new ones.

Further benefits will be discussed in the next lecture.

---

*** 2- Benefits of Automated Testing ***
---

# Benefits of Automated Testing

## Lecture Notes

### 1. Why Write Code to Test Code?

A common question from developers is:
**Why write code to test our code when we can just run the application and check the result manually?**

In the previous lecture, we saw that automated tests save time and let you test frequently.
But there are deeper and more important benefits.

---

## 2. Catching Bugs Before Deployment

The most significant benefit of automated testing is the ability to detect bugs **before** deploying the application.

This leads to:

* Fewer production issues
* More confidence when releasing features
* Less stress and fewer emergency fixes after deployment

Many developers have experienced situations where:

* They deploy the app thinking everything works
* Later receive a call saying a major feature is broken
* Return to the office expecting a quick fix
* End up staying late into the night

Automated tests do not eliminate all bugs, but they **significantly reduce** the number of issues that reach production.

---

## 3. Confidence When Refactoring

Refactoring is the process of improving code structure **without** changing its behavior.

Examples:

* Extracting part of a method into a separate private method
* Renaming a method
* Reorganizing logic to improve readability and maintainability

Without automated tests:

* Every refactor requires manual testing
* Manual testing is slow, repetitive, and error-prone
* As the application grows, developers may forget parts of the system affected by the change

With automated tests:

* You can refactor freely
* You run the test suite to ensure you did not break existing functionality
* You maintain cleaner and higher-quality code with confidence

---

## 4. Better Code Quality

Writing tests forces you to:

* Think about how each method behaves
* Consider different inputs and boundary conditions
* Handle edge cases
* Design cleaner, more modular functions

This leads to better overall code quality.

---

## 5. What Comes Next

In the next lecture, the focus will shift to the **different types of automated tests**.

---

*** 3- Types of Tests ***
# Types of Automated Tests

## Lecture Notes

In automated testing, there are three main categories of tests:

1. Unit tests
2. Integration tests
3. End-to-end (E2E) tests

---

## 1. Unit Tests

### Definition

A unit test verifies a small unit of the application **without** its external dependencies.

**External dependencies** include:

* Files
* Databases
* Message queues
* Web services
* External APIs

The absence of these dependencies is the defining characteristic of a true unit test.

### Characteristics

* Fast to write
* Extremely fast to run
* Can run hundreds or thousands within seconds
* Verify that individual building blocks behave correctly

### Limitation

Because unit tests do not involve real external systems, they provide limited confidence about the overall reliability of the application.

---

## 2. Integration Tests

### Definition

An integration test verifies how a class or component works **with its external dependencies**.

This means the test uses real systems such as:

* Actual databases
* File systems
* Concrete services

### Characteristics

* Slower than unit tests
* Provide higher confidence in system reliability
* Test the real integration between code and dependencies

### Misconception: Integrating Classes vs True Integration

Many people define integration testing as testing two or more classes together.
However:

* If none of the tested classes relies on an external resource, the test is still a **unit test**.
* Testing multiple classes together without external dependencies leads to fragile tests tightly coupled to implementation details.
* These tests break easily during refactoring and waste development time.

This flawed definition is one of the main reasons developers struggle with unit testing.

### Correct Definition Recap

* **Unit test:** Tests a class or group of classes without external dependencies.
* **Integration test:** Tests a class or group of classes with external dependencies.

---

## 3. End-to-End (E2E) Tests

### Definition

End-to-end tests verify the entire application flow through the **user interface**, simulating real user interactions.

Tools designed for these tests include:

* Selenium (a popular option)

These tools:

* Record user interactions
* Replay them
* Confirm that the application behaves correctly from the user’s perspective

### Strength

* Provide the highest level of confidence in the system
* Test the application exactly as the user experiences it

### Major Drawbacks

1. **Very slow**

   * They require launching the full application
   * Often involve logging in, navigating, submitting forms, and checking results

2. **Very brittle**

   * Small UI changes can break tests
   * Frequent maintenance required
   * Not ideal for covering large test suites

---

## Summary

* **Unit tests**: Fast, cheap, isolated, no external dependencies
* **Integration tests**: Slower, involve real external systems, higher confidence
* **End-to-end tests**: Highest confidence, but slow and fragile

---

*** 4- Test Pyramid ***
# The Test Pyramid and What Tests You Should Write

## Lecture Notes

---

## 1. Types of Tests You Should Write

You have learned about three types of automated tests:

* Unit tests
* Integration tests
* End-to-end tests

In real applications, you should write **all three**.
The question is how many of each, and for which scenarios.
This is where the **test pyramid** comes in.

---

## 2. The Test Pyramid

The test pyramid is a guideline that recommends the following structure:

### Base: Unit Tests

* The largest portion of your tests
* Fast, cheap, and easy to write
* Provide quick feedback
* Ideal for testing logic, conditions, loops, and pure functions
* Should cover most edge cases
* Although they do not give high confidence in the full system, they are the foundation of your testing strategy

### Middle: Integration Tests

* A smaller portion than unit tests
* Test the interaction between application code and external dependencies
* Provide many of the benefits of end-to-end tests
* Without the complexity and slowness of testing through the UI
* Useful when your application reads from or writes to external systems

### Top: End-to-End Tests

* The smallest portion of your tests
* Used only for the key user flows
* Should test happy paths, not edge cases
* Slow and brittle, so use them sparingly

---

## 3. The Pyramid Is a Guideline, Not a Rule

The exact ratio of unit, integration, and end-to-end tests depends on:

* The nature of your project
* The complexity of your business logic
* The amount of interaction with external systems

Examples:

* Applications with complex logic should rely heavily on unit tests
* Applications focused mostly on reading and writing data may require more integration tests

---

## 4. Summary of Recommendations

The test pyramid suggests three main practices:

### 1. Favor Unit Tests

* Fast, cheap, precise
* Provide rapid feedback
* Easy to maintain

### 2. Use Integration Tests to Fill Gaps

* Verify interactions with external systems
* Cover areas unit tests cannot reach

### 3. Use End-to-End Tests Sparingly

* Only for major user flows
* Avoid covering edge cases with E2E tests due to slowness and fragility

---

## Final Note

The ideal balance between test types varies by project and team.
Use your judgment to decide which parts of the application should be covered by which kind of test.

---


*** 5- Tooling ***
---

# Test Frameworks

## Lecture Notes

---

## 1. Why We Need a Test Framework

To write automated tests, we need a **test framework**.
A test framework provides two essential components:

### 1.1 Utility Functions

* A library of functions that help us define and structure tests
* Used to write expectations, assertions, and test suites

### 1.2 Test Runner

* A command-line program that finds and executes tests
* Provides a report showing how many tests passed or failed

---

## 2. Popular Test Frameworks

There are several well-known frameworks in the JavaScript ecosystem.

### 2.1 Jasmine

* One of the earliest and most popular testing frameworks
* Includes everything needed for writing tests
* Does not require external plugins

### 2.2 Mocha

* The most popular testing library on npm
* Lightweight and flexible
* By design, lacks certain built-in features found in other frameworks
* Commonly used with external plugins such as:

  * Chai (assertions)
  * Sinon (spies, stubs, mocks)
* Requires checking multiple documentation sources
* Compatibility issues can occur because plugins evolve independently

### 2.3 Jest

* Created by Facebook
* Widely used for testing React applications
* Essentially a wrapper around Jasmine
* Supports all Jasmine utility functions
* Includes additional features such as built-in code coverage
* Provides a complete solution without relying on external libraries

---

## 3. Preferred Framework

The recommended choice in this course is **Jest**, because:

* It includes everything needed out of the box
* No additional libraries or plugins required
* Provides consistent documentation and simpler setup

However:

* You are free to use any framework you like
* Tools and frameworks change over time
* The key goal is to learn the **fundamentals** of writing high-quality unit tests, which apply regardless of the framework

---

## 4. What Comes Next

In the next lecture, you will:

* Install Jest
* Write your first unit test

---

*** 6- Writing Your First Unit Test ***
---

# Setting Up Jest and Writing the First Test

## Lecture Notes

---

## 1. Downloading the Starter Project

* Begin by downloading the project attached to the lecture.
* This project will be used throughout the entire testing section.

---

## 2. Installing Jest

Jest is installed differently from regular Node packages.

### Installation Command

-------------------code----------------------
npm install jest --save-dev
-------------------code----------------------

### Reason

* Jest is a **development dependency**, not a production dependency.
* It should not be included in the production bundle when deploying the application.

### Version

* The version used in the lecture is `22.2.2`.

### Where It Appears

In `package.json`, Jest will appear under `devDependencies`.

---

## 3. Configuring the Test Script

In the `package.json` file, Node projects include a `scripts` section, which defines shortcut commands.

### Default Test Script

The default value usually looks like this:

-------------------code----------------------
"test": "echo \"Error: no test specified\" && exit 1"
-------------------code----------------------

* Running `npm test` will simply print this message and exit.

### Modifying the Test Script

Change the `test` script to:

-------------------code----------------------
"test": "jest"
-------------------code----------------------

This points the `npm test` command to Jest’s command-line interface.

---

## 4. Running the Test Script

After modifying the test script:

### First Run

-------------------code----------------------
npm test
-------------------code----------------------

Jest reports:

-------------------code----------------------
No tests found
-------------------code----------------------

This means Jest is working and is now searching for test files.

---

## 5. Jest Test File Naming Convention

Jest searches for files matching the following patterns:

* `*.test.js`
* `*.spec.js`

These files are automatically recognized as test files.

---

## 6. Creating the First Test

### Folder Structure

Create a folder named `tests` to organize test files.

### Target Module

You will be writing tests for `lib.js`, which exports multiple functions.

### Creating the Test File

Create:

-------------------code----------------------
tests/lib.test.js
-------------------code----------------------

### Writing a Basic Test

Inside the file:

-------------------code----------------------
test('our first test', () => {
});
-------------------code----------------------

* `test` is a Jest-provided function.
* The first argument is the test name (what appears in the console).
* The second argument is a function containing the test logic.

At this point, the test can remain empty.

---

## 7. Running the Test Again

Run:

-------------------code----------------------
npm test
-------------------code----------------------

### Output

* Jest shows a green “pass” label.
* The test name appears with a green check mark.
* Execution time is displayed.
* A summary of passed or failed tests appears at the bottom.

---

## 8. Making a Test Fail

To see how Jest reports an error, modify the test:

-------------------code----------------------
test('our first test', () => {
  throw new Error('Something failed');
});
-------------------code----------------------

Run `npm test` again.

### Output

* A red “fail” label appears.
* Jest displays which test failed.
* It shows the exact line number where the failure occurred.

This demonstrates how Jest reports both passing and failing tests.


Note: we add  jest.config.js to ignore another files
-------------------code----------------------
module.exports = {
  testPathIgnorePatterns: [
    "/node_modules/",
    "/12- Unit Testing/",
    "/12- Unit Testing .*/",
  ],
};
-------------------code----------------------

---


*** 7- Testing Numbers ***
---

# Unit Testing the `absolute` Function

## Lecture Notes

### 1. Overview

We are writing unit tests for the `absolute` function.
The behavior of the function is as follows:

* If the input number is positive → return the same number.
* If the input number is negative → return its positive equivalent.
* If the input is zero → return zero.

The goal is to write tests that cover all execution paths.

---

## 2. Determining Number of Test Cases

A general guideline:
**Number of unit tests ≥ Number of execution paths**

Execution paths in this function:

1. Input is positive
2. Input is negative
3. Input is zero

So we need at least three tests.

---

## 3. Writing Tests in `lib.test.js`

### 3.1 Importing the Module

-------------------code----------------------
const lib = require('../lib');
-------------------code----------------------

### 3.2 First Test Case

**Description:** Should return a positive number if input is positive.

Use simple, non-magic numbers such as `1` instead of arbitrary values like `857`.

-------------------code----------------------
test('absolute - should return a positive number if input is positive', () => {
    const result = lib.absolute(1);
    expect(result).toBe(1);
});
-------------------code----------------------

Run the test:

-------------------code----------------------
npm test
-------------------code----------------------

The test passes.

---

## 4. Jest Matcher Functions

Jest provides various matchers used with `expect()`.
Examples include:

* `toBe`
* `toEqual`
* `toBeNull`
* `toBeUndefined`
* `toBeTruthy`
* `toBeFalsy`
* `toBeGreaterThan`
* `toBeLessThan`
* `toBeCloseTo` (important for floating point numbers)

Floating point values should not use `toBe` or `toEqual` due to precision issues.

---

## 5. Completing All Test Cases

### 5.1 Test for Negative Input

-------------------code----------------------
test('absolute - should return a positive number if input is negative', () => {
    const result = lib.absolute(-1);
    expect(result).toBe(1);
});
-------------------code----------------------

### 5.2 Test for Zero Input

-------------------code----------------------
test('absolute - should return 0 if input is 0', () => {
    const result = lib.absolute(0);
    expect(result).toBe(0);
});
-------------------code----------------------

Run the test suite again:

-------------------code----------------------
npm test
-------------------code----------------------

All three tests should pass.

---

## 6. Demonstrating a Failing Test

If we intentionally change the expected value in the zero-input test:

-------------------code----------------------
expect(result).toBe(1);
-------------------code----------------------

Then run the test suite:

-------------------code----------------------
npm test
-------------------code----------------------

Jest output will show:

* Expected: 1
* Received: 0

Use these messages to identify whether the error is in the test or the production code.

---

## 7. Summary

* The `absolute` function has three execution paths.
* We wrote three unit tests to cover each path.
* Jest matchers help verify correct behavior.
* Jest error outputs are essential for debugging failing tests.

The next lecture covers grouping tests.

---


*** 8- Grouping Tests ***
---

# Grouping Unit Tests with `describe`

## 1. Importance of Clean and Maintainable Tests

As the number of tests increases, organizing them becomes essential.
Tests should be treated as first-class citizens in your codebase, meaning they are as important as production code.

Poorly structured tests become difficult to maintain and understand. In many cases, poorly written tests can be worse than having no tests at all.

---

## 2. Using `describe` to Group Related Tests

Jest (and Jasmine) provide a `describe` function that allows grouping related tests.
Since all current tests are for the `absolute` function, they should be grouped under a single `describe` block.

### Example Structure

-------------------code----------------------
describe('absolute', () => {
    // tests go here
});
-------------------code----------------------

Inside this block you place all tests related to the `absolute` function.

---

## 3. Cleaning Test Names

After moving tests inside the `describe` block, you no longer need to repeat the function name in each test title.

Before grouping:

* absolute should return a positive number if input is positive
* absolute should return a positive number if input is negative

After grouping:

* should return a positive number if input is positive
* should return a positive number if input is negative

This makes the test suite read more naturally.

---

## 4. Using `it` Instead of `test`

Jest provides both `test` and `it`.
Using `it` often makes tests read like plain English when combined with a `describe` block.

Example:

-------------------code----------------------
describe('absolute', () => {
    it('should return a positive number if input is positive', () => { ... });
    it('should return a positive number if input is negative', () => { ... });
});
-------------------code----------------------

This results in a clear and expressive test suite.

---

## 5. Final Reading Flow

When properly grouped, the test file reads naturally:

* describing absolute
* it should return a positive number if input is positive
* it should return a positive number if input is negative
* it should return zero if input is zero

This structure makes tests easier to follow, maintain, and extend.

---

*** 9- Refactoring with Confidence ***
# Refactoring with Confidence Using Unit Tests

## 1. Purpose of Refactoring

Refactoring means improving or restructuring code **without changing its external behavior**.
Unit tests give us confidence during refactoring because they verify that the function still behaves correctly after changes.

---

## 2. Why Tests Make Refactoring Safe

If all execution paths in a function are covered by tests, you can safely modify the internal implementation.
After making changes, you simply run the tests.
If they pass, you can be confident your refactor did not break anything.

Without tests, refactoring is risky.
You would need to run the entire application, navigate to the feature, and manually verify behavior.

---

## 3. Simplifying the Implementation

Given the `absolute` function, all execution paths were already tested.
This allows rewriting the function internally.

### Example Refactor

* Change the first line to return the number directly if it is greater than or equal to zero.
* Remove the last return statement because it is no longer needed.
* For negative values, convert them to positive.

After simplifying, you run:

-------------------code----------------------
npm test
-------------------code----------------------

If tests fail, you check whether the problem is in the tests or in the code.

In this case, the failure came from an intentional bug in a test.
Fixing the test and running again resulted in all tests passing.

---

## 4. Running Tests After Each Change

After correcting the test, running `npm test` again showed three passing tests.
The grouped structure using `describe` also helped produce a clear hierarchical output, displaying:

* absolute

  * should return a positive number if input is positive
  * should return a positive number if input is negative
  * should return zero if input is zero

---

## 5. Refactoring Again Using a Ternary Operator

The implementation was further simplified using a single-line ternary expression:

-------------------code----------------------
return number >= 0 ? number : -number
-------------------code----------------------

After removing unnecessary code and running tests again:

-------------------code----------------------
npm test
-------------------code----------------------

All tests passed successfully.

---

## 6. Key Takeaway

Unit tests enable safe refactoring.
You can freely change the internal implementation of a function, run the tests, and if everything passes, you know the behavior remains correct. This is one of the greatest advantages of having a strong test suite.

*** 10- Testing Strings ***
---

# Testing the `greet` Function

## 1. Purpose of the `greet` Function

The `greet` function takes a name and returns a greeting message.
In real applications, similar functions generate email subjects, email bodies, notification content, and so on.
This example is a simplified version of such functionality.

---

# 2. Writing the First Test

### Create a New `describe` Block

Group all tests related to the `greet` function:

-------------------code----------------------
describe('greet', () => {
    it('should return the greeting message', () => {
        const result = lib.greet('Mosh');
        expect(result).toBe('Welcome Mosh');
    });
});
-------------------code----------------------

Run the test:

-------------------code----------------------
npm test
-------------------code----------------------

All tests pass.
The test hierarchy now shows:

* absolute
* greet

---

# 3. The Problem: Test Too Specific

The initial test checks for **exact equality**:

-------------------code----------------------
expect(result).toBe('Welcome Mosh')
-------------------code----------------------

This is fragile.
If the implementation changes even slightly—for example, adding an exclamation mark:

-------------------code----------------------
return 'Welcome ' + name + '!';
-------------------code----------------------

The test will fail.
Running the tests again shows:

Expected: `Welcome Mosh`
Received: `Welcome Mosh!`

This demonstrates a key principle:

**Tests should not be too specific or too general. They must strike a balanced level of precision.**

---

# 4. Making the Test More General

### Option 1: Use Regular Expressions

Instead of checking the entire string, ensure that the returned message contains the expected name:

-------------------code----------------------
expect(result).toMatch(/Mosh/);
-------------------code----------------------

Run again:

-------------------code----------------------
npm test
-------------------code----------------------

The test passes whether or not the implementation includes additional characters like punctuation.

### Option 2: Use `toContain`

If regular expressions are unnecessary, use a simpler matcher:

-------------------code----------------------
expect(result).toContain('Mosh');
-------------------code----------------------

Run:

-------------------code----------------------
npm test
-------------------code----------------------

All tests pass.

---

# 5. Key Takeaway

When testing strings:

* Avoid overly specific equality tests unless the exact string format is critical.
* Favor matchers like `toMatch` or `toContain` to ensure tests remain stable but still meaningful.

Balanced test precision prevents false failures while still verifying correct behavior.

*** 11- Testing Arrays ***

# Testing Arrays in Unit Tests

## 1. Overview

Some functions return arrays, and in this lecture the focus is on how to properly test such functions.
The example function is `getCurrencies`, which returns an array of three currency strings.

---

# 2. Setting Up the Test

In the test file:

* Add a new `describe` block for `getCurrencies`.
* Only one test is needed because there is a single execution path.
* The test description: **"should return supported currencies"**.
* Inside the test:

  * Call `lib.getCurrencies()`
  * Store the result
  * Write assertions

---

# 3. Principles: Not Too General, Not Too Specific

## A. Tests That Are Too General (Bad Practice)

1. **Expecting result to be defined**

   * Example: `expect(result).toBeDefined()`
   * Problem: If the function returns a number instead of an array due to a bug, this test still passes.

2. **Expecting result not to be null**

   * Example: `expect(result).not.toBeNull()`
   * Problem: This does not ensure the presence of specific currencies.

General tests do not validate output correctness.

---

## B. Tests That Are Too Specific (Bad Practice)

### 1. Checking Exact Element Order

Example:

* `expect(result[0]).toBe('USD')`
* `expect(result[1]).toBe('AUD')`
* `expect(result[2]).toBe('EUR')`

Problem:

* This tightly couples the test to the array order.
* If the sorting changes, tests break unnecessarily.

### 2. Checking Exact Length

Example:

* `expect(result.length).toBe(3)`

Problem:

* If a new currency is added in the future, the test breaks even though the function still behaves correctly.

---

# 4. Proper Way To Test Arrays

## A. Correct (But Not Ideal) Approach

Check for existence of elements regardless of order:

* `expect(result).toContain('USD')`
* `expect(result).toContain('AUD')`
* `expect(result).toContain('EUR')`

This avoids relying on array position.

---

## B. Ideal Approach (Cleaner and Recommended)

Use `expect.arrayContaining()`:

-------------------code----------------------
expect(result).toEqual(expect.arrayContaining([
  'EUR',
  'USD',
  'AUD'
]));
-------------------code----------------------

Notes:

* Order does not matter.
* You can specify only the elements you care about.
* The result may contain more items and the test still passes.

---

# 5. Running the Test

* Restore the original array in `lib.js`
* Run tests: `npm test`
* All tests should pass

---

# 6. Documentation Reference

For matchers like `arrayContaining`, refer to Jest API documentation under `expect`.

---

# Next Topic

The next lecture will cover how to test objects.

---

*** 12- Testing Objects ***

# Testing Objects in Unit Tests

## 1. The Function Being Tested

We are testing a function named `getProduct`:

-------------------code----------------------
// lib.js
module.exports.getProduct = function(id) {
  return { id: id, price: 10 };
};
-------------------code----------------------

This function takes a product ID and returns an object containing two properties:

* `id`
* `price`

---

# 2. Setting Up the Test

Create a new `describe` block in the test file:

-------------------code----------------------
// lib.test.js
const lib = require('../lib');

describe('getProduct', () => {
  it('should return the product with the given id', () => {
    const result = lib.getProduct(1);

    expect(result).toBe({ id: 1, price: 10 }); // incorrect approach
  });
});
-------------------code----------------------

Running this test using `npm test` will cause it to fail.

-------------------code----------------------
 Expected value to be:
      {"id": 1, "price": 10}
    Received:
      {"id": 1, "price": 10}

    Difference:

    Compared values have no visual difference. Looks like you wanted to test for 
    object/array equality with strict `toBe` matcher. You probably need to use `toEqual` instead.
-------------------code----------------------
---

# 3. Why the Test Fails with `toBe`

Even though the expected and received objects look identical, the test fails because:

* `toBe` checks whether both objects reference the **same memory location**.
* The object returned from the function is a different object in memory than the literal object in the test.
* Therefore, `toBe` reports a mismatch.

---

# 4. Correcting the Test Using `toEqual`

Since we care about object **structure and values**, not memory reference, replace `toBe` with `toEqual`:

-------------------code----------------------
expect(result).toEqual({ id: 1, price: 10 });
-------------------code----------------------

Running `npm test` again will now make the test pass.

---

# 5. Alternative Matcher: `toMatchObject`

Sometimes, the returned object may contain more properties than you care about. For example, if the function later returns:

-------------------code----------------------
return { id: id, price: 10, category: 'a' };
-------------------code----------------------

The `toEqual` matcher will fail because the extra property is not included in the test.

Use `toMatchObject` instead:

-------------------code----------------------
expect(result).toMatchObject({ id: 1, price: 10 });
-------------------code----------------------

Characteristics of `toMatchObject`:

* Only requires that the specified properties exist.
* Ignores additional properties.
* Useful when the source object contains many properties.

If you run the test after adding new properties, `toMatchObject` will still pass.

---

# 6. Checking Single Properties: `toHaveProperty`

Another approach is verifying specific properties individually:

-------------------code----------------------
expect(result).toHaveProperty('id', 1);
-------------------code----------------------

Notes:

* The type must match exactly.
* If you change the value to a string, for example:

-------------------code----------------------
expect(result).toHaveProperty('id', "1");
-------------------code----------------------

The test will fail because the function returns `id` as a number.

---

# 7. Summary of Matchers

### Too Specific (avoid)

* `toBe`
* `toEqual` (only when strict full-object match is required)

### Preferred for Flexible Object Testing

* `toMatchObject`
* `toHaveProperty`

These allow your tests to avoid unnecessary breakage while still validating correctness.

---

# 8. Next Topic

The next lecture will explain how to test exceptions.

---

*** 13- Testing Exceptions ***
---

# Testing Exceptions in Unit Tests

## 1. The Function Under Test

We are testing the `registerUser` function, which behaves as follows:

* It takes a `username`.
* If `username` is **falsy**, it **throws an exception**.
* Otherwise, it returns an object:

-------------------code----------------------
{ id: new Date().getTime(), username: username }
-------------------code----------------------

This means the function has **two execution paths**, so we need **at least two tests**.

---

# 2. Setting Up the Test Suite

Add a new `describe` block for `registerUser`:

-------------------code----------------------
describe('registerUser', () => {
});
-------------------code----------------------

---

# 3. Test Case 1: Should Throw If Username Is Falsy

### Falsy values in JavaScript include:

* `null`
* `undefined`
* `NaN`
* `''` (empty string)
* `0`
* `false`

All of these must cause the function to throw an exception.

### Incorrect approach (explained)

Using something like:

-------------------code----------------------
const result = lib.registerUser(null);
expect(result).toThrow();
-------------------code----------------------

does not work because:

* We never get a `result` (the function throws before returning anything).
* The `toThrow` matcher must be given a callback function, not a returned value.

### Correct approach

Wrap the function call inside an arrow function:

-------------------code----------------------
expect(() => { lib.registerUser(null); }).toThrow();
-------------------code----------------------

This allows Jest to check whether an exception is thrown.

---

## 3.1 Parameterized Testing (Manual Approach)

Since Jest does not natively support parameterized tests at the time of recording, we manually loop over falsy values.

Define an array of arguments:

-------------------code----------------------
const args = [null, undefined, NaN, '', 0, false];
-------------------code----------------------

Then loop:

-------------------code----------------------
args.forEach(a => {
  expect(() => { lib.registerUser(a); }).toThrow();
});
-------------------code----------------------

This keeps the test clean and avoids duplicating code in multiple `it` blocks.

---

## 3.2 About the Single Assertion Principle

Some developers interpret the principle as allowing only one `expect` call per test.
However, the principle refers to **logical assertions**, not the literal number of expectations.

Here:

* All falsy values represent one logical concept.
* One test covering all falsy values is valid, clean, and avoids duplication.

If someone prefers one `it` block per value, that is acceptable but unnecessary in this case.

---

# 4. Test Case 2: Should Return a Valid User Object (Happy Path)

Test name:

-------------------code----------------------
it('should return a user object if valid username is passed', () => { ... })
-------------------code----------------------

### Steps:

1. Call `registerUser` with a valid username:

   -------------------code----------------------
   const result = lib.registerUser('mosh');
   -------------------code----------------------

2. Use `toMatchObject` to check the `username`:

   -------------------code----------------------
   expect(result).toMatchObject({ username: 'mosh' });
   -------------------code----------------------

3. Assert that `id` is a positive number:

   -------------------code----------------------
   expect(result.id).toBeGreaterThan(0);
   -------------------code----------------------

We cannot test the exact value of `id` because it is based on the current timestamp, which varies between the function call and the assertion.

These two assertions together test a single logical concept:
The returned user object is valid.

---

# 5. Final Result: All Tests Passing

After running:

-------------------code----------------------
npm test
-------------------code----------------------

All tests pass successfully.

---

*** 14- Continuously Running Tests ***

---

# Automatically Rerunning Tests with Jest Watch Mode

## 1. The Problem

Up to this point, every time you made a change to:

* your **test code**, or
* your **production code**

you had to manually return to the terminal and run:

-------------------code----------------------
npm test
-------------------code----------------------

This becomes tedious and inefficient, especially in large applications.

---

# 2. Enabling Watch Mode

Jest provides a feature that automatically reruns your tests whenever files change.

To enable it:

### Step 1: Edit `package.json`

In the `scripts` section, update the `test` command to include the `--watchAll` flag:

-------------------code----------------------
"scripts": {
  "test": "jest --watchAll"
}
-------------------code----------------------

This tells Jest to continuously watch **all** project files for changes.

---

# 3. Running Tests in Watch Mode

Now return to the terminal and run:

-------------------code----------------------
npm test
-------------------code----------------------

Jest will:

1. Run all existing tests once.
2. Enter watch mode and wait for file changes.

---

# 4. Demonstration

### Example:

1. Open the production code file, such as `registerUser`.
2. Make a small change (for example, remove the exclamation mark in the validation logic).
3. Save the file.

As soon as you save:

* Jest detects the file change.
* Jest automatically reruns your tests.
* You immediately see which test fails, without manually running any command.

This shortens feedback loops significantly.

---

# 5. Improving Your Workflow

For optimal productivity during development:

* Keep your editor and terminal visible at the same time.
* On dual-monitor setups, place:

  * the **test console** on one screen, and
  * the **source code** on the other.

This allows you to immediately see test failures as soon as you save your code.

---
