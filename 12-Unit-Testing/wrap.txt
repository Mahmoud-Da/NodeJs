*** 1- What is Automated Testing ***
# Automated Testing

## Lecture Notes

### 1. Common Questions About Automated Testing

Developers often ask:

* What is automated testing?
* Is it a replacement for manual testing?
* Do I really need it?
* How should I do it?
* Should I use test-driven development (TDD) or write application code first?
* What exactly should I test?

These questions form the foundation of this course, and each will be answered step by step.

---

## 2. What Is Automated Testing?

Automated testing is the practice of writing code that tests our application code and running those tests automatically.

In any project, your source code will consist of:

* **Application (production) code**
* **Test code**

---

## 3. Manual Testing vs Automated Testing

### Manual Testing Workflow

To test a function manually:

1. Launch the application in the browser.
2. Possibly log in.
3. Navigate to the page where the function is used.
4. Fill a form and submit it.
5. Observe the output on screen.
6. Repeat all steps for every different input you want to test.

This approach:

* Is slow and repetitive.
* Takes several minutes per test.
* Becomes impossible to scale as your application grows.
* Must be repeated for dozens or hundreds of functions.

### Automated Testing Workflow

With automated testing:

* You directly call the function in code.
* You pass various inputs programmatically.
* You verify (assert) the returned outputs.
* You can run all tests automatically whenever:

  * You change your code.
  * You commit to source control.
  * You deploy your application.

This approach:

* Tests all execution paths in less than a second.
* Supports hundreds or thousands of tests.
* Takes only a few seconds to run the entire test suite.

---

## 4. Why Automated Testing Matters

Automated testing:

* Saves enormous time.
* Improves reliability.
* Ensures you do not break existing features when adding new ones.

Further benefits will be discussed in the next lecture.

---

*** 2- Benefits of Automated Testing ***
---

# Benefits of Automated Testing

## Lecture Notes

### 1. Why Write Code to Test Code?

A common question from developers is:
**Why write code to test our code when we can just run the application and check the result manually?**

In the previous lecture, we saw that automated tests save time and let you test frequently.
But there are deeper and more important benefits.

---

## 2. Catching Bugs Before Deployment

The most significant benefit of automated testing is the ability to detect bugs **before** deploying the application.

This leads to:

* Fewer production issues
* More confidence when releasing features
* Less stress and fewer emergency fixes after deployment

Many developers have experienced situations where:

* They deploy the app thinking everything works
* Later receive a call saying a major feature is broken
* Return to the office expecting a quick fix
* End up staying late into the night

Automated tests do not eliminate all bugs, but they **significantly reduce** the number of issues that reach production.

---

## 3. Confidence When Refactoring

Refactoring is the process of improving code structure **without** changing its behavior.

Examples:

* Extracting part of a method into a separate private method
* Renaming a method
* Reorganizing logic to improve readability and maintainability

Without automated tests:

* Every refactor requires manual testing
* Manual testing is slow, repetitive, and error-prone
* As the application grows, developers may forget parts of the system affected by the change

With automated tests:

* You can refactor freely
* You run the test suite to ensure you did not break existing functionality
* You maintain cleaner and higher-quality code with confidence

---

## 4. Better Code Quality

Writing tests forces you to:

* Think about how each method behaves
* Consider different inputs and boundary conditions
* Handle edge cases
* Design cleaner, more modular functions

This leads to better overall code quality.

---

## 5. What Comes Next

In the next lecture, the focus will shift to the **different types of automated tests**.

---

*** 3- Types of Tests ***
# Types of Automated Tests

## Lecture Notes

In automated testing, there are three main categories of tests:

1. Unit tests
2. Integration tests
3. End-to-end (E2E) tests

---

## 1. Unit Tests

### Definition

A unit test verifies a small unit of the application **without** its external dependencies.

**External dependencies** include:

* Files
* Databases
* Message queues
* Web services
* External APIs

The absence of these dependencies is the defining characteristic of a true unit test.

### Characteristics

* Fast to write
* Extremely fast to run
* Can run hundreds or thousands within seconds
* Verify that individual building blocks behave correctly

### Limitation

Because unit tests do not involve real external systems, they provide limited confidence about the overall reliability of the application.

---

## 2. Integration Tests

### Definition

An integration test verifies how a class or component works **with its external dependencies**.

This means the test uses real systems such as:

* Actual databases
* File systems
* Concrete services

### Characteristics

* Slower than unit tests
* Provide higher confidence in system reliability
* Test the real integration between code and dependencies

### Misconception: Integrating Classes vs True Integration

Many people define integration testing as testing two or more classes together.
However:

* If none of the tested classes relies on an external resource, the test is still a **unit test**.
* Testing multiple classes together without external dependencies leads to fragile tests tightly coupled to implementation details.
* These tests break easily during refactoring and waste development time.

This flawed definition is one of the main reasons developers struggle with unit testing.

### Correct Definition Recap

* **Unit test:** Tests a class or group of classes without external dependencies.
* **Integration test:** Tests a class or group of classes with external dependencies.

---

## 3. End-to-End (E2E) Tests

### Definition

End-to-end tests verify the entire application flow through the **user interface**, simulating real user interactions.

Tools designed for these tests include:

* Selenium (a popular option)

These tools:

* Record user interactions
* Replay them
* Confirm that the application behaves correctly from the user’s perspective

### Strength

* Provide the highest level of confidence in the system
* Test the application exactly as the user experiences it

### Major Drawbacks

1. **Very slow**

   * They require launching the full application
   * Often involve logging in, navigating, submitting forms, and checking results

2. **Very brittle**

   * Small UI changes can break tests
   * Frequent maintenance required
   * Not ideal for covering large test suites

---

## Summary

* **Unit tests**: Fast, cheap, isolated, no external dependencies
* **Integration tests**: Slower, involve real external systems, higher confidence
* **End-to-end tests**: Highest confidence, but slow and fragile

---

*** 4- Test Pyramid ***
# The Test Pyramid and What Tests You Should Write

## Lecture Notes

---

## 1. Types of Tests You Should Write

You have learned about three types of automated tests:

* Unit tests
* Integration tests
* End-to-end tests

In real applications, you should write **all three**.
The question is how many of each, and for which scenarios.
This is where the **test pyramid** comes in.

---

## 2. The Test Pyramid

The test pyramid is a guideline that recommends the following structure:

### Base: Unit Tests

* The largest portion of your tests
* Fast, cheap, and easy to write
* Provide quick feedback
* Ideal for testing logic, conditions, loops, and pure functions
* Should cover most edge cases
* Although they do not give high confidence in the full system, they are the foundation of your testing strategy

### Middle: Integration Tests

* A smaller portion than unit tests
* Test the interaction between application code and external dependencies
* Provide many of the benefits of end-to-end tests
* Without the complexity and slowness of testing through the UI
* Useful when your application reads from or writes to external systems

### Top: End-to-End Tests

* The smallest portion of your tests
* Used only for the key user flows
* Should test happy paths, not edge cases
* Slow and brittle, so use them sparingly

---

## 3. The Pyramid Is a Guideline, Not a Rule

The exact ratio of unit, integration, and end-to-end tests depends on:

* The nature of your project
* The complexity of your business logic
* The amount of interaction with external systems

Examples:

* Applications with complex logic should rely heavily on unit tests
* Applications focused mostly on reading and writing data may require more integration tests

---

## 4. Summary of Recommendations

The test pyramid suggests three main practices:

### 1. Favor Unit Tests

* Fast, cheap, precise
* Provide rapid feedback
* Easy to maintain

### 2. Use Integration Tests to Fill Gaps

* Verify interactions with external systems
* Cover areas unit tests cannot reach

### 3. Use End-to-End Tests Sparingly

* Only for major user flows
* Avoid covering edge cases with E2E tests due to slowness and fragility

---

## Final Note

The ideal balance between test types varies by project and team.
Use your judgment to decide which parts of the application should be covered by which kind of test.

---


*** 5- Tooling ***
---

# Test Frameworks

## Lecture Notes

---

## 1. Why We Need a Test Framework

To write automated tests, we need a **test framework**.
A test framework provides two essential components:

### 1.1 Utility Functions

* A library of functions that help us define and structure tests
* Used to write expectations, assertions, and test suites

### 1.2 Test Runner

* A command-line program that finds and executes tests
* Provides a report showing how many tests passed or failed

---

## 2. Popular Test Frameworks

There are several well-known frameworks in the JavaScript ecosystem.

### 2.1 Jasmine

* One of the earliest and most popular testing frameworks
* Includes everything needed for writing tests
* Does not require external plugins

### 2.2 Mocha

* The most popular testing library on npm
* Lightweight and flexible
* By design, lacks certain built-in features found in other frameworks
* Commonly used with external plugins such as:

  * Chai (assertions)
  * Sinon (spies, stubs, mocks)
* Requires checking multiple documentation sources
* Compatibility issues can occur because plugins evolve independently

### 2.3 Jest

* Created by Facebook
* Widely used for testing React applications
* Essentially a wrapper around Jasmine
* Supports all Jasmine utility functions
* Includes additional features such as built-in code coverage
* Provides a complete solution without relying on external libraries

---

## 3. Preferred Framework

The recommended choice in this course is **Jest**, because:

* It includes everything needed out of the box
* No additional libraries or plugins required
* Provides consistent documentation and simpler setup

However:

* You are free to use any framework you like
* Tools and frameworks change over time
* The key goal is to learn the **fundamentals** of writing high-quality unit tests, which apply regardless of the framework

---

## 4. What Comes Next

In the next lecture, you will:

* Install Jest
* Write your first unit test

---

*** 6- Writing Your First Unit Test ***
---

# Setting Up Jest and Writing the First Test

## Lecture Notes

---

## 1. Downloading the Starter Project

* Begin by downloading the project attached to the lecture.
* This project will be used throughout the entire testing section.

---

## 2. Installing Jest

Jest is installed differently from regular Node packages.

### Installation Command

-------------------code----------------------
npm install jest --save-dev
-------------------code----------------------

### Reason

* Jest is a **development dependency**, not a production dependency.
* It should not be included in the production bundle when deploying the application.

### Version

* The version used in the lecture is `22.2.2`.

### Where It Appears

In `package.json`, Jest will appear under `devDependencies`.

---

## 3. Configuring the Test Script

In the `package.json` file, Node projects include a `scripts` section, which defines shortcut commands.

### Default Test Script

The default value usually looks like this:

-------------------code----------------------
"test": "echo \"Error: no test specified\" && exit 1"
-------------------code----------------------

* Running `npm test` will simply print this message and exit.

### Modifying the Test Script

Change the `test` script to:

-------------------code----------------------
"test": "jest"
-------------------code----------------------

This points the `npm test` command to Jest’s command-line interface.

---

## 4. Running the Test Script

After modifying the test script:

### First Run

-------------------code----------------------
npm test
-------------------code----------------------

Jest reports:

-------------------code----------------------
No tests found
-------------------code----------------------

This means Jest is working and is now searching for test files.

---

## 5. Jest Test File Naming Convention

Jest searches for files matching the following patterns:

* `*.test.js`
* `*.spec.js`

These files are automatically recognized as test files.

---

## 6. Creating the First Test

### Folder Structure

Create a folder named `tests` to organize test files.

### Target Module

You will be writing tests for `lib.js`, which exports multiple functions.

### Creating the Test File

Create:

-------------------code----------------------
tests/lib.test.js
-------------------code----------------------

### Writing a Basic Test

Inside the file:

-------------------code----------------------
test('our first test', () => {
});
-------------------code----------------------

* `test` is a Jest-provided function.
* The first argument is the test name (what appears in the console).
* The second argument is a function containing the test logic.

At this point, the test can remain empty.

---

## 7. Running the Test Again

Run:

-------------------code----------------------
npm test
-------------------code----------------------

### Output

* Jest shows a green “pass” label.
* The test name appears with a green check mark.
* Execution time is displayed.
* A summary of passed or failed tests appears at the bottom.

---

## 8. Making a Test Fail

To see how Jest reports an error, modify the test:

-------------------code----------------------
test('our first test', () => {
  throw new Error('Something failed');
});
-------------------code----------------------

Run `npm test` again.

### Output

* A red “fail” label appears.
* Jest displays which test failed.
* It shows the exact line number where the failure occurred.

This demonstrates how Jest reports both passing and failing tests.


Note: we add  jest.config.js to ignore another files
-------------------code----------------------
module.exports = {
  testPathIgnorePatterns: [
    "/node_modules/",
    "/12- Unit Testing/",
    "/12- Unit Testing .*/",
  ],
};
-------------------code----------------------

---


*** 7- Testing Numbers ***
---

# Unit Testing the `absolute` Function

## Lecture Notes

### 1. Overview

We are writing unit tests for the `absolute` function.
The behavior of the function is as follows:

* If the input number is positive → return the same number.
* If the input number is negative → return its positive equivalent.
* If the input is zero → return zero.

The goal is to write tests that cover all execution paths.

---

## 2. Determining Number of Test Cases

A general guideline:
**Number of unit tests ≥ Number of execution paths**

Execution paths in this function:

1. Input is positive
2. Input is negative
3. Input is zero

So we need at least three tests.

---

## 3. Writing Tests in `lib.test.js`

### 3.1 Importing the Module

-------------------code----------------------
const lib = require('../lib');
-------------------code----------------------

### 3.2 First Test Case

**Description:** Should return a positive number if input is positive.

Use simple, non-magic numbers such as `1` instead of arbitrary values like `857`.

-------------------code----------------------
test('absolute - should return a positive number if input is positive', () => {
    const result = lib.absolute(1);
    expect(result).toBe(1);
});
-------------------code----------------------

Run the test:

-------------------code----------------------
npm test
-------------------code----------------------

The test passes.

---

## 4. Jest Matcher Functions

Jest provides various matchers used with `expect()`.
Examples include:

* `toBe`
* `toEqual`
* `toBeNull`
* `toBeUndefined`
* `toBeTruthy`
* `toBeFalsy`
* `toBeGreaterThan`
* `toBeLessThan`
* `toBeCloseTo` (important for floating point numbers)

Floating point values should not use `toBe` or `toEqual` due to precision issues.

---

## 5. Completing All Test Cases

### 5.1 Test for Negative Input

-------------------code----------------------
test('absolute - should return a positive number if input is negative', () => {
    const result = lib.absolute(-1);
    expect(result).toBe(1);
});
-------------------code----------------------

### 5.2 Test for Zero Input

-------------------code----------------------
test('absolute - should return 0 if input is 0', () => {
    const result = lib.absolute(0);
    expect(result).toBe(0);
});
-------------------code----------------------

Run the test suite again:

-------------------code----------------------
npm test
-------------------code----------------------

All three tests should pass.

---

## 6. Demonstrating a Failing Test

If we intentionally change the expected value in the zero-input test:

-------------------code----------------------
expect(result).toBe(1);
-------------------code----------------------

Then run the test suite:

-------------------code----------------------
npm test
-------------------code----------------------

Jest output will show:

* Expected: 1
* Received: 0

Use these messages to identify whether the error is in the test or the production code.

---

## 7. Summary

* The `absolute` function has three execution paths.
* We wrote three unit tests to cover each path.
* Jest matchers help verify correct behavior.
* Jest error outputs are essential for debugging failing tests.

The next lecture covers grouping tests.

---


*** 8- Grouping Tests ***
---

# Grouping Unit Tests with `describe`

## 1. Importance of Clean and Maintainable Tests

As the number of tests increases, organizing them becomes essential.
Tests should be treated as first-class citizens in your codebase, meaning they are as important as production code.

Poorly structured tests become difficult to maintain and understand. In many cases, poorly written tests can be worse than having no tests at all.

---

## 2. Using `describe` to Group Related Tests

Jest (and Jasmine) provide a `describe` function that allows grouping related tests.
Since all current tests are for the `absolute` function, they should be grouped under a single `describe` block.

### Example Structure

-------------------code----------------------
describe('absolute', () => {
    // tests go here
});
-------------------code----------------------

Inside this block you place all tests related to the `absolute` function.

---

## 3. Cleaning Test Names

After moving tests inside the `describe` block, you no longer need to repeat the function name in each test title.

Before grouping:

* absolute should return a positive number if input is positive
* absolute should return a positive number if input is negative

After grouping:

* should return a positive number if input is positive
* should return a positive number if input is negative

This makes the test suite read more naturally.

---

## 4. Using `it` Instead of `test`

Jest provides both `test` and `it`.
Using `it` often makes tests read like plain English when combined with a `describe` block.

Example:

-------------------code----------------------
describe('absolute', () => {
    it('should return a positive number if input is positive', () => { ... });
    it('should return a positive number if input is negative', () => { ... });
});
-------------------code----------------------

This results in a clear and expressive test suite.

---

## 5. Final Reading Flow

When properly grouped, the test file reads naturally:

* describing absolute
* it should return a positive number if input is positive
* it should return a positive number if input is negative
* it should return zero if input is zero

This structure makes tests easier to follow, maintain, and extend.

---

*** 9- Refactoring with Confidence ***
# Refactoring with Confidence Using Unit Tests

## 1. Purpose of Refactoring

Refactoring means improving or restructuring code **without changing its external behavior**.
Unit tests give us confidence during refactoring because they verify that the function still behaves correctly after changes.

---

## 2. Why Tests Make Refactoring Safe

If all execution paths in a function are covered by tests, you can safely modify the internal implementation.
After making changes, you simply run the tests.
If they pass, you can be confident your refactor did not break anything.

Without tests, refactoring is risky.
You would need to run the entire application, navigate to the feature, and manually verify behavior.

---

## 3. Simplifying the Implementation

Given the `absolute` function, all execution paths were already tested.
This allows rewriting the function internally.

### Example Refactor

* Change the first line to return the number directly if it is greater than or equal to zero.
* Remove the last return statement because it is no longer needed.
* For negative values, convert them to positive.

After simplifying, you run:

-------------------code----------------------
npm test
-------------------code----------------------

If tests fail, you check whether the problem is in the tests or in the code.

In this case, the failure came from an intentional bug in a test.
Fixing the test and running again resulted in all tests passing.

---

## 4. Running Tests After Each Change

After correcting the test, running `npm test` again showed three passing tests.
The grouped structure using `describe` also helped produce a clear hierarchical output, displaying:

* absolute

  * should return a positive number if input is positive
  * should return a positive number if input is negative
  * should return zero if input is zero

---

## 5. Refactoring Again Using a Ternary Operator

The implementation was further simplified using a single-line ternary expression:

-------------------code----------------------
return number >= 0 ? number : -number
-------------------code----------------------

After removing unnecessary code and running tests again:

-------------------code----------------------
npm test
-------------------code----------------------

All tests passed successfully.

---

## 6. Key Takeaway

Unit tests enable safe refactoring.
You can freely change the internal implementation of a function, run the tests, and if everything passes, you know the behavior remains correct. This is one of the greatest advantages of having a strong test suite.

*** 10- Testing Strings ***
---

# Testing the `greet` Function

## 1. Purpose of the `greet` Function

The `greet` function takes a name and returns a greeting message.
In real applications, similar functions generate email subjects, email bodies, notification content, and so on.
This example is a simplified version of such functionality.

---

# 2. Writing the First Test

### Create a New `describe` Block

Group all tests related to the `greet` function:

-------------------code----------------------
describe('greet', () => {
    it('should return the greeting message', () => {
        const result = lib.greet('Mosh');
        expect(result).toBe('Welcome Mosh');
    });
});
-------------------code----------------------

Run the test:

-------------------code----------------------
npm test
-------------------code----------------------

All tests pass.
The test hierarchy now shows:

* absolute
* greet

---

# 3. The Problem: Test Too Specific

The initial test checks for **exact equality**:

-------------------code----------------------
expect(result).toBe('Welcome Mosh')
-------------------code----------------------

This is fragile.
If the implementation changes even slightly—for example, adding an exclamation mark:

-------------------code----------------------
return 'Welcome ' + name + '!';
-------------------code----------------------

The test will fail.
Running the tests again shows:

Expected: `Welcome Mosh`
Received: `Welcome Mosh!`

This demonstrates a key principle:

**Tests should not be too specific or too general. They must strike a balanced level of precision.**

---

# 4. Making the Test More General

### Option 1: Use Regular Expressions

Instead of checking the entire string, ensure that the returned message contains the expected name:

-------------------code----------------------
expect(result).toMatch(/Mosh/);
-------------------code----------------------

Run again:

-------------------code----------------------
npm test
-------------------code----------------------

The test passes whether or not the implementation includes additional characters like punctuation.

### Option 2: Use `toContain`

If regular expressions are unnecessary, use a simpler matcher:

-------------------code----------------------
expect(result).toContain('Mosh');
-------------------code----------------------

Run:

-------------------code----------------------
npm test
-------------------code----------------------

All tests pass.

---

# 5. Key Takeaway

When testing strings:

* Avoid overly specific equality tests unless the exact string format is critical.
* Favor matchers like `toMatch` or `toContain` to ensure tests remain stable but still meaningful.

Balanced test precision prevents false failures while still verifying correct behavior.
