*** 1- What is Automated Testing ***
# Automated Testing

## Lecture Notes

### 1. Common Questions About Automated Testing

Developers often ask:

* What is automated testing?
* Is it a replacement for manual testing?
* Do I really need it?
* How should I do it?
* Should I use test-driven development (TDD) or write application code first?
* What exactly should I test?

These questions form the foundation of this course, and each will be answered step by step.

---

## 2. What Is Automated Testing?

Automated testing is the practice of writing code that tests our application code and running those tests automatically.

In any project, your source code will consist of:

* **Application (production) code**
* **Test code**

---

## 3. Manual Testing vs Automated Testing

### Manual Testing Workflow

To test a function manually:

1. Launch the application in the browser.
2. Possibly log in.
3. Navigate to the page where the function is used.
4. Fill a form and submit it.
5. Observe the output on screen.
6. Repeat all steps for every different input you want to test.

This approach:

* Is slow and repetitive.
* Takes several minutes per test.
* Becomes impossible to scale as your application grows.
* Must be repeated for dozens or hundreds of functions.

### Automated Testing Workflow

With automated testing:

* You directly call the function in code.
* You pass various inputs programmatically.
* You verify (assert) the returned outputs.
* You can run all tests automatically whenever:

  * You change your code.
  * You commit to source control.
  * You deploy your application.

This approach:

* Tests all execution paths in less than a second.
* Supports hundreds or thousands of tests.
* Takes only a few seconds to run the entire test suite.

---

## 4. Why Automated Testing Matters

Automated testing:

* Saves enormous time.
* Improves reliability.
* Ensures you do not break existing features when adding new ones.

Further benefits will be discussed in the next lecture.

---

*** 2- Benefits of Automated Testing ***
---

# Benefits of Automated Testing

## Lecture Notes

### 1. Why Write Code to Test Code?

A common question from developers is:
**Why write code to test our code when we can just run the application and check the result manually?**

In the previous lecture, we saw that automated tests save time and let you test frequently.
But there are deeper and more important benefits.

---

## 2. Catching Bugs Before Deployment

The most significant benefit of automated testing is the ability to detect bugs **before** deploying the application.

This leads to:

* Fewer production issues
* More confidence when releasing features
* Less stress and fewer emergency fixes after deployment

Many developers have experienced situations where:

* They deploy the app thinking everything works
* Later receive a call saying a major feature is broken
* Return to the office expecting a quick fix
* End up staying late into the night

Automated tests do not eliminate all bugs, but they **significantly reduce** the number of issues that reach production.

---

## 3. Confidence When Refactoring

Refactoring is the process of improving code structure **without** changing its behavior.

Examples:

* Extracting part of a method into a separate private method
* Renaming a method
* Reorganizing logic to improve readability and maintainability

Without automated tests:

* Every refactor requires manual testing
* Manual testing is slow, repetitive, and error-prone
* As the application grows, developers may forget parts of the system affected by the change

With automated tests:

* You can refactor freely
* You run the test suite to ensure you did not break existing functionality
* You maintain cleaner and higher-quality code with confidence

---

## 4. Better Code Quality

Writing tests forces you to:

* Think about how each method behaves
* Consider different inputs and boundary conditions
* Handle edge cases
* Design cleaner, more modular functions

This leads to better overall code quality.

---

## 5. What Comes Next

In the next lecture, the focus will shift to the **different types of automated tests**.

---

*** 3- Types of Tests ***
# Types of Automated Tests

## Lecture Notes

In automated testing, there are three main categories of tests:

1. Unit tests
2. Integration tests
3. End-to-end (E2E) tests

---

## 1. Unit Tests

### Definition

A unit test verifies a small unit of the application **without** its external dependencies.

**External dependencies** include:

* Files
* Databases
* Message queues
* Web services
* External APIs

The absence of these dependencies is the defining characteristic of a true unit test.

### Characteristics

* Fast to write
* Extremely fast to run
* Can run hundreds or thousands within seconds
* Verify that individual building blocks behave correctly

### Limitation

Because unit tests do not involve real external systems, they provide limited confidence about the overall reliability of the application.

---

## 2. Integration Tests

### Definition

An integration test verifies how a class or component works **with its external dependencies**.

This means the test uses real systems such as:

* Actual databases
* File systems
* Concrete services

### Characteristics

* Slower than unit tests
* Provide higher confidence in system reliability
* Test the real integration between code and dependencies

### Misconception: Integrating Classes vs True Integration

Many people define integration testing as testing two or more classes together.
However:

* If none of the tested classes relies on an external resource, the test is still a **unit test**.
* Testing multiple classes together without external dependencies leads to fragile tests tightly coupled to implementation details.
* These tests break easily during refactoring and waste development time.

This flawed definition is one of the main reasons developers struggle with unit testing.

### Correct Definition Recap

* **Unit test:** Tests a class or group of classes without external dependencies.
* **Integration test:** Tests a class or group of classes with external dependencies.

---

## 3. End-to-End (E2E) Tests

### Definition

End-to-end tests verify the entire application flow through the **user interface**, simulating real user interactions.

Tools designed for these tests include:

* Selenium (a popular option)

These tools:

* Record user interactions
* Replay them
* Confirm that the application behaves correctly from the userâ€™s perspective

### Strength

* Provide the highest level of confidence in the system
* Test the application exactly as the user experiences it

### Major Drawbacks

1. **Very slow**

   * They require launching the full application
   * Often involve logging in, navigating, submitting forms, and checking results

2. **Very brittle**

   * Small UI changes can break tests
   * Frequent maintenance required
   * Not ideal for covering large test suites

---

## Summary

* **Unit tests**: Fast, cheap, isolated, no external dependencies
* **Integration tests**: Slower, involve real external systems, higher confidence
* **End-to-end tests**: Highest confidence, but slow and fragile

---

*** 4- Test Pyramid ***
# The Test Pyramid and What Tests You Should Write

## Lecture Notes

---

## 1. Types of Tests You Should Write

You have learned about three types of automated tests:

* Unit tests
* Integration tests
* End-to-end tests

In real applications, you should write **all three**.
The question is how many of each, and for which scenarios.
This is where the **test pyramid** comes in.

---

## 2. The Test Pyramid

The test pyramid is a guideline that recommends the following structure:

### Base: Unit Tests

* The largest portion of your tests
* Fast, cheap, and easy to write
* Provide quick feedback
* Ideal for testing logic, conditions, loops, and pure functions
* Should cover most edge cases
* Although they do not give high confidence in the full system, they are the foundation of your testing strategy

### Middle: Integration Tests

* A smaller portion than unit tests
* Test the interaction between application code and external dependencies
* Provide many of the benefits of end-to-end tests
* Without the complexity and slowness of testing through the UI
* Useful when your application reads from or writes to external systems

### Top: End-to-End Tests

* The smallest portion of your tests
* Used only for the key user flows
* Should test happy paths, not edge cases
* Slow and brittle, so use them sparingly

---

## 3. The Pyramid Is a Guideline, Not a Rule

The exact ratio of unit, integration, and end-to-end tests depends on:

* The nature of your project
* The complexity of your business logic
* The amount of interaction with external systems

Examples:

* Applications with complex logic should rely heavily on unit tests
* Applications focused mostly on reading and writing data may require more integration tests

---

## 4. Summary of Recommendations

The test pyramid suggests three main practices:

### 1. Favor Unit Tests

* Fast, cheap, precise
* Provide rapid feedback
* Easy to maintain

### 2. Use Integration Tests to Fill Gaps

* Verify interactions with external systems
* Cover areas unit tests cannot reach

### 3. Use End-to-End Tests Sparingly

* Only for major user flows
* Avoid covering edge cases with E2E tests due to slowness and fragility

---

## Final Note

The ideal balance between test types varies by project and team.
Use your judgment to decide which parts of the application should be covered by which kind of test.

---


*** 5- Tooling ***
---

# Test Frameworks

## Lecture Notes

---

## 1. Why We Need a Test Framework

To write automated tests, we need a **test framework**.
A test framework provides two essential components:

### 1.1 Utility Functions

* A library of functions that help us define and structure tests
* Used to write expectations, assertions, and test suites

### 1.2 Test Runner

* A command-line program that finds and executes tests
* Provides a report showing how many tests passed or failed

---

## 2. Popular Test Frameworks

There are several well-known frameworks in the JavaScript ecosystem.

### 2.1 Jasmine

* One of the earliest and most popular testing frameworks
* Includes everything needed for writing tests
* Does not require external plugins

### 2.2 Mocha

* The most popular testing library on npm
* Lightweight and flexible
* By design, lacks certain built-in features found in other frameworks
* Commonly used with external plugins such as:

  * Chai (assertions)
  * Sinon (spies, stubs, mocks)
* Requires checking multiple documentation sources
* Compatibility issues can occur because plugins evolve independently

### 2.3 Jest

* Created by Facebook
* Widely used for testing React applications
* Essentially a wrapper around Jasmine
* Supports all Jasmine utility functions
* Includes additional features such as built-in code coverage
* Provides a complete solution without relying on external libraries

---

## 3. Preferred Framework

The recommended choice in this course is **Jest**, because:

* It includes everything needed out of the box
* No additional libraries or plugins required
* Provides consistent documentation and simpler setup

However:

* You are free to use any framework you like
* Tools and frameworks change over time
* The key goal is to learn the **fundamentals** of writing high-quality unit tests, which apply regardless of the framework

---

## 4. What Comes Next

In the next lecture, you will:

* Install Jest
* Write your first unit test

---
