*** 1- Introduction ***
---

# Integration Testing Overview

## 1. Unit Tests Recap

* Unit tests are simple and quick to write.
* They execute very fast.
* Best suited for functions that have zero or minimal dependency on external resources.
* Useful for testing small, isolated pieces of logic.

## 2. The Need for Integration Tests

* Real-world applications often rely on one or more external resources such as databases, file systems, or network services.
* Integration tests validate that the application code works correctly together with these external systems.
* Instead of testing components in isolation, integration tests check them as a whole.

## 3. Working With a Real Database

* Integration tests require a real database instance.
* The database is populated with test data before running tests.
* Tests interact with the application exactly as a real client would.

## 4. How Integration Tests Work

1. Prepare test data in the database.
2. Send an HTTP request to the endpoint being tested.
3. Make assertions based on either:

   * The HTTP response.
   * The changes in the database.

### Example

* Sending an HTTP POST request to create a new genre.
* After the request, the test inspects the database to ensure that the new genre has been created.

## 5. Next Steps

* In the next lecture, you will make a few adjustments to the application code to prepare it for integration testing.

---

*** 2- Preparing the App ***
---

# Preparing the Application for Integration Testing

## 1. Required Adjustments Before Writing Integration Tests

Before starting integration tests for the Vidly application, several updates are needed to ensure the environment works correctly.

---

## 2. Fixing the Index Module

* Open `index.js`.
* A previous refactor introduced an issue: on line 5, the logging module was required but not invoked.
* Ensure that the required logging module is actually called as a function.
* Without calling it, logging will not work properly.

---

## 3. Updating the NPM Test Script

* Open `package.json`.
* Modify the test script to include the `--verbose` flag.
* The verbose flag causes Jest to print additional diagnostic information in the console.
* This extra output is useful for troubleshooting when tests fail or behave unexpectedly.

---

## 4. Adjusting the Logging Module

* Open the logging module used for Winston integrations.

* Previously, MongoDB was configured as a transport for Winston, using `winston-mongodb`.

* This module currently causes the test runner to freeze when running integration tests in the terminal.

* The issue may depend on the specific version or environment and may not occur on all machines.

* To avoid blocking integration tests:

  1. Temporarily comment out the MongoDB logging configuration.
  2. Comment out the lines that add MongoDB as a Winston transport (around line 14 in the logging module).

* This allows focus on integration tests without interference from the Winston MongoDB plugin.

* The configuration can be restored later once the issue is resolved.

---

## 5. Summary of Required Changes

1. **index.js**:

   * Add parentheses to invoke the logging module function on line 5.

2. **package.json**:

   * Add the `--verbose` flag to the test command.

3. **logging module**:

   * Temporarily disable the Winston MongoDB plugin by commenting out its configuration and transport setup.

---

*** 3- Setting Up the Test Db ***
---

# Setting Up a Test Database for Integration Testing

## 1. Why We Need a Separate Test Database

* Integration tests use a real database.
* These tests add and remove documents from the database.
* Because of this behavior, the test database must be **separate** from both development and production databases.
* This prevents accidental modification or corruption of real data.

---

## 2. Adding a Database Key to Configuration

### Step 1: Modify `default.json`

* Go to the `config` folder and open `default.json`.
* Add a new key named `db`.
* Set `db` to your default MongoDB connection string.
* Ensure that no single quotes are used.

**Example structure:**

-------------------code----------------------
{
  "db": "mongodb://localhost/vidly"
}
-------------------code----------------------

---

## 3. Move the Connection String to Configuration

* Open `db.js`.
* Cut the MongoDB connection string from the file.
* Paste it into `default.json` under the new `db` key.
* This centralizes configuration and keeps environment settings clean.

---

## 4. Create a Test-Specific Configuration

### Step 1: Modify `test.json`

* Open `test.json` in the same configuration folder.
* Copy the new `db` key from `default.json`.
* Change the database name to something like `vidly_test`.

**Example:**

-------------------code----------------------
"db": "mongodb://localhost/vidly_test"
-------------------code----------------------

This ensures tests run against a separate database.

---

## 5. Updating `db.js` to Use Environment-Based Configuration

### Step 1: Load the Configuration Module

* In `db.js`, add:

  -------------------code----------------------
  const config = require('config');
  -------------------code----------------------
* Replace hardcoded connection strings with:

  -------------------code----------------------
  config.get('db')
  -------------------code----------------------

### Step 2: Improve Code Clarity

* Create a constant for the database connection:

  -------------------code----------------------
  const db = config.get('db');
  -------------------code----------------------
* Use this constant both when connecting and when logging the active database.

---

## 6. Verifying Environment-Based Database Selection

* When running the application normally, it connects to the development database.
* When running tests, it should connect to the test database.

### Manual simulation:

1. Set the environment variable:

   -------------------code----------------------
   NODE_ENV=test
   -------------------code----------------------
2. Run the app:

   -------------------code----------------------
   node index.js
   -------------------code----------------------
3. The console should show a connection to the test database.

---

## 7. Next Step

* With the test database configured, the next lecture will focus on writing the first integration test.

---


*** 4- Your First Integration Test ***

# Writing Integration Tests with Supertest

## 1. Installing Supertest

* Integration tests for Express applications require a library called **supertest**.
* Supertest allows sending HTTP requests to your endpoints programmatically, similar to Postman.
* Install it as a development dependency:
  `npm install supertest --save-dev`
* The version used in the lecture is 3.0.0.

---

## 2. Exporting the Server from index.js

* Open `index.js`.
* The `app.listen()` call returns a server object.
* Store the returned object in a variable, for example:

  -------------------code----------------------
  const server = app.listen(...)
  -------------------code----------------------
* Export the server:

  -------------------code----------------------
  module.exports = server;
  -------------------code----------------------
* This allows test files to load and control the server instance.

---

## 3. Creating the Integration Test Structure

### Step 1: Create a Test Directory

* Inside the `tests` folder, create a new folder named `integration`.
* Inside that folder, create a test file:

  -------------------code----------------------
  genres.test.js
  -------------------code----------------------

### Step 2: Create the Test Suite Structure

* Start with a top-level describe block:

  -------------------code----------------------
  describe('/api/genres', () => { ... });
  -------------------code----------------------

* Inside it, add another describe block for GET requests:

  -------------------code----------------------
  describe('GET /', () => { ... });
  -------------------code----------------------

* Inside this block, write your test:

  -------------------code----------------------
  it('should return all genres', () => { ... });
  -------------------code----------------------

---

## 4. Loading and Managing the Server in Tests

### Problem

* If the server is loaded globally, Jest will restart tests after code changes.
* This causes an error because the server is already listening on port 3000.

### Solution

* Load the server inside a `beforeEach` block.
* Close the server in an `afterEach` block.

### Example:

-------------------code----------------------
let server;

beforeEach(() => {
  server = require('../../../index');
});

afterEach(() => {
  server.close();
});
-------------------code----------------------

This ensures:

* A fresh server instance is used for each test.
* No port conflicts occur.

---

## 5. Using Supertest

### Step 1: Import Supertest

-------------------code----------------------
const request = require('supertest');
-------------------code----------------------

### Step 2: Sending a Request

* The `request()` function takes the server object.
* You can then chain request methods such as `.get()`, `.post()`, `.put()`, `.delete()`.

### Example GET request:

-------------------code----------------------
const res = await request(server).get('/api/genres');
-------------------code----------------------

* Since `await` is used, the test function must be marked as `async`.

---

## 6. Making Assertions

* A simple initial assertion is to check the response status:

  -------------------code----------------------
  expect(res.status).toBe(200);
  -------------------code----------------------

* Running the test:

  -------------------code----------------------
  npm test
  -------------------code----------------------

* If everything is set up correctly, tests will pass and the GET endpoint will be successfully called.

-------------------code----------------------
const request = require("supertest");
let server;

describe("/api/genres", () => {
  beforeEach(() => {
    server = require("../../index");
  });

  afterEach(() => {
    server.close();
  });

  describe("GET /", () => {
    it("should return all genres", async () => {
      const res = await request(server).get("/api/genres");
      expect(res.status).toBe(200);
    });
  });
});
-------------------code----------------------

---

## 7. Next Steps

* This first test only checks the status code.
* It does not verify whether the response actually contains genres.
* In the next lecture, the test database will be pre-populated with sample genres.
* The test will then be updated to confirm that the returned genres match the data stored in the database.

---

