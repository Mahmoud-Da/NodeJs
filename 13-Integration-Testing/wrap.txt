*** 1- Introduction ***
---

# Integration Testing Overview

## 1. Unit Tests Recap

* Unit tests are simple and quick to write.
* They execute very fast.
* Best suited for functions that have zero or minimal dependency on external resources.
* Useful for testing small, isolated pieces of logic.

## 2. The Need for Integration Tests

* Real-world applications often rely on one or more external resources such as databases, file systems, or network services.
* Integration tests validate that the application code works correctly together with these external systems.
* Instead of testing components in isolation, integration tests check them as a whole.

## 3. Working With a Real Database

* Integration tests require a real database instance.
* The database is populated with test data before running tests.
* Tests interact with the application exactly as a real client would.

## 4. How Integration Tests Work

1. Prepare test data in the database.
2. Send an HTTP request to the endpoint being tested.
3. Make assertions based on either:

   * The HTTP response.
   * The changes in the database.

### Example

* Sending an HTTP POST request to create a new genre.
* After the request, the test inspects the database to ensure that the new genre has been created.

## 5. Next Steps

* In the next lecture, you will make a few adjustments to the application code to prepare it for integration testing.

---

*** 2- Preparing the App ***
---

# Preparing the Application for Integration Testing

## 1. Required Adjustments Before Writing Integration Tests

Before starting integration tests for the Vidly application, several updates are needed to ensure the environment works correctly.

---

## 2. Fixing the Index Module

* Open `index.js`.
* A previous refactor introduced an issue: on line 5, the logging module was required but not invoked.
* Ensure that the required logging module is actually called as a function.
* Without calling it, logging will not work properly.

---

## 3. Updating the NPM Test Script

* Open `package.json`.
* Modify the test script to include the `--verbose` flag.
* The verbose flag causes Jest to print additional diagnostic information in the console.
* This extra output is useful for troubleshooting when tests fail or behave unexpectedly.

---

## 4. Adjusting the Logging Module

* Open the logging module used for Winston integrations.

* Previously, MongoDB was configured as a transport for Winston, using `winston-mongodb`.

* This module currently causes the test runner to freeze when running integration tests in the terminal.

* The issue may depend on the specific version or environment and may not occur on all machines.

* To avoid blocking integration tests:

  1. Temporarily comment out the MongoDB logging configuration.
  2. Comment out the lines that add MongoDB as a Winston transport (around line 14 in the logging module).

* This allows focus on integration tests without interference from the Winston MongoDB plugin.

* The configuration can be restored later once the issue is resolved.

---

## 5. Summary of Required Changes

1. **index.js**:

   * Add parentheses to invoke the logging module function on line 5.

2. **package.json**:

   * Add the `--verbose` flag to the test command.

3. **logging module**:

   * Temporarily disable the Winston MongoDB plugin by commenting out its configuration and transport setup.

---

*** 3- Setting Up the Test Db ***
---

# Setting Up a Test Database for Integration Testing

## 1. Why We Need a Separate Test Database

* Integration tests use a real database.
* These tests add and remove documents from the database.
* Because of this behavior, the test database must be **separate** from both development and production databases.
* This prevents accidental modification or corruption of real data.

---

## 2. Adding a Database Key to Configuration

### Step 1: Modify `default.json`

* Go to the `config` folder and open `default.json`.
* Add a new key named `db`.
* Set `db` to your default MongoDB connection string.
* Ensure that no single quotes are used.

**Example structure:**

-------------------code----------------------
{
  "db": "mongodb://localhost/vidly"
}
-------------------code----------------------

---

## 3. Move the Connection String to Configuration

* Open `db.js`.
* Cut the MongoDB connection string from the file.
* Paste it into `default.json` under the new `db` key.
* This centralizes configuration and keeps environment settings clean.

---

## 4. Create a Test-Specific Configuration

### Step 1: Modify `test.json`

* Open `test.json` in the same configuration folder.
* Copy the new `db` key from `default.json`.
* Change the database name to something like `vidly_test`.

**Example:**

-------------------code----------------------
"db": "mongodb://localhost/vidly_test"
-------------------code----------------------

This ensures tests run against a separate database.

---

## 5. Updating `db.js` to Use Environment-Based Configuration

### Step 1: Load the Configuration Module

* In `db.js`, add:

  -------------------code----------------------
  const config = require('config');
  -------------------code----------------------
* Replace hardcoded connection strings with:

  -------------------code----------------------
  config.get('db')
  -------------------code----------------------

### Step 2: Improve Code Clarity

* Create a constant for the database connection:

  -------------------code----------------------
  const db = config.get('db');
  -------------------code----------------------
* Use this constant both when connecting and when logging the active database.

---

## 6. Verifying Environment-Based Database Selection

* When running the application normally, it connects to the development database.
* When running tests, it should connect to the test database.

### Manual simulation:

1. Set the environment variable:

   -------------------code----------------------
   NODE_ENV=test
   -------------------code----------------------
2. Run the app:

   -------------------code----------------------
   node index.js
   -------------------code----------------------
3. The console should show a connection to the test database.

---

## 7. Next Step

* With the test database configured, the next lecture will focus on writing the first integration test.

---
