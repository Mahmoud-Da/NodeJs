*** 1- Introduction ***
---

# Integration Testing Overview

## 1. Unit Tests Recap

* Unit tests are simple and quick to write.
* They execute very fast.
* Best suited for functions that have zero or minimal dependency on external resources.
* Useful for testing small, isolated pieces of logic.

## 2. The Need for Integration Tests

* Real-world applications often rely on one or more external resources such as databases, file systems, or network services.
* Integration tests validate that the application code works correctly together with these external systems.
* Instead of testing components in isolation, integration tests check them as a whole.

## 3. Working With a Real Database

* Integration tests require a real database instance.
* The database is populated with test data before running tests.
* Tests interact with the application exactly as a real client would.

## 4. How Integration Tests Work

1. Prepare test data in the database.
2. Send an HTTP request to the endpoint being tested.
3. Make assertions based on either:

   * The HTTP response.
   * The changes in the database.

### Example

* Sending an HTTP POST request to create a new genre.
* After the request, the test inspects the database to ensure that the new genre has been created.

## 5. Next Steps

* In the next lecture, you will make a few adjustments to the application code to prepare it for integration testing.

---

*** 2- Preparing the App ***
---

# Preparing the Application for Integration Testing

## 1. Required Adjustments Before Writing Integration Tests

Before starting integration tests for the Vidly application, several updates are needed to ensure the environment works correctly.

---

## 2. Fixing the Index Module

* Open `index.js`.
* A previous refactor introduced an issue: on line 5, the logging module was required but not invoked.
* Ensure that the required logging module is actually called as a function.
* Without calling it, logging will not work properly.

---

## 3. Updating the NPM Test Script

* Open `package.json`.
* Modify the test script to include the `--verbose` flag.
* The verbose flag causes Jest to print additional diagnostic information in the console.
* This extra output is useful for troubleshooting when tests fail or behave unexpectedly.

---

## 4. Adjusting the Logging Module

* Open the logging module used for Winston integrations.

* Previously, MongoDB was configured as a transport for Winston, using `winston-mongodb`.

* This module currently causes the test runner to freeze when running integration tests in the terminal.

* The issue may depend on the specific version or environment and may not occur on all machines.

* To avoid blocking integration tests:

  1. Temporarily comment out the MongoDB logging configuration.
  2. Comment out the lines that add MongoDB as a Winston transport (around line 14 in the logging module).

* This allows focus on integration tests without interference from the Winston MongoDB plugin.

* The configuration can be restored later once the issue is resolved.

---

## 5. Summary of Required Changes

1. **index.js**:

   * Add parentheses to invoke the logging module function on line 5.

2. **package.json**:

   * Add the `--verbose` flag to the test command.

3. **logging module**:

   * Temporarily disable the Winston MongoDB plugin by commenting out its configuration and transport setup.

---

*** 3- Setting Up the Test Db ***
---

# Setting Up a Test Database for Integration Testing

## 1. Why We Need a Separate Test Database

* Integration tests use a real database.
* These tests add and remove documents from the database.
* Because of this behavior, the test database must be **separate** from both development and production databases.
* This prevents accidental modification or corruption of real data.

---

## 2. Adding a Database Key to Configuration

### Step 1: Modify `default.json`

* Go to the `config` folder and open `default.json`.
* Add a new key named `db`.
* Set `db` to your default MongoDB connection string.
* Ensure that no single quotes are used.

**Example structure:**

-------------------code----------------------
{
  "db": "mongodb://localhost/vidly"
}
-------------------code----------------------

---

## 3. Move the Connection String to Configuration

* Open `db.js`.
* Cut the MongoDB connection string from the file.
* Paste it into `default.json` under the new `db` key.
* This centralizes configuration and keeps environment settings clean.

---

## 4. Create a Test-Specific Configuration

### Step 1: Modify `test.json`

* Open `test.json` in the same configuration folder.
* Copy the new `db` key from `default.json`.
* Change the database name to something like `vidly_test`.

**Example:**

-------------------code----------------------
"db": "mongodb://localhost/vidly_test"
-------------------code----------------------

This ensures tests run against a separate database.

---

## 5. Updating `db.js` to Use Environment-Based Configuration

### Step 1: Load the Configuration Module

* In `db.js`, add:

  -------------------code----------------------
  const config = require('config');
  -------------------code----------------------
* Replace hardcoded connection strings with:

  -------------------code----------------------
  config.get('db')
  -------------------code----------------------

### Step 2: Improve Code Clarity

* Create a constant for the database connection:

  -------------------code----------------------
  const db = config.get('db');
  -------------------code----------------------
* Use this constant both when connecting and when logging the active database.

---

## 6. Verifying Environment-Based Database Selection

* When running the application normally, it connects to the development database.
* When running tests, it should connect to the test database.

### Manual simulation:

1. Set the environment variable:

   -------------------code----------------------
   NODE_ENV=test
   -------------------code----------------------
2. Run the app:

   -------------------code----------------------
   node index.js
   -------------------code----------------------
3. The console should show a connection to the test database.

---

## 7. Next Step

* With the test database configured, the next lecture will focus on writing the first integration test.

---


*** 4- Your First Integration Test ***

# Writing Integration Tests with Supertest

## 1. Installing Supertest

* Integration tests for Express applications require a library called **supertest**.
* Supertest allows sending HTTP requests to your endpoints programmatically, similar to Postman.
* Install it as a development dependency:
  `npm install supertest --save-dev`
* The version used in the lecture is 3.0.0.

---

## 2. Exporting the Server from index.js

* Open `index.js`.
* The `app.listen()` call returns a server object.
* Store the returned object in a variable, for example:

  -------------------code----------------------
  const server = app.listen(...)
  -------------------code----------------------
* Export the server:

  -------------------code----------------------
  module.exports = server;
  -------------------code----------------------
* This allows test files to load and control the server instance.

---

## 3. Creating the Integration Test Structure

### Step 1: Create a Test Directory

* Inside the `tests` folder, create a new folder named `integration`.
* Inside that folder, create a test file:

  -------------------code----------------------
  genres.test.js
  -------------------code----------------------

### Step 2: Create the Test Suite Structure

* Start with a top-level describe block:

  -------------------code----------------------
  describe('/api/genres', () => { ... });
  -------------------code----------------------

* Inside it, add another describe block for GET requests:

  -------------------code----------------------
  describe('GET /', () => { ... });
  -------------------code----------------------

* Inside this block, write your test:

  -------------------code----------------------
  it('should return all genres', () => { ... });
  -------------------code----------------------

---

## 4. Loading and Managing the Server in Tests

### Problem

* If the server is loaded globally, Jest will restart tests after code changes.
* This causes an error because the server is already listening on port 3000.

### Solution

* Load the server inside a `beforeEach` block.
* Close the server in an `afterEach` block.

### Example:

-------------------code----------------------
let server;

beforeEach(() => {
  server = require('../../../index');
});

afterEach(() => {
  server.close();
});
-------------------code----------------------

This ensures:

* A fresh server instance is used for each test.
* No port conflicts occur.

---

## 5. Using Supertest

### Step 1: Import Supertest

-------------------code----------------------
const request = require('supertest');
-------------------code----------------------

### Step 2: Sending a Request

* The `request()` function takes the server object.
* You can then chain request methods such as `.get()`, `.post()`, `.put()`, `.delete()`.

### Example GET request:

-------------------code----------------------
const res = await request(server).get('/api/genres');
-------------------code----------------------

* Since `await` is used, the test function must be marked as `async`.

---

## 6. Making Assertions

* A simple initial assertion is to check the response status:

  -------------------code----------------------
  expect(res.status).toBe(200);
  -------------------code----------------------

* Running the test:

  -------------------code----------------------
  npm test
  -------------------code----------------------

* If everything is set up correctly, tests will pass and the GET endpoint will be successfully called.

-------------------code----------------------
const request = require("supertest");
let server;

describe("/api/genres", () => {
  beforeEach(() => {
    server = require("../../index");
  });

  afterEach(() => {
    server.close();
  });

  describe("GET /", () => {
    it("should return all genres", async () => {
      const res = await request(server).get("/api/genres");
      expect(res.status).toBe(200);
    });
  });
});
-------------------code----------------------

---

## 7. Next Steps

* This first test only checks the status code.
* It does not verify whether the response actually contains genres.
* In the next lecture, the test database will be pre-populated with sample genres.
* The test will then be updated to confirm that the returned genres match the data stored in the database.

---

*** 5- Populating the Test Db ***
---

# Improving the Integration Test by Populating and Cleaning the Database

## 1. Purpose of Improving the Test

The earlier test only checked the HTTP status code.
To make the test meaningful, we need to:

1. Insert known genre documents into the test database.
2. Call the `/api/genres` endpoint.
3. Assert that the returned genres are exactly the ones stored.

This validates the full application stack including:

* Express routing
* Validation middleware
* MongoDB operations

---

# 2. Loading the Genre Model

At the top of the test file, import the Genre model:

-------------------code----------------------
const { Genre } = require('../../models/genre');
-------------------code----------------------

Notes:

* Use object destructuring because the module exports `{ Genre, validate }`.
* Move up two directories from the integration folder.

---

# 3. Populating the Database in the Test

Inside the test, insert sample documents:

-------------------code----------------------
await Genre.collection.insertMany([
  { name: 'genre1' },
  { name: 'genre2' }
]);
-------------------code----------------------

Important notes:

* Use real names like `genre1` and `genre2` because short values like `a` or `b` will fail validation.
* `insertMany` returns a promise, so you must use `await`.

---

# 4. Adding Assertions

### Basic count check

-------------------code----------------------
expect(res.body.length).toBe(2);
-------------------code----------------------

However, this only checks the array length.
It does not validate the content, so even `[1,2]` would pass.

---

# 5. Cleaning the Database After Each Test

### The Problem

Each test run adds two more documents to the test database.
Running tests multiple times leads to duplicates:

* First run: 2 documents
* Second run: 4 documents
* Third run: 6 documents
* etc.

This breaks repeatability.

### The Solution

Always clean the collection after each test using:

-------------------code----------------------
await Genre.deleteMany({});
-------------------code----------------------

Place this cleanup inside `afterEach`, not inside the test itself, so it always runs even if assertions fail.

Also mark `afterEach` as `async`.

---

# 6. Updating afterEach

-------------------code----------------------
afterEach(async () => {
  await Genre.deleteMany({});
  await server.close();
});
-------------------code----------------------

This ensures:

* The server shuts down cleanly.
* The database is reset.
* Tests remain isolated.

---

# 7. Ensuring Tests Are Repeatable

Before re-running, verify your test database contains no stale documents.
If needed, manually delete the `genres` collection in MongoDB Compass.

---

# 8. Improving the Assertions to Check Actual Data

A stronger test ensures the response contains the exact inserted genres.

Use the `Array.prototype.some` method:

-------------------code----------------------
expect(res.body.some(g => g.name === 'genre1')).toBeTruthy();
expect(res.body.some(g => g.name === 'genre2')).toBeTruthy();
-------------------code----------------------

This verifies:

* The returned list contains a genre named `genre1`.
* The list also contains a genre named `genre2`.

---

# 9. Final Test Behavior

After running:

* The test inserts two genres.
* Calls the `/api/genres` endpoint.
* Confirms the response includes both genres.
* Cleans the database.
* Repeats cleanly every time.

Tests must always run in isolation and must never depend on state left behind from previous runs.

---

# 10. Exercise Given in the Lecture

In `routes/genres.js`, there is a route to get a single genre by ID.
This route has two execution paths:

1. If the ID does not match any document, return status **404**.
2. If the document exists, return status **200** with the genre.

**Exercise:**
Write two integration tests for this endpoint:

1. A test that ensures a non-existing genre ID returns **404**.
2. A test that ensures a valid genre ID returns the correct genre object.

The solution will appear in the next lecture.

---


*** 6- Testing Routes with Parameters ***
---

## Integration Test: GET /api/genres/:id

### 1. Goal of the Test

Create a new test suite to verify all tests for the endpoint:

-------------------code----------------------
GET /api/genres/:id
-------------------code----------------------

The first test checks that the endpoint returns a genre when provided a valid ID.

---

## 2. Preparing the Database

For this test, only a single genre is needed. You do not need to insert multiple documents.

### Steps:

1. Create a new `Genre` instance:

-------------------code----------------------
const genre = new Genre({ name: "genre1" });
-------------------code----------------------

2. Save it to the database using:

-------------------code----------------------
await genre.save();
-------------------code----------------------

Make the test function `async` since `save()` returns a promise.

---

## 3. Calling the Endpoint

Make a GET request to the endpoint using supertest:

-------------------code----------------------
const res = await request(server)
  .get("/api/genres/" + genre._id);
-------------------code----------------------

Store the response in a variable for later assertions.

---

## 4. Writing Assertions

### Status Code

Ensure the endpoint returns HTTP status 200:

-------------------code----------------------
expect(res.status).toBe(200);
-------------------code----------------------

### Response Body

Initially, you might try:

-------------------code----------------------
expect(res.body).toMatchObject(genre);
-------------------code----------------------

But this fails because:

* Mongoose stores `_id` as an **ObjectId**.
* When retrieved from the database, `_id` becomes a **string**.
* Therefore, comparing the entire object directly will cause a mismatch.

### Correct Approach

Assert only the relevant properties manually:

-------------------code----------------------
expect(res.body).toHaveProperty("name", genre.name);
-------------------code----------------------

---

## 5. Running the Test

After updating the expectation, run the test again.
All tests should now pass.

---

## 6. Next Lecture

The next lecture will cover writing the second integration test for this endpoint.

---

*** 7- Validating ObjectIDs ***
---

## Integration Test: GET /api/genres/:id

### Test 2: Invalid ID Should Return 404

### 1. Duplicating the First Test

Start by duplicating the previous test and renaming it to reflect the new scenario:

**Test name:**
`it("should return 404 if invalid ID is passed", ...)`

---

## 2. No Need to Insert a Genre

For this test:

* There is no need to create or save a genre in the database.
* Whether the collection is empty or full makes no difference.
* Passing an invalid ID should result in a 404 regardless of the database content.

Remove the `new Genre()` and `save()` lines to make the test simpler, cleaner, and faster.

---

## 3. Calling the Endpoint with an Invalid ID

Instead of using `genre._id`, pass a blatantly invalid ID like:

-------------------code----------------------
/api/genres/1
-------------------code----------------------

This should trigger a failure because `1` is not a valid MongoDB ObjectId.

Your expectation:

-------------------code----------------------js
expect(res.status).toBe(404);
-------------------code----------------------

Checking the response message is optional since the status code is what matters for clients.

---

## 4. Test Failure and Debugging the Issue

Running the test initially results in:

* Expected: 404
* Received: 500 (internal server error)

### Reason:

The invalid ID causes Mongoose to throw a `CastError` because it attempts to convert `"1"` into an ObjectId.

This error reaches your error middleware, where Winston logs it, and the middleware returns status 500.

### Meaning:

The route handler does not handle invalid route parameters before calling `findById`.

---

## 5. Fixing the Route Handler

Before calling:

-------------------code----------------------js
Genre.findById(req.params.id)
-------------------code----------------------

you must validate the ID.

### Use Mongoose's built-in validator:

-------------------code----------------------js
if (!mongoose.Types.ObjectId.isValid(req.params.id))
  return res.status(404).send("Invalid ID");
-------------------code----------------------

This ensures:

* No cast error is thrown.
* The client receives the expected 404.

Save the file and re-run the tests.

---

## 6. Result

All tests now pass correctly.

---

## 7. Next Step

Multiple endpoints in your application fetch a single resource by ID.
Each will need the same ObjectId validation logic.

In the next lecture, this logic will be refactored into a reusable middleware function to avoid duplication.

---

