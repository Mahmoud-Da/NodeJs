*** 1- Introduction ***
---

# Integration Testing Overview

## 1. Unit Tests Recap

* Unit tests are simple and quick to write.
* They exec very fast.
* Best suited for functions that have zero or minimal dependency on external resources.
* Useful for testing small, isolated pieces of logic.

## 2. The Need for Integration Tests

* Real-world applications often rely on one or more external resources such as databases, file systems, or network services.
* Integration tests validate that the application code works correctly together with these external systems.
* Instead of testing components in isolation, integration tests check them as a whole.

## 3. Working With a Real Database

* Integration tests require a real database instance.
* The database is populated with test data before running tests.
* Tests interact with the application exactly as a real client would.

## 4. How Integration Tests Work

1. Prepare test data in the database.
2. Send an HTTP request to the endpoint being tested.
3. Make assertions based on either:

   * The HTTP response.
   * The changes in the database.

### Example

* Sending an HTTP POST request to create a new genre.
* After the request, the test inspects the database to ensure that the new genre has been created.

## 5. Next Steps

* In the next lecture, you will make a few adjustments to the application code to prepare it for integration testing.

---

*** 2- Preparing the App ***
---

# Preparing the Application for Integration Testing

## 1. Required Adjustments Before Writing Integration Tests

Before starting integration tests for the Vidly application, several updates are needed to ensure the environment works correctly.

---

## 2. Fixing the Index Module

* Open `index.js`.
* A previous refactor introduced an issue: on line 5, the logging module was required but not invoked.
* Ensure that the required logging module is actually called as a function.
* Without calling it, logging will not work properly.

---

## 3. Updating the NPM Test Script

* Open `package.json`.
* Modify the test script to include the `--verbose` flag.
* The verbose flag causes Jest to print additional diagnostic information in the console.
* This extra output is useful for troubleshooting when tests fail or behave unexpectedly.

---

## 4. Adjusting the Logging Module

* Open the logging module used for Winston integrations.

* Previously, MongoDB was configured as a transport for Winston, using `winston-mongodb`.

* This module currently causes the test runner to freeze when running integration tests in the terminal.

* The issue may depend on the specific version or environment and may not occur on all machines.

* To avoid blocking integration tests:

  1. Temporarily comment out the MongoDB logging configuration.
  2. Comment out the lines that add MongoDB as a Winston transport (around line 14 in the logging module).

* This allows focus on integration tests without interference from the Winston MongoDB plugin.

* The configuration can be restored later once the issue is resolved.

---

## 5. Summary of Required Changes

1. **index.js**:

   * Add parentheses to invoke the logging module function on line 5.

2. **package.json**:

   * Add the `--verbose` flag to the test command.

3. **logging module**:

   * Temporarily disable the Winston MongoDB plugin by commenting out its configuration and transport setup.

---

*** 3- Setting Up the Test Db ***
---

# Setting Up a Test Database for Integration Testing

## 1. Why We Need a Separate Test Database

* Integration tests use a real database.
* These tests add and remove documents from the database.
* Because of this behavior, the test database must be **separate** from both development and production databases.
* This prevents accidental modification or corruption of real data.

---

## 2. Adding a Database Key to Configuration

### Step 1: Modify `default.json`

* Go to the `config` folder and open `default.json`.
* Add a new key named `db`.
* Set `db` to your default MongoDB connection string.
* Ensure that no single quotes are used.

**Example structure:**

-------------------code----------------------
{
  "db": "mongodb://localhost/vidly"
}
-------------------code----------------------

---

## 3. Move the Connection String to Configuration

* Open `db.js`.
* Cut the MongoDB connection string from the file.
* Paste it into `default.json` under the new `db` key.
* This centralizes configuration and keeps environment settings clean.

---

## 4. Create a Test-Specific Configuration

### Step 1: Modify `test.json`

* Open `test.json` in the same configuration folder.
* Copy the new `db` key from `default.json`.
* Change the database name to something like `vidly_test`.

**Example:**

-------------------code----------------------
"db": "mongodb://localhost/vidly_test"
-------------------code----------------------

This ensures tests run against a separate database.

---

## 5. Updating `db.js` to Use Environment-Based Configuration

### Step 1: Load the Configuration Module

* In `db.js`, add:

  -------------------code----------------------
  const config = require('config');
  -------------------code----------------------
* Replace hardcoded connection strings with:

  -------------------code----------------------
  config.get('db')
  -------------------code----------------------

### Step 2: Improve Code Clarity

* Create a constant for the database connection:

  -------------------code----------------------
  const db = config.get('db');
  -------------------code----------------------
* Use this constant both when connecting and when logging the active database.

---

## 6. Verifying Environment-Based Database Selection

* When running the application normally, it connects to the development database.
* When running tests, it should connect to the test database.

### Manual simulation:

1. Set the environment variable:

   -------------------code----------------------
   NODE_ENV=test
   -------------------code----------------------
2. Run the app:

   -------------------code----------------------
   node index.js
   -------------------code----------------------
3. The console should show a connection to the test database.

---

## 7. Next Step

* With the test database configured, the next lecture will focus on writing the first integration test.

---


*** 4- Your First Integration Test ***

# Writing Integration Tests with Supertest

## 1. Installing Supertest

* Integration tests for Express applications require a library called **supertest**.
* Supertest allows sending HTTP requests to your endpoints programmatically, similar to Postman.
* Install it as a development dependency:
  `npm install supertest --save-dev`
* The version used in the lecture is 3.0.0.

---

## 2. Exporting the Server from index.js

* Open `index.js`.
* The `app.listen()` call returns a server object.
* Store the returned object in a variable, for example:

  -------------------code----------------------
  const server = app.listen(...)
  -------------------code----------------------
* Export the server:

  -------------------code----------------------
  module.exports = server;
  -------------------code----------------------
* This allows test files to load and control the server instance.

---

## 3. Creating the Integration Test Structure

### Step 1: Create a Test Directory

* Inside the `tests` folder, create a new folder named `integration`.
* Inside that folder, create a test file:

  -------------------code----------------------
  genres.test.js
  -------------------code----------------------

### Step 2: Create the Test Suite Structure

* Start with a top-level describe block:

  -------------------code----------------------
  describe('/api/genres', () => { ... });
  -------------------code----------------------

* Inside it, add another describe block for GET requests:

  -------------------code----------------------
  describe('GET /', () => { ... });
  -------------------code----------------------

* Inside this block, write your test:

  -------------------code----------------------
  it('should return all genres', () => { ... });
  -------------------code----------------------

---

## 4. Loading and Managing the Server in Tests

### Problem

* If the server is loaded globally, Jest will restart tests after code changes.
* This causes an error because the server is already listening on port 3000.

### Solution

* Load the server inside a `beforeEach` block.
* Close the server in an `afterEach` block.

### Example:

-------------------code----------------------
let server;

beforeEach(() => {
  server = require('../../../index');
});

afterEach(() => {
  server.close();
});
-------------------code----------------------

This ensures:

* A fresh server instance is used for each test.
* No port conflicts occur.

---

## 5. Using Supertest

### Step 1: Import Supertest

-------------------code----------------------
const request = require('supertest');
-------------------code----------------------

### Step 2: Sending a Request

* The `request()` function takes the server object.
* You can then chain request methods such as `.get()`, `.post()`, `.put()`, `.delete()`.

### Example GET request:

-------------------code----------------------
const res = await request(server).get('/api/genres');
-------------------code----------------------

* Since `await` is used, the test function must be marked as `async`.

---

## 6. Making Assertions

* A simple initial assertion is to check the response status:

  -------------------code----------------------
  expect(res.status).toBe(200);
  -------------------code----------------------

* Running the test:

  -------------------code----------------------
  npm test
  -------------------code----------------------

* If everything is set up correctly, tests will pass and the GET endpoint will be successfully called.

-------------------code----------------------
const request = require("supertest");
let server;

describe("/api/genres", () => {
  beforeEach(() => {
    server = require("../../index");
  });

  afterEach(() => {
    server.close();
  });

  describe("GET /", () => {
    it("should return all genres", async () => {
      const res = await request(server).get("/api/genres");
      expect(res.status).toBe(200);
    });
  });
});
-------------------code----------------------

---

## 7. Next Steps

* This first test only checks the status code.
* It does not verify whether the response actually contains genres.
* In the next lecture, the test database will be pre-populated with sample genres.
* The test will then be updated to confirm that the returned genres match the data stored in the database.

---

*** 5- Populating the Test Db ***
---

# Improving the Integration Test by Populating and Cleaning the Database

## 1. Purpose of Improving the Test

The earlier test only checked the HTTP status code.
To make the test meaningful, we need to:

1. Insert known genre documents into the test database.
2. Call the `/api/genres` endpoint.
3. Assert that the returned genres are exactly the ones stored.

This validates the full application stack including:

* Express routing
* Validation middleware
* MongoDB operations

---

# 2. Loading the Genre Model

At the top of the test file, import the Genre model:

-------------------code----------------------
const { Genre } = require('../../models/genre');
-------------------code----------------------

Notes:

* Use object destructuring because the module exports `{ Genre, validate }`.
* Move up two directories from the integration folder.

---

# 3. Populating the Database in the Test

Inside the test, insert sample documents:

-------------------code----------------------
await Genre.collection.insertMany([
  { name: 'genre1' },
  { name: 'genre2' }
]);
-------------------code----------------------

Important notes:

* Use real names like `genre1` and `genre2` because short values like `a` or `b` will fail validation.
* `insertMany` returns a promise, so you must use `await`.

---

# 4. Adding Assertions

### Basic count check

-------------------code----------------------
expect(res.body.length).toBe(2);
-------------------code----------------------

However, this only checks the array length.
It does not validate the content, so even `[1,2]` would pass.

---

# 5. Cleaning the Database After Each Test

### The Problem

Each test run adds two more documents to the test database.
Running tests multiple times leads to duplicates:

* First run: 2 documents
* Second run: 4 documents
* Third run: 6 documents
* etc.

This breaks repeatability.

### The Solution

Always clean the collection after each test using:

-------------------code----------------------
await Genre.deleteMany({});
-------------------code----------------------

Place this cleanup inside `afterEach`, not inside the test itself, so it always runs even if assertions fail.

Also mark `afterEach` as `async`.

---

# 6. Updating afterEach

-------------------code----------------------
afterEach(async () => {
  await Genre.deleteMany({});
  await server.close();
});
-------------------code----------------------

This ensures:

* The server shuts down cleanly.
* The database is reset.
* Tests remain isolated.

---

# 7. Ensuring Tests Are Repeatable

Before re-running, verify your test database contains no stale documents.
If needed, manually delete the `genres` collection in MongoDB Compass.

---

# 8. Improving the Assertions to Check Actual Data

A stronger test ensures the response contains the exact inserted genres.

Use the `Array.prototype.some` method:

-------------------code----------------------
expect(res.body.some(g => g.name === 'genre1')).toBeTruthy();
expect(res.body.some(g => g.name === 'genre2')).toBeTruthy();
-------------------code----------------------

This verifies:

* The returned list contains a genre named `genre1`.
* The list also contains a genre named `genre2`.

---

# 9. Final Test Behavior

After running:

* The test inserts two genres.
* Calls the `/api/genres` endpoint.
* Confirms the response includes both genres.
* Cleans the database.
* Repeats cleanly every time.

Tests must always run in isolation and must never depend on state left behind from previous runs.

---

# 10. Exercise Given in the Lecture

In `routes/genres.js`, there is a route to get a single genre by ID.
This route has two execution paths:

1. If the ID does not match any document, return status **404**.
2. If the document exists, return status **200** with the genre.

**Exercise:**
Write two integration tests for this endpoint:

1. A test that ensures a non-existing genre ID returns **404**.
2. A test that ensures a valid genre ID returns the correct genre object.

The solution will appear in the next lecture.

---


*** 6- Testing Routes with Parameters ***
---

## Integration Test: GET /api/genres/:id

### 1. Goal of the Test

Create a new test suite to verify all tests for the endpoint:

-------------------code----------------------
GET /api/genres/:id
-------------------code----------------------

The first test checks that the endpoint returns a genre when provided a valid ID.

---

## 2. Preparing the Database

For this test, only a single genre is needed. You do not need to insert multiple documents.

### Steps:

1. Create a new `Genre` instance:

-------------------code----------------------
const genre = new Genre({ name: "genre1" });
-------------------code----------------------

2. Save it to the database using:

-------------------code----------------------
await genre.save();
-------------------code----------------------

Make the test function `async` since `save()` returns a promise.

---

## 3. Calling the Endpoint

Make a GET request to the endpoint using supertest:

-------------------code----------------------
const res = await request(server)
  .get("/api/genres/" + genre._id);
-------------------code----------------------

Store the response in a variable for later assertions.

---

## 4. Writing Assertions

### Status Code

Ensure the endpoint returns HTTP status 200:

-------------------code----------------------
expect(res.status).toBe(200);
-------------------code----------------------

### Response Body

Initially, you might try:

-------------------code----------------------
expect(res.body).toMatchObject(genre);
-------------------code----------------------

But this fails because:

* Mongoose stores `_id` as an **ObjectId**.
* When retrieved from the database, `_id` becomes a **string**.
* Therefore, comparing the entire object directly will cause a mismatch.

### Correct Approach

Assert only the relevant properties manually:

-------------------code----------------------
expect(res.body).toHaveProperty("name", genre.name);
-------------------code----------------------

---

## 5. Running the Test

After updating the expectation, run the test again.
All tests should now pass.

---

## 6. Next Lecture

The next lecture will cover writing the second integration test for this endpoint.

---

*** 7- Validating ObjectIDs ***
---

## Integration Test: GET /api/genres/:id

### Test 2: Invalid ID Should Return 404

### 1. Duplicating the First Test

Start by duplicating the previous test and renaming it to reflect the new scenario:

**Test name:**
`it("should return 404 if invalid ID is passed", ...)`

---

## 2. No Need to Insert a Genre

For this test:

* There is no need to create or save a genre in the database.
* Whether the collection is empty or full makes no difference.
* Passing an invalid ID should result in a 404 regardless of the database content.

Remove the `new Genre()` and `save()` lines to make the test simpler, cleaner, and faster.

---

## 3. Calling the Endpoint with an Invalid ID

Instead of using `genre._id`, pass a blatantly invalid ID like:

-------------------code----------------------
/api/genres/1
-------------------code----------------------

This should trigger a failure because `1` is not a valid MongoDB ObjectId.

Your expectation:

-------------------code----------------------js
expect(res.status).toBe(404);
-------------------code----------------------

Checking the response message is optional since the status code is what matters for clients.

---

## 4. Test Failure and Debugging the Issue

Running the test initially results in:

* Expected: 404
* Received: 500 (internal server error)

### Reason:

The invalid ID causes Mongoose to throw a `CastError` because it attempts to convert `"1"` into an ObjectId.

This error reaches your error middleware, where Winston logs it, and the middleware returns status 500.

### Meaning:

The route handler does not handle invalid route parameters before calling `findById`.

---

## 5. Fixing the Route Handler

Before calling:

-------------------code----------------------js
Genre.findById(req.params.id)
-------------------code----------------------

you must validate the ID.

### Use Mongoose's built-in validator:

-------------------code----------------------js
if (!mongoose.Types.ObjectId.isValid(req.params.id))
  return res.status(404).send("Invalid ID");
-------------------code----------------------

This ensures:

* No cast error is thrown.
* The client receives the expected 404.

Save the file and re-run the tests.

---

## 6. Result

All tests now pass correctly.

---

## 7. Next Step

Multiple endpoints in your application fetch a single resource by ID.
Each will need the same ObjectId validation logic.

In the next lecture, this logic will be refactored into a reusable middleware function to avoid duplication.

---

*** 8- Refactoring with Confidence ***
---

# Refactoring ObjectId Validation Into a Middleware

## 1. Goal

Move the repeated ObjectId validation logic into a dedicated middleware function so it can be reused across multiple routes.

---

## 2. Creating the Middleware File

### Location:

`middleware/validateObjectId.js`

### Steps:

1. Inside the `middleware` folder, create a new file named `validateObjectId.js`.

2. Export a middleware function with the standard signature:

   -------------------code----------------------
   module.exports = function (req, res, next) { ... }
   -------------------code----------------------

3. Move the validation logic from the route handler into this middleware.

---

## 3. Middleware Implementation

### Function behavior:

* If the route parameter `id` is not a valid MongoDB ObjectId:
  Return a 404 response.
* Otherwise:
  Call `next()` to pass control to the next middleware or route handler.

### Required dependency:

Since the logic uses Mongoose validation, import Mongoose at the top.

---

## 4. Updated Middleware Code

-------------------code----------------------
const mongoose = require("mongoose");

module.exports = function (req, res, next) {
  if (!mongoose.Types.ObjectId.isValid(req.params.id))
    return res.status(404).send("Invalid ID");

  next();
};
-------------------code----------------------

---

## 5. Applying the Middleware in the Route

### Steps:

1. Import the middleware at the top of the genres route file:

   -------------------code----------------------
   const validateObjectId = require("../middleware/validateObjectId");
   -------------------code----------------------

2. Apply it in the route definition:

   -------------------code----------------------
   router.get("/:id", validateObjectId, async (req, res) => {
     const genre = await Genre.findById(req.params.id);
     if (!genre) return res.status(404).send("Genre not found");
     res.send(genre);
   });
   -------------------code----------------------

---

## 6. Verifying With Tests

Because the integration tests cover all execution paths, saving and running the test suite will confirm that the refactor did not break anything.

After running the tests, all tests pass successfully.

---

*** 9- Testing the Authorization ***

---

# Testing the Route Handler for Creating a New Genre

### Endpoint: `POST /api/genres`

---

## 1. Determining the Number of Tests

A test suite must include at least as many tests as the number of execution paths in the route handler.

### Execution paths:

1. **User not logged in**
   Should return `401 Unauthorized`.

2. **Invalid genre (fails validation)**
   Should return `400 Bad Request`.

3. **Valid genre**
   This requires two separate tests:

   * Ensure the genre is saved in the database.
   * Ensure the created genre is returned in the response body.

Total tests needed: **4**

---

## 2. Creating the Test Suite

In the test file, create a new `describe` block for:

-------------------code----------------------
POST /api/genres
-------------------code----------------------

---

## 3. First Test: Unauthorized Access

### Goal:

Verify that the endpoint returns `401` if the client is not logged in.

### Steps:

1. Use `request(server)` to call the endpoint.
2. Use `.post("/api/genres")`.
3. Send a genre object:

   -------------------code----------------------
   { name: "genre1" }
   -------------------code----------------------
4. Expect the status to be `401`.

### Important:

The test function must be `async` because the post operation returns a promise.

---

## 4. Example Test Code (First Test)

-------------------code----------------------
it("should return 401 if client is not logged in", async () => {
  const res = await request(server)
    .post("/api/genres")
    .send({ name: "genre1" });

  expect(res.status).toBe(401);
});
-------------------code----------------------

---

## 5. Result

After adding `async` and saving, running the test confirms that it passes successfully.

---

*** 10- Testing the Invalid Inputs ***

---

# Testing the POST `/api/genres` Route

## Validations, Authentication, and Error Handling

This lecture focuses on writing integration tests for the endpoint responsible for creating a new genre. The goal is to cover each execution path and confirm that both authentication and input validation behave correctly.

---

## 1. The Second Test: Invalid Genre (Less Than 5 Characters)

### Purpose

The endpoint should return a `400 Bad Request` if the client is authenticated but sends an invalid genre name. A genre is invalid when its name is fewer than five characters.

---

## 2. Preparing the Test

To simulate an authenticated request, we must generate a valid authentication token.

### Steps:

1. Import the `User` model at the top of the test file.
2. Create a new `User` instance inside the test.
3. Call `generateAuthToken()` to obtain a token.
4. Add the token to the request using `.set("x-auth-token", token)`.

---

## 3. Writing the Test

### Structure:

* Duplicate the previous test for unauthorized users.
* Modify the test so that:

  * A token is generated.
  * The token is added to the request header.
  * The genre name is shorter than five characters.
  * Expect the status code to be `400`.

### Issue Encountered

The test fails with a `500 Internal Server Error`.

### Reason

The error comes from Mongoose, not Joi.
The Joi validation schema incorrectly allowed a minimum length of three characters.
Because Joi passed the request, the invalid value reached Mongoose and triggered a schema validation error.

### Fix

Update the Joi validation schema:

* Change `.min(3)` to `.min(5)`.

After correcting this, the test passes successfully.

---

## 4. Third Test: Genre Name Longer Than 50 Characters

### Purpose

The endpoint should return `400 Bad Request` if the genre name exceeds 50 characters.

### Steps:

1. Duplicate the previous test.
2. Change the test description to indicate the length violation.
3. Replace the genre name with a dynamically generated long string.

---

## 5. Generating a Long String Dynamically

Inside Node REPL, the following observations help us generate a string of a specific length:

* `new Array(5).join("a")` gives a string of length 4.
* This means:
  Length of resulting string = array length − 1.

To generate a string with 51 characters:

* Use `new Array(52).join("a")`.

This generates a string of exactly 51 characters.

---

## 6. Second Issue: Failing Test

Again, the test fails with status `500` instead of `400`.

### Reason

In the Joi schema, only `.min(5)` was set.
Maximum length validation was missing.

### Fix

In the Joi validation function, add:

-------------------code----------------------
.max(50)
-------------------code----------------------

After updating the schema, the test passes.

---

## 7. Summary of Fixes

1. Joi minimum length updated from 3 to 5.
2. Joi maximum length added with `.max(50)`.

These ensure that invalid input is caught before reaching Mongoose.

-------------------code----------------------
it("should return 400 if genre is less than 5 characters", async () => {
      const user = new User();
      const token = user.generateAuthToken();

      const res = await request(server)
        .post("/api/genres")
        .set("x-auth-token", token)
        .send({ name: "1234" });

      expect(res.status).toBe(400);
    });

    it("should return 400 if genre is more than 50 characters", async () => {
      const user = new User();
      const token = user.generateAuthToken();

      // Generate a string of length 51
      const longName = new Array(52).join("a");

      const res = await request(server)
        .post("/api/genres")
        .set("x-auth-token", token)
        .send({ name: longName });

      expect(res.status).toBe(400);
    });
-------------------code----------------------
---



---

# Understanding How `new Array(...)` and `.join()` Behave

JavaScript's `Array` constructor behaves differently depending on how many arguments you pass and what their types are.
`join()` then acts on whatever array is produced.

Below are all cases, including your new example.

---

# 1. `new Array[1,3].join("a")`

Throws:

-------------------code----------------------
TypeError: Cannot read properties of undefined (reading 'join')
-------------------code----------------------

### Why?

* `new Array[1,3]` is parsed as `new (Array[1,3])`
* `Array[1,3]` uses the comma operator → returns the last value → `Array[3]`
* `Array[3]` is undefined
* You are trying `new undefined` → invalid

---

# 2. `new Array([1,3]).join("a")` → `'1,3'`

### Why?

* Passing a **single** argument `[1,3]`
* Creates an array with one element:

  -------------------code----------------------
  [ [1,3] ]
  -------------------code----------------------
* `join("a")` turns `[1,3]` into `"1,3"`
* Only one element → no joining occurs
  Result: `"1,3"`

---

# 3. `new Array([1,3]).join("adsad")` → `'1,3'`

Same reasoning: one element, no joining.

---

# 4. `new Array(4)` → `[ <4 empty items> ]`

* One numeric argument → creates an empty array with that length.

---

# 5. `new Array(4).join("a")` → `'aaa'`

* Four empty slots → joining produces `length - 1` separators = `3`
* Result: `"aaa"`

---

# 6. **New Example:**

## `new Array([3], [2]).join("a")` → `'3a2'`

### Why?

When you pass **multiple arguments** to the Array constructor:

-------------------code----------------------
new Array( arg1, arg2, arg3, ... )
-------------------code----------------------

JavaScript creates an array containing those arguments **directly**.

So:

-------------------code----------------------
new Array([3], [2])
-------------------code----------------------

creates:

-------------------code----------------------
[ [3], [2] ]
-------------------code----------------------

Now join them with `"a"`:

* `[3]` becomes `"3"`
* `[2]` becomes `"2"`
* Join inserts `"a"` between them

Result:

-------------------code----------------------
"3a2"
-------------------code----------------------

---

# Summary Table

| Expression                       | Created Array         | Result of `.join("a")` |
| -------------------------------- | --------------------- | ---------------------- |
| `new Array[1,3]`                 | Error                 | Error                  |
| `new Array([1,3])`               | `[ [1,3] ]`           | `"1,3"`                |
| `new Array([1,3]).join("adsad")` | `[ [1,3] ]`           | `"1,3"`                |
| `new Array(4)`                   | `[ <4 empty items> ]` | N/A                    |
| `new Array(4).join("a")`         | `[ <4 empty items> ]` | `"aaa"`                |
| `new Array([3], [2])`            | `[ [3], [2] ]`        | `"3a2"`                |

---


*** 11- Testing the Happy Path ***

---

# Testing the POST `/api/genres` Endpoint – Happy Path

In this section, we focus on the **successful execution paths** where the input is valid.

---

## 1. Number of Tests

* For each execution path, multiple tests may be required to cover all possibilities.
* Previously, we wrote tests for invalid input (too short, too long).
* Now we test the **happy path** (valid input).

---

## 2. Test 1: Saving the Genre in the Database

### Purpose

Ensure that when a valid genre is sent, it is actually saved in the database.

### Steps

1. Duplicate the last valid input test.
2. Rename it:

-------------------code----------------------
it("should save the genre if it is valid", ...)
-------------------code----------------------

3. Send a valid genre:

-------------------code----------------------
{ name: "genre1" }
-------------------code----------------------

4. Query the database using the `Genre` model:

-------------------code----------------------
const genreInDb = await Genre.find({ name: "genre1" });
-------------------code----------------------

5. Assert that the genre exists:

-------------------code----------------------
expect(genreInDb).not.toBeNull();
-------------------code----------------------

* Note: The `afterEach` function will clean up the database after each test.

---

## 3. Test 2: Returning the Genre in the Response

### Purpose

Ensure that the created genre is returned in the response body with the correct properties.

### Steps

1. Duplicate the previous test.
2. Rename it:

-------------------code----------------------
it("should return the genre if it is valid", ...)
-------------------code----------------------

3. Check the response body:

-------------------code----------------------
expect(res.body).toHaveProperty("_id");           // Ensure an id is present
expect(res.body).toHaveProperty("name", "genre1"); // Ensure the name matches
-------------------code----------------------

* No need to query the database for this test.
* We only check the response body.

---

## 4. Summary

For the happy path:

1. Test that the genre is **saved in the database**.
2. Test that the genre is **returned in the response**.

After running the tests, all should pass successfully.

---


*** 12- Writing Clean Tests ***
---

# Refactoring POST `/api/genres` Tests – Masha’s Technique

In this lecture, we focus on **reducing duplication** and making tests clean, clear, and maintainable.

---

## 1. Observations Before Refactoring

* In the original tests:

  * Each test generates an authentication token.
  * Each test sends a request body with only small variations (short genre, long genre, or missing token).
* Much of the code is repeated unnecessarily.
* Goal: Extract the **common template** and only modify the parameters relevant to the scenario.

---

## 2. Defining the Happy Path

* The **happy path** is a valid request with a valid genre and valid token.
* All tests can be derived from this template by **changing a single parameter**.
* Steps:

  1. Cut the request code from the happy path test.
  2. Add a `// TODO` comment temporarily.
  3. Define an `exec` function at the top of the test suite:

     -------------------code----------------------
     let token;
     let name;

     const exec = async () => {
       return await request(server)
         .post("/api/genres")
         .set("x-auth-token", token)
         .send({ name });
     };
     -------------------code----------------------

---

## 3. Refactoring the Tests

### 3.1 Use `beforeEach` to initialize the happy path

-------------------code----------------------
beforeEach(() => {
  token = new User().generateAuthToken();
  name = "genre1"; // default happy path
});
-------------------code----------------------

* Now, before each test, `token` and `name` are valid.
* Individual tests only modify what is necessary.

---

### 3.2 Test 1: Unauthorized User

-------------------code----------------------
it("should return 401 if client is not logged in", async () => {
  token = ""; // simulate no login
  const res = await exec();
  expect(res.status).toBe(401);
});
-------------------code----------------------

* Only one line of code to simulate this scenario.
* Matches the test description clearly.

---

### 3.3 Test 2: Genre Too Short

-------------------code----------------------
it("should return 400 if genre is less than 5 characters", async () => {
  name = "1234"; // invalid short genre
  const res = await exec();
  expect(res.status).toBe(400);
});
-------------------code----------------------

* Only the `name` is changed for this scenario.
* Test code is concise and easy to read.

---

### 3.4 Test 3: Genre Too Long

-------------------code----------------------
it("should return 400 if genre is more than 50 characters", async () => {
  name = new Array(52).join("a"); // 51 characters
  const res = await exec();
  expect(res.status).toBe(400);
});
-------------------code----------------------

* Only the `name` is changed.
* Test clearly reflects the scenario.

---

### 3.5 Test 4: Genre Saved in Database (Happy Path)

-------------------code----------------------
it("should save the genre if it is valid", async () => {
  await exec();
  const genreInDb = await Genre.find({ name });
  expect(genreInDb.length).toBe(1);
});
-------------------code----------------------

* No need to change `token` or `name` (happy path defaults used).

---

### 3.6 Test 5: Genre Returned in Response (Happy Path)

-------------------code----------------------
it("should return the genre if it is valid", async () => {
  const res = await exec();
  expect(res.body).toHaveProperty("_id");
  expect(res.body).toHaveProperty("name", name);
});
-------------------code----------------------

* Happy path is used directly.
* Minimal repetition, clear alignment with the test description.

---

## 4. Benefits of This Refactoring

1. **Single source of truth** for the request (`exec` function).
2. **`beforeEach` initializes happy path values** (`token` and `name`).
3. **Tests only modify the relevant parameter** for each scenario.
4. Cleaner, more readable, and easier to maintain.
5. Easy to add new scenarios in the future.

---



*** 13- Testing the Auth Middleware ***

# Testing Authorization Middleware

In this lecture, we focus on testing the **authorization middleware** independently from route handlers.

---

## 1. Why Test Middleware Separately

* Currently, we have a test for unauthorized access in the genres test suite (`401` if no token).

* However, the middleware has multiple execution paths:

  1. No token provided → `401`
  2. Invalid token provided → `400`
  3. Valid token → proceed with request

* Middleware is used across many endpoints (create, update, delete genres, etc.).

* Testing it separately avoids **repeating the same logic** in multiple endpoint tests.

---

## 2. Setting Up the Test File

* Create a new test file in `integration` folder: `auth.test.js`.
* Import dependencies:

-------------------code----------------------
const request = require("supertest");
const { User } = require("../../models/user");
const { Genre } = require("../../models/genre");
let server;
-------------------code----------------------

* Use `beforeEach` and `afterEach` to start and stop the server and clean up:

-------------------code----------------------
beforeEach(() => {
  server = require("../../index");
});

afterEach(async () => {
  await Genre.deleteMany({});
  await server.close();
});
-------------------code----------------------

---

## 3. Masha’s Technique for Clean Tests

* Define the **happy path** in a function called `exec`.
* This function sends a POST request to an endpoint requiring authorization (`/api/genres`) with a valid object:

-------------------code----------------------
let token;
let name;

const exec = () => {
  return request(server)
    .post("/api/genres")
    .set("x-auth-token", token)
    .send({ name });
};
-------------------code----------------------

* `beforeEach` initializes the happy path values:

-------------------code----------------------
beforeEach(() => {
  const user = new User();
  token = user.generateAuthToken();
  name = "genre1";
});
-------------------code----------------------

* Tests only modify **one parameter** to simulate each scenario.

---

## 4. Test Cases

### 4.1 No Token Provided

-------------------code----------------------
it("should return 401 if no token is provided", async () => {
  token = ""; // simulate missing token
  const res = await exec();
  expect(res.status).toBe(401);
});
-------------------code----------------------

### 4.2 Invalid Token Provided

-------------------code----------------------
it("should return 400 if token is invalid", async () => {
  token = "a"; // invalid JWT
  const res = await exec();
  expect(res.status).toBe(400);
});
-------------------code----------------------

### 4.3 Valid Token (Happy Path)

-------------------code----------------------
it("should return 200 if token is valid", async () => {
  const res = await exec();
  expect(res.status).toBe(200);
});
-------------------code----------------------

* **Important:** After the test, clean up the database to prevent interference with other tests:

-------------------code----------------------
afterEach(async () => {
  await Genre.deleteMany({});
});
-------------------code----------------------

---

## 5. Notes

* Using this approach, tests are concise, readable, and focused.
* We **don’t need to repeat token generation or request sending** in each test.
* Happy path defines the default valid request; each test only changes what it needs to.

---

## 6. Next Step

* To test that the `req.user` property is populated correctly by the middleware, we need a **unit test**, since SuperTest does not expose the request object.

---

*** 14- Unit Testing the Auth Middleware ***
---

# Unit Testing Authorization Middleware

## 1. Why Unit Tests Are Needed

* Integration tests cannot always cover all specific functionalities.
* Every application benefits from **both unit and integration tests**, which complement each other.
* Choose the approach based on what you want to verify:

  * Unit tests → isolated behavior
  * Integration tests → multiple components working together
* The goal is to **verify the behavior** of your application.

---

## 2. Test Goal

* Test that **`request.user` is populated** with the payload of a **valid JSON Web Token**.
* This is a **unit test**, because we need to verify middleware logic in isolation.

---

## 3. Test File Structure

* Folder: `tests/unit/middleware/`
* File: `auth.test.js`

---

## 4. Setting Up the Test

1. **Import dependencies:**

-------------------code----------------------
const { User } = require("../../../models/user");
const auth = require("../../../middleware/auth");
const mongoose = require("mongoose");
-------------------code----------------------

2. **Describe block:**

-------------------code----------------------
describe("Auth Middleware", () => {
  it("should populate request.user with the payload of a valid JSON Web Token", () => {
    // Test logic here
  });
});
-------------------code----------------------

---

## 5. Mocking Request, Response, and Next

* Create a **mock request object** with a `header` method:

-------------------code----------------------
const userPayload = {
  _id: mongoose.Types.ObjectId().toHexString(),
  isAdmin: true
};

const token = new User(userPayload).generateAuthToken();

const req = {
  header: jest.fn().mockReturnValue(token)
};
-------------------code----------------------

* Mock `response` object (not used in this path):

-------------------code----------------------
const res = {};
-------------------code----------------------

* Mock `next` function:

-------------------code----------------------
const next = jest.fn();
-------------------code----------------------

---

## 6. Calling the Middleware

-------------------code----------------------
auth(req, res, next);
-------------------code----------------------

---

## 7. Assertions

* Check that `request.user` is populated correctly:

-------------------code----------------------
expect(req.user).toMatchObject(userPayload);
-------------------code----------------------

* This ensures that the decoded JWT payload is correctly assigned to `req.user`.

---

## 8. Full Test Code

-------------------code----------------------
const { User } = require("../../../models/user");
const auth = require("../../../middleware/auth");
const mongoose = require("mongoose");

describe("Auth Middleware", () => {
  it("should populate request.user with the payload of a valid JSON Web Token", () => {
    const userPayload = {
      _id: mongoose.Types.ObjectId().toHexString(),
      isAdmin: true
    };

    const token = new User(userPayload).generateAuthToken();

    const req = {
      header: jest.fn().mockReturnValue(token)
    };
    const res = {};
    const next = jest.fn();

    auth(req, res, next);

    expect(req.user).toMatchObject(userPayload);
  });
});
-------------------code----------------------

---

## 9. Notes

* JWT payload `_id` is stored as a **string**, even if the original user object had an ObjectId.
* `toHexString()` is used to match the string format.
* This is a **unit test**, so no server or database interaction is required.

---

*** 15- Code Coverage ***
---

# Using Jest to Measure Code Coverage

## 1. Purpose of Code Coverage

* When writing **unit and integration tests**, you might wonder:

  * How much of your code is actually covered?
  * What scenarios are not yet tested?
* Code coverage tools help answer these questions by analyzing which parts of your code are exercised by tests.

---

## 2. Enabling Code Coverage in Jest

1. Open `package.json`.
2. Modify the test script to include the coverage flag:

-------------------code----------------------
"scripts": {
  "test": "jest --coverage"
}
-------------------code----------------------

3. Run tests again in the terminal:

-------------------code----------------------
npm test
-------------------code----------------------

---

## 3. Viewing Coverage Reports

* Jest generates a **coverage report** in the terminal and an **HTML report**.
* The HTML report can be found at:

-------------------code----------------------
<project-folder>/coverage/lcov-report/index.html
-------------------code----------------------

* Open `index.html` in a browser for a visual report.

---

## 4. Understanding the Report

* The report includes coverage per folder and file.

* Columns include:

  * **Statements:** Number of statements executed by tests.
  * **Branches:** Execution paths tested (if/else, try/catch).
  * **Functions:** Number of functions tested.
  * **Lines:** Number of lines executed.

* **Example:** `models/genre.js` shows 100% coverage because tests for routes exercise the model, even if there is no direct test for the model itself.

---

## 5. Analyzing Execution Paths

* For `auth.js` middleware:

  * Statements: 11, 100% covered
  * Branches: 2, 100% covered
  * Functions: 1, 100% covered
  * Lines: 16

* Branches represent return statements and different paths through the function.

* JWT validation has multiple paths: valid, invalid, missing token.

---

## 6. Identifying Untested Code

* Coverage highlights untested lines in **red** in the HTML report.

* Example: A route handler line is not covered if there is no test for:

  * A valid object ID that does not exist in the database.

* Solution: Add a test for this scenario:

-------------------code----------------------js
it("should return 404 if no genre with the given id exists", async () => {
  const id = mongoose.Types.ObjectId(); // valid ObjectId
  const res = await request(server).get("/api/genres/" + id);
  expect(res.status).toBe(404);
});
-------------------code----------------------

---

## 7. Updating Coverage

* Every time you run tests with the coverage flag, Jest regenerates the report.
* Refresh the HTML report to see updated coverage.

---

## 8. Ignoring Coverage Folder in Git

* The `coverage` folder is auto-generated and should not be checked into version control.
* Add it to `.gitignore`:

-------------------code----------------------
coverage/
-------------------code----------------------

* This prevents unnecessary files from being committed to the repository.

---

### Summary

1. Use `jest --coverage` to measure how much code your tests cover.
2. Review the HTML report to identify untested areas.
3. Write additional tests to cover missing execution paths.
4. Exclude the `coverage` folder from Git since it can be regenerated.

---

*** 16- Exercise ***
---

# Exercise: Completing Route Tests in the Genre Module

## Objective

* Finish testing the remaining routes in the **Genre module**:

  1. **PUT** route (update a genre)
  2. **DELETE** route (remove a genre)

* These routes are similar to the ones already tested (`GET` and `POST`), so the techniques used previously apply here as well.

---

## PUT Route Testing

* **Purpose:** Update a genre by its ID.

* **Execution paths to test:**

  1. **Invalid ID** → should return `404`.
  2. **Valid ID, invalid payload** → should return `400`.
  3. **Valid ID, valid payload, authorized user** → should update the genre and return the updated genre.
  4. **Unauthorized access** → should return `401`.

* **Steps:**

  * Generate a valid authentication token if required.
  * Use `supertest` to send a PUT request with the genre ID.
  * Validate response status and response body.
  * Check database to ensure changes were applied.

---

## DELETE Route Testing

* **Purpose:** Delete a genre by its ID.

* **Execution paths to test:**

  1. **Invalid ID** → should return `404`.
  2. **Valid ID, authorized user** → should remove the genre and return the deleted genre.
  3. **Unauthorized access** → should return `401`.
  4. **Valid ID, user not admin** (if admin is required) → should return `403`.

* **Steps:**

  * Generate a valid authentication token (admin if required).
  * Use `supertest` to send a DELETE request with the genre ID.
  * Validate response status and response body.
  * Check the database to confirm the genre was removed.

---

## Notes

* You can reuse patterns from previous tests:

  * **`beforeEach`** for setting up tokens and test data.
  * **`afterEach`** for cleaning up the database.
  * **`execute()` helper** to handle the request and return response for cleaner tests.
* Ensure all **execution paths** are tested for each route.
* Reference the provided solution file if needed.

---

