*** 1- Introduction ***
---

# Integration Testing Overview

## 1. Unit Tests Recap

* Unit tests are simple and quick to write.
* They execute very fast.
* Best suited for functions that have zero or minimal dependency on external resources.
* Useful for testing small, isolated pieces of logic.

## 2. The Need for Integration Tests

* Real-world applications often rely on one or more external resources such as databases, file systems, or network services.
* Integration tests validate that the application code works correctly together with these external systems.
* Instead of testing components in isolation, integration tests check them as a whole.

## 3. Working With a Real Database

* Integration tests require a real database instance.
* The database is populated with test data before running tests.
* Tests interact with the application exactly as a real client would.

## 4. How Integration Tests Work

1. Prepare test data in the database.
2. Send an HTTP request to the endpoint being tested.
3. Make assertions based on either:

   * The HTTP response.
   * The changes in the database.

### Example

* Sending an HTTP POST request to create a new genre.
* After the request, the test inspects the database to ensure that the new genre has been created.

## 5. Next Steps

* In the next lecture, you will make a few adjustments to the application code to prepare it for integration testing.

---

*** 2- Preparing the App ***
---

# Preparing the Application for Integration Testing

## 1. Required Adjustments Before Writing Integration Tests

Before starting integration tests for the Vidly application, several updates are needed to ensure the environment works correctly.

---

## 2. Fixing the Index Module

* Open `index.js`.
* A previous refactor introduced an issue: on line 5, the logging module was required but not invoked.
* Ensure that the required logging module is actually called as a function.
* Without calling it, logging will not work properly.

---

## 3. Updating the NPM Test Script

* Open `package.json`.
* Modify the test script to include the `--verbose` flag.
* The verbose flag causes Jest to print additional diagnostic information in the console.
* This extra output is useful for troubleshooting when tests fail or behave unexpectedly.

---

## 4. Adjusting the Logging Module

* Open the logging module used for Winston integrations.

* Previously, MongoDB was configured as a transport for Winston, using `winston-mongodb`.

* This module currently causes the test runner to freeze when running integration tests in the terminal.

* The issue may depend on the specific version or environment and may not occur on all machines.

* To avoid blocking integration tests:

  1. Temporarily comment out the MongoDB logging configuration.
  2. Comment out the lines that add MongoDB as a Winston transport (around line 14 in the logging module).

* This allows focus on integration tests without interference from the Winston MongoDB plugin.

* The configuration can be restored later once the issue is resolved.

---

## 5. Summary of Required Changes

1. **index.js**:

   * Add parentheses to invoke the logging module function on line 5.

2. **package.json**:

   * Add the `--verbose` flag to the test command.

3. **logging module**:

   * Temporarily disable the Winston MongoDB plugin by commenting out its configuration and transport setup.

---

*** 3- Setting Up the Test Db ***
---

# Setting Up a Test Database for Integration Testing

## 1. Why We Need a Separate Test Database

* Integration tests use a real database.
* These tests add and remove documents from the database.
* Because of this behavior, the test database must be **separate** from both development and production databases.
* This prevents accidental modification or corruption of real data.

---

## 2. Adding a Database Key to Configuration

### Step 1: Modify `default.json`

* Go to the `config` folder and open `default.json`.
* Add a new key named `db`.
* Set `db` to your default MongoDB connection string.
* Ensure that no single quotes are used.

**Example structure:**

-------------------code----------------------
{
  "db": "mongodb://localhost/vidly"
}
-------------------code----------------------

---

## 3. Move the Connection String to Configuration

* Open `db.js`.
* Cut the MongoDB connection string from the file.
* Paste it into `default.json` under the new `db` key.
* This centralizes configuration and keeps environment settings clean.

---

## 4. Create a Test-Specific Configuration

### Step 1: Modify `test.json`

* Open `test.json` in the same configuration folder.
* Copy the new `db` key from `default.json`.
* Change the database name to something like `vidly_test`.

**Example:**

-------------------code----------------------
"db": "mongodb://localhost/vidly_test"
-------------------code----------------------

This ensures tests run against a separate database.

---

## 5. Updating `db.js` to Use Environment-Based Configuration

### Step 1: Load the Configuration Module

* In `db.js`, add:

  -------------------code----------------------
  const config = require('config');
  -------------------code----------------------
* Replace hardcoded connection strings with:

  -------------------code----------------------
  config.get('db')
  -------------------code----------------------

### Step 2: Improve Code Clarity

* Create a constant for the database connection:

  -------------------code----------------------
  const db = config.get('db');
  -------------------code----------------------
* Use this constant both when connecting and when logging the active database.

---

## 6. Verifying Environment-Based Database Selection

* When running the application normally, it connects to the development database.
* When running tests, it should connect to the test database.

### Manual simulation:

1. Set the environment variable:

   -------------------code----------------------
   NODE_ENV=test
   -------------------code----------------------
2. Run the app:

   -------------------code----------------------
   node index.js
   -------------------code----------------------
3. The console should show a connection to the test database.

---

## 7. Next Step

* With the test database configured, the next lecture will focus on writing the first integration test.

---


*** 4- Your First Integration Test ***

# Writing Integration Tests with Supertest

## 1. Installing Supertest

* Integration tests for Express applications require a library called **supertest**.
* Supertest allows sending HTTP requests to your endpoints programmatically, similar to Postman.
* Install it as a development dependency:
  `npm install supertest --save-dev`
* The version used in the lecture is 3.0.0.

---

## 2. Exporting the Server from index.js

* Open `index.js`.
* The `app.listen()` call returns a server object.
* Store the returned object in a variable, for example:

  -------------------code----------------------
  const server = app.listen(...)
  -------------------code----------------------
* Export the server:

  -------------------code----------------------
  module.exports = server;
  -------------------code----------------------
* This allows test files to load and control the server instance.

---

## 3. Creating the Integration Test Structure

### Step 1: Create a Test Directory

* Inside the `tests` folder, create a new folder named `integration`.
* Inside that folder, create a test file:

  -------------------code----------------------
  genres.test.js
  -------------------code----------------------

### Step 2: Create the Test Suite Structure

* Start with a top-level describe block:

  -------------------code----------------------
  describe('/api/genres', () => { ... });
  -------------------code----------------------

* Inside it, add another describe block for GET requests:

  -------------------code----------------------
  describe('GET /', () => { ... });
  -------------------code----------------------

* Inside this block, write your test:

  -------------------code----------------------
  it('should return all genres', () => { ... });
  -------------------code----------------------

---

## 4. Loading and Managing the Server in Tests

### Problem

* If the server is loaded globally, Jest will restart tests after code changes.
* This causes an error because the server is already listening on port 3000.

### Solution

* Load the server inside a `beforeEach` block.
* Close the server in an `afterEach` block.

### Example:

-------------------code----------------------
let server;

beforeEach(() => {
  server = require('../../../index');
});

afterEach(() => {
  server.close();
});
-------------------code----------------------

This ensures:

* A fresh server instance is used for each test.
* No port conflicts occur.

---

## 5. Using Supertest

### Step 1: Import Supertest

-------------------code----------------------
const request = require('supertest');
-------------------code----------------------

### Step 2: Sending a Request

* The `request()` function takes the server object.
* You can then chain request methods such as `.get()`, `.post()`, `.put()`, `.delete()`.

### Example GET request:

-------------------code----------------------
const res = await request(server).get('/api/genres');
-------------------code----------------------

* Since `await` is used, the test function must be marked as `async`.

---

## 6. Making Assertions

* A simple initial assertion is to check the response status:

  -------------------code----------------------
  expect(res.status).toBe(200);
  -------------------code----------------------

* Running the test:

  -------------------code----------------------
  npm test
  -------------------code----------------------

* If everything is set up correctly, tests will pass and the GET endpoint will be successfully called.

-------------------code----------------------
const request = require("supertest");
let server;

describe("/api/genres", () => {
  beforeEach(() => {
    server = require("../../index");
  });

  afterEach(() => {
    server.close();
  });

  describe("GET /", () => {
    it("should return all genres", async () => {
      const res = await request(server).get("/api/genres");
      expect(res.status).toBe(200);
    });
  });
});
-------------------code----------------------

---

## 7. Next Steps

* This first test only checks the status code.
* It does not verify whether the response actually contains genres.
* In the next lecture, the test database will be pre-populated with sample genres.
* The test will then be updated to confirm that the returned genres match the data stored in the database.

---

*** 5- Populating the Test Db ***
---

# Improving the Integration Test by Populating and Cleaning the Database

## 1. Purpose of Improving the Test

The earlier test only checked the HTTP status code.
To make the test meaningful, we need to:

1. Insert known genre documents into the test database.
2. Call the `/api/genres` endpoint.
3. Assert that the returned genres are exactly the ones stored.

This validates the full application stack including:

* Express routing
* Validation middleware
* MongoDB operations

---

# 2. Loading the Genre Model

At the top of the test file, import the Genre model:

-------------------code----------------------
const { Genre } = require('../../models/genre');
-------------------code----------------------

Notes:

* Use object destructuring because the module exports `{ Genre, validate }`.
* Move up two directories from the integration folder.

---

# 3. Populating the Database in the Test

Inside the test, insert sample documents:

-------------------code----------------------
await Genre.collection.insertMany([
  { name: 'genre1' },
  { name: 'genre2' }
]);
-------------------code----------------------

Important notes:

* Use real names like `genre1` and `genre2` because short values like `a` or `b` will fail validation.
* `insertMany` returns a promise, so you must use `await`.

---

# 4. Adding Assertions

### Basic count check

-------------------code----------------------
expect(res.body.length).toBe(2);
-------------------code----------------------

However, this only checks the array length.
It does not validate the content, so even `[1,2]` would pass.

---

# 5. Cleaning the Database After Each Test

### The Problem

Each test run adds two more documents to the test database.
Running tests multiple times leads to duplicates:

* First run: 2 documents
* Second run: 4 documents
* Third run: 6 documents
* etc.

This breaks repeatability.

### The Solution

Always clean the collection after each test using:

-------------------code----------------------
await Genre.deleteMany({});
-------------------code----------------------

Place this cleanup inside `afterEach`, not inside the test itself, so it always runs even if assertions fail.

Also mark `afterEach` as `async`.

---

# 6. Updating afterEach

-------------------code----------------------
afterEach(async () => {
  await Genre.deleteMany({});
  await server.close();
});
-------------------code----------------------

This ensures:

* The server shuts down cleanly.
* The database is reset.
* Tests remain isolated.

---

# 7. Ensuring Tests Are Repeatable

Before re-running, verify your test database contains no stale documents.
If needed, manually delete the `genres` collection in MongoDB Compass.

---

# 8. Improving the Assertions to Check Actual Data

A stronger test ensures the response contains the exact inserted genres.

Use the `Array.prototype.some` method:

-------------------code----------------------
expect(res.body.some(g => g.name === 'genre1')).toBeTruthy();
expect(res.body.some(g => g.name === 'genre2')).toBeTruthy();
-------------------code----------------------

This verifies:

* The returned list contains a genre named `genre1`.
* The list also contains a genre named `genre2`.

---

# 9. Final Test Behavior

After running:

* The test inserts two genres.
* Calls the `/api/genres` endpoint.
* Confirms the response includes both genres.
* Cleans the database.
* Repeats cleanly every time.

Tests must always run in isolation and must never depend on state left behind from previous runs.

---

# 10. Exercise Given in the Lecture

In `routes/genres.js`, there is a route to get a single genre by ID.
This route has two execution paths:

1. If the ID does not match any document, return status **404**.
2. If the document exists, return status **200** with the genre.

**Exercise:**
Write two integration tests for this endpoint:

1. A test that ensures a non-existing genre ID returns **404**.
2. A test that ensures a valid genre ID returns the correct genre object.

The solution will appear in the next lecture.

---


*** 6- Testing Routes with Parameters ***
---

## Integration Test: GET /api/genres/:id

### 1. Goal of the Test

Create a new test suite to verify all tests for the endpoint:

-------------------code----------------------
GET /api/genres/:id
-------------------code----------------------

The first test checks that the endpoint returns a genre when provided a valid ID.

---

## 2. Preparing the Database

For this test, only a single genre is needed. You do not need to insert multiple documents.

### Steps:

1. Create a new `Genre` instance:

-------------------code----------------------
const genre = new Genre({ name: "genre1" });
-------------------code----------------------

2. Save it to the database using:

-------------------code----------------------
await genre.save();
-------------------code----------------------

Make the test function `async` since `save()` returns a promise.

---

## 3. Calling the Endpoint

Make a GET request to the endpoint using supertest:

-------------------code----------------------
const res = await request(server)
  .get("/api/genres/" + genre._id);
-------------------code----------------------

Store the response in a variable for later assertions.

---

## 4. Writing Assertions

### Status Code

Ensure the endpoint returns HTTP status 200:

-------------------code----------------------
expect(res.status).toBe(200);
-------------------code----------------------

### Response Body

Initially, you might try:

-------------------code----------------------
expect(res.body).toMatchObject(genre);
-------------------code----------------------

But this fails because:

* Mongoose stores `_id` as an **ObjectId**.
* When retrieved from the database, `_id` becomes a **string**.
* Therefore, comparing the entire object directly will cause a mismatch.

### Correct Approach

Assert only the relevant properties manually:

-------------------code----------------------
expect(res.body).toHaveProperty("name", genre.name);
-------------------code----------------------

---

## 5. Running the Test

After updating the expectation, run the test again.
All tests should now pass.

---

## 6. Next Lecture

The next lecture will cover writing the second integration test for this endpoint.

---

*** 7- Validating ObjectIDs ***
---

## Integration Test: GET /api/genres/:id

### Test 2: Invalid ID Should Return 404

### 1. Duplicating the First Test

Start by duplicating the previous test and renaming it to reflect the new scenario:

**Test name:**
`it("should return 404 if invalid ID is passed", ...)`

---

## 2. No Need to Insert a Genre

For this test:

* There is no need to create or save a genre in the database.
* Whether the collection is empty or full makes no difference.
* Passing an invalid ID should result in a 404 regardless of the database content.

Remove the `new Genre()` and `save()` lines to make the test simpler, cleaner, and faster.

---

## 3. Calling the Endpoint with an Invalid ID

Instead of using `genre._id`, pass a blatantly invalid ID like:

-------------------code----------------------
/api/genres/1
-------------------code----------------------

This should trigger a failure because `1` is not a valid MongoDB ObjectId.

Your expectation:

-------------------code----------------------js
expect(res.status).toBe(404);
-------------------code----------------------

Checking the response message is optional since the status code is what matters for clients.

---

## 4. Test Failure and Debugging the Issue

Running the test initially results in:

* Expected: 404
* Received: 500 (internal server error)

### Reason:

The invalid ID causes Mongoose to throw a `CastError` because it attempts to convert `"1"` into an ObjectId.

This error reaches your error middleware, where Winston logs it, and the middleware returns status 500.

### Meaning:

The route handler does not handle invalid route parameters before calling `findById`.

---

## 5. Fixing the Route Handler

Before calling:

-------------------code----------------------js
Genre.findById(req.params.id)
-------------------code----------------------

you must validate the ID.

### Use Mongoose's built-in validator:

-------------------code----------------------js
if (!mongoose.Types.ObjectId.isValid(req.params.id))
  return res.status(404).send("Invalid ID");
-------------------code----------------------

This ensures:

* No cast error is thrown.
* The client receives the expected 404.

Save the file and re-run the tests.

---

## 6. Result

All tests now pass correctly.

---

## 7. Next Step

Multiple endpoints in your application fetch a single resource by ID.
Each will need the same ObjectId validation logic.

In the next lecture, this logic will be refactored into a reusable middleware function to avoid duplication.

---

*** 8- Refactoring with Confidence ***
---

# Refactoring ObjectId Validation Into a Middleware

## 1. Goal

Move the repeated ObjectId validation logic into a dedicated middleware function so it can be reused across multiple routes.

---

## 2. Creating the Middleware File

### Location:

`middleware/validateObjectId.js`

### Steps:

1. Inside the `middleware` folder, create a new file named `validateObjectId.js`.

2. Export a middleware function with the standard signature:

   -------------------code----------------------
   module.exports = function (req, res, next) { ... }
   -------------------code----------------------

3. Move the validation logic from the route handler into this middleware.

---

## 3. Middleware Implementation

### Function behavior:

* If the route parameter `id` is not a valid MongoDB ObjectId:
  Return a 404 response.
* Otherwise:
  Call `next()` to pass control to the next middleware or route handler.

### Required dependency:

Since the logic uses Mongoose validation, import Mongoose at the top.

---

## 4. Updated Middleware Code

-------------------code----------------------
const mongoose = require("mongoose");

module.exports = function (req, res, next) {
  if (!mongoose.Types.ObjectId.isValid(req.params.id))
    return res.status(404).send("Invalid ID");

  next();
};
-------------------code----------------------

---

## 5. Applying the Middleware in the Route

### Steps:

1. Import the middleware at the top of the genres route file:

   -------------------code----------------------
   const validateObjectId = require("../middleware/validateObjectId");
   -------------------code----------------------

2. Apply it in the route definition:

   -------------------code----------------------
   router.get("/:id", validateObjectId, async (req, res) => {
     const genre = await Genre.findById(req.params.id);
     if (!genre) return res.status(404).send("Genre not found");
     res.send(genre);
   });
   -------------------code----------------------

---

## 6. Verifying With Tests

Because the integration tests cover all execution paths, saving and running the test suite will confirm that the refactor did not break anything.

After running the tests, all tests pass successfully.

---

*** 9- Testing the Authorization ***

---

# Testing the Route Handler for Creating a New Genre

### Endpoint: `POST /api/genres`

---

## 1. Determining the Number of Tests

A test suite must include at least as many tests as the number of execution paths in the route handler.

### Execution paths:

1. **User not logged in**
   Should return `401 Unauthorized`.

2. **Invalid genre (fails validation)**
   Should return `400 Bad Request`.

3. **Valid genre**
   This requires two separate tests:

   * Ensure the genre is saved in the database.
   * Ensure the created genre is returned in the response body.

Total tests needed: **4**

---

## 2. Creating the Test Suite

In the test file, create a new `describe` block for:

-------------------code----------------------
POST /api/genres
-------------------code----------------------

---

## 3. First Test: Unauthorized Access

### Goal:

Verify that the endpoint returns `401` if the client is not logged in.

### Steps:

1. Use `request(server)` to call the endpoint.
2. Use `.post("/api/genres")`.
3. Send a genre object:

   -------------------code----------------------
   { name: "genre1" }
   -------------------code----------------------
4. Expect the status to be `401`.

### Important:

The test function must be `async` because the post operation returns a promise.

---

## 4. Example Test Code (First Test)

-------------------code----------------------
it("should return 401 if client is not logged in", async () => {
  const res = await request(server)
    .post("/api/genres")
    .send({ name: "genre1" });

  expect(res.status).toBe(401);
});
-------------------code----------------------

---

## 5. Result

After adding `async` and saving, running the test confirms that it passes successfully.

---

*** 10- Testing the Invalid Inputs ***

---

# Testing the POST `/api/genres` Route

## Validations, Authentication, and Error Handling

This lecture focuses on writing integration tests for the endpoint responsible for creating a new genre. The goal is to cover each execution path and confirm that both authentication and input validation behave correctly.

---

## 1. The Second Test: Invalid Genre (Less Than 5 Characters)

### Purpose

The endpoint should return a `400 Bad Request` if the client is authenticated but sends an invalid genre name. A genre is invalid when its name is fewer than five characters.

---

## 2. Preparing the Test

To simulate an authenticated request, we must generate a valid authentication token.

### Steps:

1. Import the `User` model at the top of the test file.
2. Create a new `User` instance inside the test.
3. Call `generateAuthToken()` to obtain a token.
4. Add the token to the request using `.set("x-auth-token", token)`.

---

## 3. Writing the Test

### Structure:

* Duplicate the previous test for unauthorized users.
* Modify the test so that:

  * A token is generated.
  * The token is added to the request header.
  * The genre name is shorter than five characters.
  * Expect the status code to be `400`.

### Issue Encountered

The test fails with a `500 Internal Server Error`.

### Reason

The error comes from Mongoose, not Joi.
The Joi validation schema incorrectly allowed a minimum length of three characters.
Because Joi passed the request, the invalid value reached Mongoose and triggered a schema validation error.

### Fix

Update the Joi validation schema:

* Change `.min(3)` to `.min(5)`.

After correcting this, the test passes successfully.

---

## 4. Third Test: Genre Name Longer Than 50 Characters

### Purpose

The endpoint should return `400 Bad Request` if the genre name exceeds 50 characters.

### Steps:

1. Duplicate the previous test.
2. Change the test description to indicate the length violation.
3. Replace the genre name with a dynamically generated long string.

---

## 5. Generating a Long String Dynamically

Inside Node REPL, the following observations help us generate a string of a specific length:

* `new Array(5).join("a")` gives a string of length 4.
* This means:
  Length of resulting string = array length − 1.

To generate a string with 51 characters:

* Use `new Array(52).join("a")`.

This generates a string of exactly 51 characters.

---

## 6. Second Issue: Failing Test

Again, the test fails with status `500` instead of `400`.

### Reason

In the Joi schema, only `.min(5)` was set.
Maximum length validation was missing.

### Fix

In the Joi validation function, add:

-------------------code----------------------
.max(50)
-------------------code----------------------

After updating the schema, the test passes.

---

## 7. Summary of Fixes

1. Joi minimum length updated from 3 to 5.
2. Joi maximum length added with `.max(50)`.

These ensure that invalid input is caught before reaching Mongoose.

-------------------code----------------------
it("should return 400 if genre is less than 5 characters", async () => {
      const user = new User();
      const token = user.generateAuthToken();

      const res = await request(server)
        .post("/api/genres")
        .set("x-auth-token", token)
        .send({ name: "1234" });

      expect(res.status).toBe(400);
    });

    it("should return 400 if genre is more than 50 characters", async () => {
      const user = new User();
      const token = user.generateAuthToken();

      // Generate a string of length 51
      const longName = new Array(52).join("a");

      const res = await request(server)
        .post("/api/genres")
        .set("x-auth-token", token)
        .send({ name: longName });

      expect(res.status).toBe(400);
    });
-------------------code----------------------
---



---

# Understanding How `new Array(...)` and `.join()` Behave

JavaScript's `Array` constructor behaves differently depending on how many arguments you pass and what their types are.
`join()` then acts on whatever array is produced.

Below are all cases, including your new example.

---

# 1. `new Array[1,3].join("a")`

Throws:

-------------------code----------------------
TypeError: Cannot read properties of undefined (reading 'join')
-------------------code----------------------

### Why?

* `new Array[1,3]` is parsed as `new (Array[1,3])`
* `Array[1,3]` uses the comma operator → returns the last value → `Array[3]`
* `Array[3]` is undefined
* You are trying `new undefined` → invalid

---

# 2. `new Array([1,3]).join("a")` → `'1,3'`

### Why?

* Passing a **single** argument `[1,3]`
* Creates an array with one element:

  -------------------code----------------------
  [ [1,3] ]
  -------------------code----------------------
* `join("a")` turns `[1,3]` into `"1,3"`
* Only one element → no joining occurs
  Result: `"1,3"`

---

# 3. `new Array([1,3]).join("adsad")` → `'1,3'`

Same reasoning: one element, no joining.

---

# 4. `new Array(4)` → `[ <4 empty items> ]`

* One numeric argument → creates an empty array with that length.

---

# 5. `new Array(4).join("a")` → `'aaa'`

* Four empty slots → joining produces `length - 1` separators = `3`
* Result: `"aaa"`

---

# 6. **New Example:**

## `new Array([3], [2]).join("a")` → `'3a2'`

### Why?

When you pass **multiple arguments** to the Array constructor:

-------------------code----------------------
new Array( arg1, arg2, arg3, ... )
-------------------code----------------------

JavaScript creates an array containing those arguments **directly**.

So:

-------------------code----------------------
new Array([3], [2])
-------------------code----------------------

creates:

-------------------code----------------------
[ [3], [2] ]
-------------------code----------------------

Now join them with `"a"`:

* `[3]` becomes `"3"`
* `[2]` becomes `"2"`
* Join inserts `"a"` between them

Result:

-------------------code----------------------
"3a2"
-------------------code----------------------

---

# Summary Table

| Expression                       | Created Array         | Result of `.join("a")` |
| -------------------------------- | --------------------- | ---------------------- |
| `new Array[1,3]`                 | Error                 | Error                  |
| `new Array([1,3])`               | `[ [1,3] ]`           | `"1,3"`                |
| `new Array([1,3]).join("adsad")` | `[ [1,3] ]`           | `"1,3"`                |
| `new Array(4)`                   | `[ <4 empty items> ]` | N/A                    |
| `new Array(4).join("a")`         | `[ <4 empty items> ]` | `"aaa"`                |
| `new Array([3], [2])`            | `[ [3], [2] ]`        | `"3a2"`                |

---
