*** 1- Introduction ***
**Lecture Notes: NPM (Node Package Manager)**

---

### 1. Introduction to NPM

* **NPM** stands for **Node Package Manager**.
* It is both:

  1. A **command-line tool** used for managing Node.js packages.
  2. A **registry** that hosts third-party libraries and modules.

NPM allows developers to easily add functionality to Node.js applications through reusable open-source packages.

---

### 2. NPM Registry Overview

* The official NPM registry website is **[npmjs.com](https://www.npmjs.com)**.
* It contains hundreds of thousands of free, reusable Node modules.
* As of the lecture’s recording, there were **about 475,000 packages** available.
* These packages act as **building blocks** for Node.js applications.
* Developers can also **create and publish their own Node modules** to share with others.

---

### 3. Using NPM Command-Line Tool

* NPM is automatically installed with **Node.js**.
* To check your installed NPM version:

  -------------------code----------------------
  npm -v
  -------------------code----------------------
* To check your Node.js version:

  -------------------code----------------------
  node -v
  -------------------code----------------------

  Note that **Node.js and NPM have independent version numbers** since they are developed separately.

---

### 4. Matching NPM Versions

* Your NPM version might differ from the one used in the tutorial.
* To match the instructor’s version (**5.5.1**), you can install it globally using:

  -------------------code----------------------
  npm i -g npm@5.5.1
  -------------------code----------------------

  * `i` stands for **install**.
  * `-g` means install **globally**, not limited to a single project.
  * `@5.5.1` specifies the exact version number.

---

### 5. Permissions and Installation Notes

* **Mac users:**

  * If you encounter permission errors when installing globally, use `sudo`:

    -------------------code----------------------
    sudo npm i -g npm@5.5.1
    -------------------code----------------------
  * You’ll need to enter your system password.
* **Windows users:**

  * Run the **Command Prompt as Administrator** if you get permission errors.

---

### 6. Verifying the Installation

After installation, confirm the version with:

-------------------code----------------------
npm -v
-------------------code----------------------

You should now see:

-------------------code----------------------
5.5.1
-------------------code----------------------

---

### Summary

* **NPM** is the essential tool for managing and sharing Node.js packages.
* It enables quick integration of open-source modules into your applications.
* You can both **consume** existing packages and **publish** your own.
* Always ensure your NPM version matches your project or tutorial environment to avoid compatibility issues.

---

*** 2- Package.json ***
**Lecture Notes: Creating a Node Project and `package.json`**

---

### 1. Setting Up the Project Folder

* Create a new folder named **`npm-demo`**.
* This folder will be used throughout the section for demonstrations.
* Navigate into the folder using the terminal:

  -------------------code----------------------
  cd npm-demo
  -------------------code----------------------

---

### 2. The Role of `package.json`

* The **`package.json`** file is a **JSON file** that contains metadata about your Node.js application.

* It includes important information such as:

  * **Name** of the project
  * **Version**
  * **Description**
  * **Author**
  * **License**
  * **Git repository address**
  * **Dependencies** (external packages your project uses)

* Every Node.js project should have a `package.json` file.
  It defines the configuration and dependencies of the project in a standardized way.

---

### 3. Creating `package.json`

* To create this file, run:

  -------------------code----------------------
  npm init
  -------------------code----------------------

* This command will start an **interactive setup process** that asks a series of questions:

  1. **Package name:** Default is the current folder name (`npm-demo`).
  2. **Version:** Default is `1.0.0`.
  3. **Description:** Optional project description.
  4. **Entry point:** Default is `index.js`.
  5. **Test command:** Optional (can be left blank).
  6. **Git repository:** Optional (for version control).
  7. **Keywords:** Optional (for search tags).
  8. **Author:** Your name or organization.
  9. **License:** Default is usually `ISC`.

* After you answer these questions, NPM will display a **preview** of the generated JSON object:

  -------------------code----------------------
  {
    "name": "npm-demo",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "scripts": {
      "test": "echo \"Error: no test specified\" && exit 1"
    },
    "author": "",
    "license": "ISC"
  }
  -------------------code----------------------

* Confirm by pressing **Enter**, and the file will be created.

---

### 4. Best Practice

* Always create a **`package.json`** file before adding any Node packages.
* It allows NPM to record and manage your project’s dependencies properly.
* In summary:

  * Before installing any Node modules, **run**:

    -------------------code----------------------
    npm init
    -------------------code----------------------

---

### 5. Creating `package.json` Quickly

* You can skip the interactive questions by adding the **`--yes`** (or `-y`) flag:

  -------------------code----------------------
  npm init --yes
  -------------------code----------------------
* This command creates a `package.json` file instantly using **default values**.

---

### 6. Next Step

* Once your project has a `package.json` file, you can proceed to **install Node packages** using NPM commands.
* The next part of the lecture covers **how to install a Node package**.

*** 3- Installing a Node Package ***
**Lecture Notes: Installing Third-Party Node Packages**

---

### 1. Introduction

* In this lecture, we learn how to **add third-party libraries** (or Node packages) to a Node.js application.
* Example package: **Underscore**, a popular JavaScript utility library.

---

### 2. Exploring Packages on NPM

* Visit **[npmjs.com](https://www.npmjs.com)** and search for **“underscore”**.
* You’ll find the **Underscore** package, with the latest version (in this example) being **1.8.3**.
* On the package page, you can view:

  * **Installation command**
  * **Publisher information**
  * **Latest version**
  * **GitHub repository**
  * **Official homepage:** [underscorejs.org](https://underscorejs.org)
  * **Collaborators**
  * **Download statistics** and other metadata

**Tip:**
Whenever you need a Node package, start by checking **npmjs.com** for documentation and usage details.

---

### 3. Installing a Package

* In the terminal, you can install a package using:

  -------------------code----------------------
  npm install underscore
  -------------------code----------------------

  or the shorthand:

  -------------------code----------------------
  npm i underscore
  -------------------code----------------------

#### What Happens When You Run This:

1. **NPM downloads** the specified package from the **NPM registry**.
2. It **adds the package information** to your project’s **`package.json`** under the `dependencies` section:

   -------------------code----------------------
   "dependencies": {
     "underscore": "^1.8.3"
   }
   -------------------code----------------------
3. It **creates (or updates)** a folder named **`node_modules`**, which contains all installed packages.

   * Inside `node_modules/underscore/`, you’ll find various files including its own **`package.json`** file.

---

### 4. Understanding the Dependency Structure

* The `package.json` inside each module (like Underscore) contains metadata about that package:

  * **Version** (e.g., 1.8.3)
  * **Description**
  * **Homepage**
  * **Keywords**
  * **License**, etc.

This structure allows Node.js and NPM to manage each package independently.

---

### 5. The `--save` Flag (Old Behavior)

* In older versions of NPM, you had to include the `--save` flag when installing packages:

  -------------------code----------------------
  npm install underscore --save
  -------------------code----------------------

  * Without `--save`, the dependency was not recorded in `package.json`.
* **Modern versions of NPM** automatically update `package.json` when you install a package.
  The `--save` flag is **no longer required**.

---

### 6. Summary

* To add a third-party package:

  1. Search for it on **npmjs.com** to understand its usage.
  2. Run `npm install package-name` to add it to your project.
  3. Check your **`package.json`** for updated dependencies.
  4. Verify the **`node_modules`** folder contains the installed package.

---

**Next Lecture:**
How to use installed Node packages (like Underscore) in your application code.

*** 4- Using a Package ***
**Lecture Notes: Using Third-Party Node Modules (Example: Underscore Library)**

---

### 1. Introduction

* After installing a third-party Node module (like **Underscore**), the next step is to **use it in your application**.
* In this example, we demonstrate how to load and use the **Underscore** library in a simple Node.js script.

---

### 2. Creating the Entry File

* Inside the project root (for example, `npm-demo`), create a new file:

  -------------------code----------------------
  index.js
  -------------------code----------------------

---

### 3. Loading the Module with `require()`

* In `index.js`, use the **`require()`** function to load the Underscore module:

  -------------------code----------------------
  var _ = require('underscore');
  -------------------code----------------------
* By convention, the variable name **`_`** is used to represent the Underscore library.

---

### 4. How `require()` Works

The **`require()`** function follows a sequence when resolving a module:

1. **Core Module Check**

   * It first checks if the specified module is a **core Node.js module** (like `fs`, `http`, or `path`).
   * Since there is no core module named `underscore`, it proceeds to the next step.

2. **Local File or Folder Check**

   * If the module name starts with `./`, `../`, or `/`, Node assumes it refers to a **local file or folder**.

   * Example:

     -------------------code----------------------
     require('./underscore')
     -------------------code----------------------

     would look for:

     * A file named `underscore.js` in the current folder, or
     * A folder named `underscore` containing a file `index.js`.

   * Since we do **not** have a local file or folder called `underscore`, Node continues.

3. **`node_modules` Folder Check**

   * Node finally checks inside the **`node_modules`** directory for a module named `underscore`.
   * If found, it loads that module.

This is the **module resolution process** in Node.js.

---

### 5. Using the Underscore Library

* Visit **[underscorejs.org](https://underscorejs.org)** for documentation and examples.
* The library provides many utility functions for arrays, objects, and collections.

**Example: Using the `contains` function**

-------------------code----------------------
var _ = require('underscore');

var result = _.contains([1, 2, 3], 2);
console.log(result);
-------------------code----------------------

* The `contains` method checks whether a given value exists in an array.
* It takes:

  * First argument: the array to search.
  * Second argument: the value to find.
* Returns a **boolean** (`true` or `false`).

---

### 6. Running the Script

* In the terminal, execute:

  -------------------code----------------------
  node index.js
  -------------------code----------------------
* Output:

  -------------------code----------------------
  true
  -------------------code----------------------
* This confirms that the **Underscore module** was successfully loaded and used.

---

### 7. Summary

* Use **`require()`** to load installed Node packages.
* The `require()` function resolves modules in this order:

  1. Core modules
  2. Local files/folders
  3. `node_modules` directory
* The **Underscore** library provides helpful utility methods such as `contains`.
* Running your script with `node filename.js` executes the Node application using these imported modules.

---

**Next Lecture:**
How to manage global packages and understand versioning in NPM.

*** 5- Package Dependencies ***
**Lecture Notes: Installing and Understanding Package Dependencies (Example: Mongoose)**

---

### 1. Exercise Overview

* The task: **Install a Node package called Mongoose**.
* **Mongoose** is a popular Node.js library used for working with **MongoDB** databases.
* You will learn about MongoDB later, but for now, the goal is to:

  1. Install the package.
  2. Inspect how it affects the **`package.json`** file and the **`node_modules`** folder.

---

### 2. Installing Mongoose

Run the following command in your terminal:

-------------------code----------------------
npm install mongoose
-------------------code----------------------

or using the shorthand:

-------------------code----------------------
npm i mongoose
-------------------code----------------------

* After installation:

  * The **`package.json`** file is automatically updated.
  * Under **`dependencies`**, a new entry appears:

    -------------------code----------------------json
    "dependencies": {
      "underscore": "^1.8.3",
      "mongoose": "^4.13.6"
    }
    -------------------code----------------------
  * The version shown here (4.13.6 in this example) may differ based on the latest release.

---

### 3. Exploring the `node_modules` Folder

* Open the **`node_modules`** folder after installing Mongoose.
* You will see many folders inside it — far more than just **`mongoose`** and **`underscore`**.
* Question: Why are there so many?

**Explanation:**

* These additional folders represent **dependencies of Mongoose**.
* When you install a Node package, NPM automatically installs all **packages that it depends on**.
* So while you explicitly installed **Mongoose**, it internally depends on several other packages (such as `mongodb`, `bson`, etc.), which are installed automatically.

---

### 4. How Dependency Storage Used to Work

In **older versions of NPM**, the dependency structure was **nested**:

* Each package stored its own dependencies inside its own `node_modules` folder.
* Example (old behavior):

  -------------------code----------------------
  node_modules/
  ├── underscore/
  │   └── node_modules/
  │       └── dependencyA/
  └── mongoose/
      └── node_modules/
          └── dependencyB/
  -------------------code----------------------
* This caused several problems:

  * **Duplicate packages**: The same dependency could be installed multiple times in different places.
  * **Deeply nested structures**, making it difficult to manage.
  * **Windows path length limitations**: Windows restricts the number of characters allowed in file paths, leading to errors with deeply nested folders.

---

### 5. How NPM Handles Dependencies Now (Modern Behavior)

In **newer versions of NPM**, this issue has been solved:

* All dependencies (both direct and indirect) are installed **flatly** under the root **`node_modules`** folder.

  -------------------code----------------------
  node_modules/
  ├── mongoose/
  ├── underscore/
  ├── mongodb/
  ├── bson/
  └── async/
  -------------------code----------------------
* This structure avoids duplication and long paths.

**However**, there is one important exception:

---

### 6. The Version Conflict Exception

* If two packages depend on **different versions** of the same dependency, NPM will install **multiple versions** as needed.

**Example:**

* Your application depends on:

  -------------------code----------------------
  async@1.x
  -------------------code----------------------
* Mongoose depends on:

  -------------------code----------------------
  async@2.x
  -------------------code----------------------

**Resulting structure:**

-------------------code----------------------
node_modules/
├── async/        → version 1 (used by your app)
├── mongoose/
│   └── node_modules/
│       └── async/ → version 2 (used internally by Mongoose)
-------------------code----------------------

So, the flat structure is used **as much as possible**, but NPM still installs local copies when version conflicts occur.

---

### 7. Summary

* Installing **Mongoose** adds both the package itself and all its dependencies.
* Modern NPM versions use a **flat dependency structure** to:

  * Reduce duplication.
  * Avoid deep nesting.
  * Prevent path length issues (especially on Windows).
* If two packages depend on **different versions** of the same dependency, NPM installs both versions — one globally under `node_modules` and one locally within the dependent package’s folder.

---

**Key Commands Reviewed**

-------------------code----------------------
npm install mongoose        # Install Mongoose and dependencies
npm list                    # View dependency tree
npm list --depth=0          # View only top-level dependencies
-------------------code----------------------

---

**Next Lecture:**
Understanding semantic versioning and the meaning of symbols like the caret (`^`) and tilde (`~`) in `package.json`.

*** 6- NPM Packages and Source Control ***
### Lecture Notes: Excluding `node_modules` from Git Repositories

---

#### 1. The Nature of the `node_modules` Folder

* The `node_modules` folder contains all installed third-party packages and their dependencies.
* In small projects, this folder may be light, but in real-world applications, it can grow to **hundreds of megabytes**.
* Every dependency used in the project is stored here after running `npm install`.

---

#### 2. Why We Should Not Include `node_modules` in Source Control

* Including it in a **Git repository** makes the repository unnecessarily large.
* When collaborators clone or pull the project, they would need to download hundreds of megabytes.
* The same applies when transferring the project (e.g., via email or cloud storage).
* The dependencies can always be restored from the `package.json` file, so storing them in Git is redundant.

---

#### 3. How Dependencies Are Restored

* All dependencies and their versions are listed in the **`package.json`** file.
* The **npm tool** can reinstall them automatically using:

  -------------------code----------------------
  npm install
  -------------------code----------------------
* This command reads the dependencies from `package.json` and downloads them from the **npm registry**.

**Example Process:**

1. Delete the existing `node_modules` folder.
2. Run `npm install`.
3. npm restores all dependencies as listed in `package.json`.

---

#### 4. Excluding `node_modules` from Git

**Step 1:** Initialize a Git repository

-------------------code----------------------
git init
-------------------code----------------------

**Step 2:** Check the current status

-------------------code----------------------
git status
-------------------code----------------------

You’ll see all project files, including `index.js`, `package.json`, `package-lock.json`, and `node_modules`.

**Step 3:** Create a `.gitignore` file

* In the root directory, create a new file named `.gitignore` (no filename, only the extension).
* Inside it, add:

  -------------------code----------------------
  node_modules/
  -------------------code----------------------

  The trailing slash indicates that it’s a folder.

**Step 4:** Save the file and check the status again

-------------------code----------------------
git status
-------------------code----------------------

Now, `node_modules` will no longer appear in the tracked files list.

---

#### 5. Finalizing the Git Commit

* After excluding unnecessary files, add and commit the remaining ones:

  -------------------code----------------------
  git add .
  git commit -m "First commit"
  -------------------code----------------------
* The `.gitignore` file ensures that `node_modules` and any other ignored files remain excluded from future commits.

---

#### **Summary**

* The `node_modules` folder should never be committed to Git.
* Dependencies can be restored using `npm install`.
* The `.gitignore` file prevents unnecessary or large files from being tracked.
* This keeps your repository clean, lightweight, and professional.

*** 7- Semantic Versioning ***
### Lecture Notes: Semantic Versioning and Version Control Characters in Node.js

---

#### 1. Understanding Semantic Versioning (SemVer)

**Definition:**
Semantic Versioning, or **SemVer**, is a system for managing version numbers of software packages.
A version number follows the format:

-------------------code----------------------
MAJOR.MINOR.PATCH
-------------------code----------------------

**Example:**

-------------------code----------------------
4.13.6
-------------------code----------------------

* **Major Version (4)**: Indicates breaking changes that are not backward compatible.
* **Minor Version (13)**: Indicates new features that do not break existing functionality.
* **Patch Version (6)**: Indicates bug fixes or minor improvements that do not affect compatibility.

---

#### 2. How Version Numbers Change

| Situation                              | Example Version Change | Description                                  |
| -------------------------------------- | ---------------------- | -------------------------------------------- |
| Bug fix                                | 4.13.6 → 4.13.7        | Increment the patch version for small fixes. |
| New feature without breaking changes   | 4.13.6 → 4.14.0        | Increment the minor version.                 |
| Major change that breaks compatibility | 4.13.6 → 5.0.0         | Increment the major version.                 |

This structured approach ensures clear communication of what has changed between versions.

---

#### 3. The Caret Character (`^`)

The **caret (`^`)** symbol is commonly seen in the `package.json` file, for example:

-------------------code----------------------
"mongoose": "^4.13.6"
-------------------code----------------------

**Meaning:**

* NPM is allowed to install any newer version **as long as the major version (4)** remains the same.
* In this case, versions like `4.14.0` or `4.13.7` are acceptable updates, but `5.0.0` is not.

**Example:**

* Current version: `4.13.6`
* Six months later, if version `4.15.2` is released, running `npm install` will automatically install that newer version since it’s still within the same major version.

**Equivalent syntax:**

-------------------code----------------------
"mongoose": "4.x"
-------------------code----------------------

---

#### 4. The Tilde Character (`~`)

The **tilde (`~`)** symbol works similarly but is more restrictive.
Example:

-------------------code----------------------
"underscore": "~1.8.3"
-------------------code----------------------

**Meaning:**

* Accept updates that do not change the **minor version** (1.8).
* Only patch updates are allowed, such as `1.8.4` or `1.8.5`.
* Minor version updates (like `1.9.0`) will **not** be installed automatically.

**Equivalent syntax:**

-------------------code----------------------
"underscore": "1.8.x"
-------------------code----------------------

---

#### 5. Comparison Between `^` and `~`

| Symbol | Equivalent Syntax | Allows updates to       | Example Allowed Versions | Example Blocked Versions |
| ------ | ----------------- | ----------------------- | ------------------------ | ------------------------ |
| `^`    | `4.x`             | Minor and patch updates | 4.13.7, 4.14.0           | 5.0.0                    |
| `~`    | `1.8.x`           | Patch updates only      | 1.8.4, 1.8.5             | 1.9.0                    |


---

#### 6. When to Lock Versions

While the caret and tilde characters help keep your dependencies up to date, they can occasionally cause **unintended issues**:

* A new patch or minor release may introduce breaking behavior or conflicts.

To prevent this, you can **lock the version** to an exact number by **removing** the `^` or `~`:

-------------------code----------------------
"underscore": "1.8.3"
-------------------code----------------------

This ensures that everyone using your code installs **the exact same version** of the dependency, guaranteeing consistent behavior across environments.

---

#### 7. Summary

* Semantic versioning consists of **major**, **minor**, and **patch** versions.
* The **caret (`^`)** allows updates within the same major version.
* The **tilde (`~`)** allows updates within the same minor version.
* Removing both locks the version to an exact number.
* Proper version control ensures stability and compatibility across different development environments.


*** 8- Listing the Installed Packages ***
### Lecture Notes: Checking Installed Package Versions in Node.js

#### 1. Understanding the Caret Character

* The **caret ( ^ )** in `package.json` means your project can use **any version of a dependency** as long as the **major version** remains the same.
  Example:

  * `^4.13.6` allows updates to versions like `4.14.0` or `4.15.2`
  * It blocks updates to `5.0.0` or higher.

---

#### 2. Checking the Installed Version

When you restore dependencies with `npm install`, the installed version in your `node_modules` folder might be **newer** (but still within the allowed version range).
To check the exact version installed, there are two main methods:

##### Method 1: Check `package.json` inside the module

1. Navigate to `node_modules`.
2. Open the folder of the dependency (e.g., `mongoose`).
3. Open its `package.json` file.
4. Scroll to the **version** property — this shows the exact installed version.

However, this is **tedious** if you have multiple dependencies.

---

#### 3. Viewing Installed Dependencies via Command Line

##### Method 2: Using `npm list`

* Run:

  -------------------code----------------------
  npm list
  -------------------code----------------------
* Displays a **tree structure** showing:

  * Your application’s dependencies.
  * Their sub-dependencies.
  * Each package’s version number.

Example Output:

-------------------code----------------------
myapp
├── mongoose@4.13.6
│   ├── async@2.1.5
│   └── lodash@4.17.4
└── underscore@1.8.3
-------------------code----------------------

---

#### 4. Simplifying the View

If you only want to see the **top-level dependencies** (those directly listed in your project’s `package.json`):

* Use the **depth flag**:

  -------------------code----------------------
  npm list --depth=0
  -------------------code----------------------
* This will display only:

  -------------------code----------------------
  myapp
  ├── mongoose@4.13.6
  └── underscore@1.8.3
  -------------------code----------------------

---

#### Summary

| Task                                       | Command                                    | Description                   |
| ------------------------------------------ | ------------------------------------------ | ----------------------------- |
| View all dependencies and sub-dependencies | `npm list`                                 | Shows full dependency tree    |
| View only main dependencies                | `npm list --depth=0`                       | Shows top-level dependencies  |
| Check version manually                     | Open `node_modules/<package>/package.json` | Shows exact installed version |

This makes it easy to monitor which versions of libraries are installed and ensure consistency across development environments.


*** 9- Viewing Registry Info for a Package ***
### Lecture Notes: Viewing Package Metadata with npm

**1. Learning about an npm package**

* To learn about any npm package, go to **[npmjs.com](https://www.npmjs.com)** and search for the desired package.
* Example: Search for **mongoose**.
* On the package page, you can view detailed metadata, including **version**, **description**, **dependencies**, and other properties.

---

**2. Viewing dependencies on the npm website**

* Scroll down the package page to find the **dependencies** section.
* Here, you can see all packages that the library depends on.
* Example:

  * `mongoose` depends on packages like **async** and **bson**.

---

**3. Viewing metadata using the terminal**

* You can access package metadata directly from the terminal using:

  -------------------code----------------------
  npm view mongoose
  -------------------code----------------------
* This displays the **package.json** content of the Mongoose library.
* Within the output, you can see key properties like:

  * **dependencies**
  * **versions**
  * **description**
  * **repository**
  * **license**

---

**4. Understanding dependency syntax**

* Example dependencies from the output:

  * `"async": "2.1.4"` — exact version (no caret or tilde).
  * `"bson": "~1.0.4"` — uses a tilde, meaning it allows updates for patch versions (1.0.x).
* If there’s a patch available, it may be compatible with the existing version of the package.

---

**5. Viewing specific properties**

* To view only certain properties (e.g., dependencies):

  -------------------code----------------------
  npm view mongoose dependencies
  -------------------code----------------------
* This shows only the **dependencies** object from the package.json file.

---

**6. Viewing version history**

* To list all released versions of a package:

  -------------------code----------------------
  npm view mongoose versions
  -------------------code----------------------
* This displays all published versions (e.g., version history of Mongoose).
* Useful for:

  * **Downgrading** to a stable or older version.
  * **Upgrading** to a newer version.

---

**7. Summary**

* `npm view <package>` → shows complete metadata (like package.json).
* `npm view <package> dependencies` → shows only dependencies.
* `npm view <package> versions` → shows version history.
* These commands help developers explore, analyze, and manage npm packages efficiently without visiting the website.

---

**Next Lecture:**

* How to **downgrade or upgrade** a Node package.


*** 10- Installing a Specific Version of a Package ***
### Lecture Notes: Installing Specific Versions of npm Packages

**1. Installing a specific version**

* Sometimes, you may need to install a specific version of a package instead of the latest.
* Command syntax:

  -------------------code----------------------
  npm install <package>@<version>
  -------------------code----------------------
* Example: Install Mongoose version 2.4.2

  -------------------code----------------------
  npm install mongoose@2.4.2
  -------------------code----------------------

---

**2. Verifying installation**

* After installation, your **package.json** is updated with the specific version.
* To verify the installed version in your `node_modules` folder:

  -------------------code----------------------
  npm list --depth=0
  -------------------code----------------------
* Example output will show:

  -------------------code----------------------
  mongoose@2.4.2
  -------------------code----------------------

---

**3. Practice Exercise**

* Task: Install **underscore** version **1.4.0** using the same method.
* Command example:

  -------------------code----------------------
  npm install underscore@1.4.0
  -------------------code----------------------

---

**Next Lecture:**

* How to handle **two outdated packages** and manage version updates.


*** 11- Updating Local Packages ***
### Lecture Notes: Managing Outdated npm Packages

**1. Checking for outdated packages**

* As you develop applications, dependencies may have newer versions available.
* To check outdated packages, run:

  -------------------code----------------------
  npm outdated
  -------------------code----------------------
  
* `npm` compares the installed versions with the versions available in the npm registry.


**2. Understanding npm outdated columns**

* **Current:** Version installed locally.
* **Wanted:** Latest version allowed based on the version range specified in `package.json`.
* **Latest:** Absolute latest version available on npm, regardless of the major version.

**Example:**

-------------------code----------------------
$ npm outdated
Package     Current  Wanted  Latest  Location                 Depended by
mongoose      2.4.2  2.9.10  8.19.1  node_modules/mongoose    NodeJs
underscore    1.4.0  1.13.7  1.13.7  node_modules/underscore  NodeJs
-------------------code----------------------

* Mongoose:

  * Current: 2.4.2
  * Wanted: 2.9.10 (latest version in major release 2)
  * Latest: 4.x (next major release, may contain breaking changes)
* Underscore:

  * Current: 1.4.0
  * Wanted & Latest: 1.8.3 (same major release, safe to update)

---

**3. Updating packages**

* To update packages within the same major version (minor/patch updates):

  -------------------code----------------------
  npm update
  -------------------code----------------------
* Example outcome:

  * Underscore updates to 1.8.3
  * Mongoose updates to 2.9.10 (latest in major release 2)

**Note:** Major version upgrades may introduce breaking changes and are not handled by `npm update`.

---

**4. Updating to the very latest version (including major releases)**

* Install the `npm-check-updates` (ncu) tool globally:

  -------------------code----------------------
  npm install -g npm-check-updates
  -------------------code----------------------

  * On Mac, use `sudo` if needed:

    -------------------code----------------------
    sudo npm install -g npm-check-updates
    -------------------code----------------------
* Check all outdated packages:

-------------------code----------------------
$ ncu
 Checking /Users/mahmouddabbbagh/moody/NodeJs/package.json
 [====================] 2/2 100%

 mongoose    ^2.4.2  →  ^8.19.1
 underscore  ^1.4.0  →  ^1.13.7

 Run ncu -u to upgrade package.json
  -------------------code----------------------
* Upgrade `package.json` to latest versions:

-------------------code----------------------
$ ncu -u
Upgrading /Users/mahmouddabbbagh/moody/NodeJs/package.json
[====================] 2/2 100%

 mongoose    ^2.4.2  →  ^8.19.1
 underscore  ^1.4.0  →  ^1.13.7

Run npm install to install new versions.
-------------------code----------------------
* After updating `package.json`, install the latest dependencies:

-------------------code----------------------
npm install
-------------------code----------------------

**5. Verifying updates**

* Run `npm outdated` again — there should be no output if all packages are up to date.
* Alternatively, run `ncu` to confirm all dependencies match the latest versions.

---

**6. Summary**

* `npm outdated` → check outdated packages.
* `npm update` → update minor and patch versions within the same major release.
* `npm-check-updates (ncu)` → upgrade packages to the very latest versions, including major releases.
* Always verify compatibility when upgrading major versions to avoid breaking your application.

*** 12- DevDependencies ***
### Lecture Notes: Development Dependencies in npm

**1. Application dependencies vs. development dependencies**

* **Application dependencies**: Required for the application to function in production.

  * Examples: `mongoose`, `underscore`
* **Development dependencies**: Only used during development, not needed in production.

  * Examples:

    * Unit testing tools
    * Static analysis tools
    * Code bundlers

---

**2. Installing a development dependency**

* Example: Install **JSHint**, a static analysis tool for JavaScript:

  -------------------code----------------------
  npm install jshint --save-dev
  -------------------code----------------------
* The flag `--save-dev` marks the package as a **development dependency**.

---

**3. package.json structure**

* After installation, `jshint` appears under the `devDependencies` property in `package.json`:

  -------------------code----------------------
  "devDependencies": {
    "jshint": "^version"
  }
  -------------------code----------------------
* This tells Node that this dependency is only for development and should not be included in production.

---

**4. Node modules folder**

* All dependencies, whether application or development, are stored in `node_modules`.
* The distinction is **only reflected in `package.json`**; physically, they exist in the same folder.

---

**5. Summary**

* Use `--save-dev` for development-only packages.
* Application dependencies go under `dependencies` and are required in production.
* Development dependencies go under `devDependencies` and are used only during development.
* Both types are stored in `node_modules` but are managed differently in `package.json`.

*** 13- Uninstalling a Package ***
### Lecture Notes: Uninstalling npm Packages

**1. When to uninstall a package**

* In real-world projects, you may no longer need a package that was previously installed.
* Uninstalling removes it from your project to keep dependencies clean and reduce bloat.

---

**2. How to uninstall a package**

* Command syntax:

  -------------------code----------------------
  npm uninstall <package-name>
  -------------------code----------------------
* Shortcut:

  -------------------code----------------------
  npm un <package-name>
  -------------------code----------------------
* Example: Uninstall Mongoose

  -------------------code----------------------
  npm uninstall mongoose
  -------------------code----------------------

---

**3. Effects of uninstalling**

* The package is removed from the **dependencies** section in `package.json`.
* The package is also removed from the **node_modules** folder.

---

**4. Summary**

* Use `npm uninstall` (or `npm un`) to remove unnecessary packages.
* Always check `package.json` and `node_modules` to verify that the package has been successfully removed.

*** 14- Working with Global Packages ***
### Lecture Notes: Local vs. Global npm Packages

**1. Local packages**

* Installed in a specific project folder.
* Examples: `underscore`, `jshint`
* Only accessible within that project.

---

**2. Global packages**

* Not tied to a specific project or folder.
* Accessible from anywhere in the system via the command line.
* Examples:

  * `npm` (command-line tool itself)
  * `Angular CLI` (used to create Angular projects)

---

**3. Installing global packages**

* Command syntax:

  -------------------code----------------------
  npm install -g <package-name>
  -------------------code----------------------
* Example:

  -------------------code----------------------
  npm install -g npm
  -------------------code----------------------
* On macOS, you may need `sudo` if permissions are not configured properly:

  -------------------code----------------------
  sudo npm install -g <package-name>
  -------------------code----------------------
* Removing the version specifier upgrades the package to the latest version.

---

**4. Managing global packages**

* **Check outdated global packages:**

  -------------------code----------------------
  npm -g outdated
  -------------------code----------------------

  * Example:

    * Angular CLI: current version 1.3.2, latest version 1.6.0
* **Uninstall global packages:**

  -------------------code----------------------
  npm uninstall -g <package-name>
  -------------------code----------------------

---

**5. Summary**

* Local packages: project-specific, stored in `node_modules`.
* Global packages: system-wide, accessible from any folder.
* All npm commands like `outdated`, `install`, and `uninstall` work with the `-g` flag for global packages.

---

**Next Lecture:**

* How to **publish your own packages** to the npm registry.
