*** 1- What is Test-driven Development ***
### Test-Driven Development (TDD)

#### 1. Definition

Test-driven development (TDD), also called *test first*, is a software development approach in which tests are written **before** the application (production) code.

---

### 2. The TDD Workflow

TDD consists of a simple repetitive cycle:

1. **Write a failing test**

   * The test must fail initially because no application code exists to satisfy it.

2. **Write the simplest code to make the test pass**

   * Implement only the minimal logic required.
   * Avoid over-engineering, premature class design, or unnecessary complexity.

3. **Refactor the code**

   * Clean up the implementation while keeping all tests passing.

These three steps are repeated until the entire feature is implemented.

---

### 3. Why Use TDD?

#### a. Immediate Testability

Your code is testable from the first line since tests come before implementation.

#### b. High Test Coverage

Every line of production code exists only because a test required it.
This leads to complete test coverage, making refactoring and deployment safer.

#### c. Reduced Complexity

Starting with tests prevents over-engineering.
If all tests pass and the system meets all requirements, additional code is unnecessary.
New requirements start with new failing tests.

---

### 4. TDD vs. Code-First Approach

#### TDD (Test First)

* Tests drive the design and implementation.
* Offers strong safety through full test coverage.
* Often leads to simpler and cleaner designs.

#### Code First

* The developer writes application code first, then tests afterward.
* This is how most beginners and many teams naturally work.

---

### 5. Which Approach Is Better?

* **In theory:** TDD provides better quality, better design, and safer refactoring.
* **In practice:** TDD can grow complex and sometimes slow down development.
* When TDD becomes impractical, switching to the code-first approach is reasonable.

---

*** 2- Implementing the Returns ***
---

### Implementing a New Feature with Test-Driven Development

**Goal:** Add the ability to return a movie.

---

### 1. Rental Model Overview

The `Rental` model has the following properties:

* `customer`
* `movie`
* `dateOut`
* `dateReturned`
* `rentalFee`

The last two properties (`dateReturned` and `rentalFee`) are initially undefined.
When a customer returns a movie, the system must:

1. Set the return date.
2. Calculate the rental fee.

---

### 2. API Design Considerations

#### Existing behavior

The current `/api/rentals` endpoint supports only creating a new rental through a POST request.

#### Incorrect approach

One idea might be to add an update route to modify an existing rental.
However, this approach is flawed:

* The client should **not** set `dateReturned` or `rentalFee`.
  If allowed, a client could send incorrect or manipulated values, such as a rental fee of zero.
* The client should also not modify `dateOut`, the `customer`, or other protected fields.

These values must be calculated and set **only** on the server.

---

### 3. Correct API Approach

Create a new endpoint dedicated to processing movie returns.

**Endpoint:**
`POST /api/returns`

**Request Body:**

* `customerId`
* `movieId`

**Server Responsibilities:**

1. Look up the rental associated with the given `customerId` and `movieId`.
2. Set the `dateReturned` to the current date/time.
3. Calculate the `rentalFee`.
4. Save the updated rental and return a response.

This endpoint becomes the contract exposed to clients for returning movies.

---

### 4. Preparing for Test-Driven Development

Now that the endpoint design and behavior are defined, we can begin writing test cases.
The tests will specify how this endpoint should behave before writing the actual implementation.

---

*** 3- Test Cases ***

---

### Brainstorming Test Cases for the Returns Endpoint

Before writing the implementation, we first identify all the test cases for the `POST /api/returns` endpoint.
This list may evolve as the feature becomes clearer.

---

## 1. Negative Test Cases

These tests ensure the endpoint correctly handles invalid or incomplete requests.

### a. Authentication

* **Return 401** if the client is not logged in.
  Only authenticated users should be able to call this endpoint.

### b. Missing Input

* **Return 400** if `customerId` is not provided.
* **Return 400** if `movieId` is not provided.

### c. Rental Not Found

* **Return 404** if there is no rental matching the provided `customerId` and `movieId`.

### d. Rental Already Processed

* **Return 400** if the rental exists but has already been returned
  (meaning `dateReturned` is already set).

---

## 2. Positive Test Cases

These tests cover correct behavior when the request is valid.

### a. Valid Request

* **Return 200** for a successful return operation.

### b. Set Return Date

* The endpoint should set `dateReturned` to the current date and time.

### c. Calculate Rental Fee

* The rental fee should be computed based on the rental duration and movie daily rental rate.

### d. Update Movie Inventory

* The movie’s stock count should be increased by one.

### e. Response Body

* The endpoint should return the updated rental object, including:

  * `dateOut`
  * `dateReturned`
  * `rentalFee`
  * `customer`
  * `movie`
  * Any other relevant properties

---

### Summary

These test cases define how the `/api/returns` endpoint should behave under different conditions.
In the next steps, each test will be implemented using the TDD cycle.

---

*** 4- Populating the Database ***
---

### Setting Up the Test Environment for the Returns Endpoint

We begin by creating a new integration test file for the returns feature.

---

## 1. Creating the Test File

* Navigate to the `tests/integration` folder.
* Add a new file named `returns.test.js`.
* Start with a test suite titled `/api/returns`.

---

## 2. Preparing the Test Suite Structure

Just like other integration tests:

* Load the server in `beforeEach`.
* Close the server in `afterEach`.
* Prepare necessary database records before each test.
* Clean up after each test.

To save time, copy the `beforeEach` and `afterEach` code from `genres.test.js` and modify as needed.

---

## 3. Importing Required Modules

Inside `returns.test.js`:

* Define `let server;` at the top.
* Import the `Rental` model from `models/rental`.
* Import `mongoose` to create object IDs.

---

## 4. Creating the Rental Object in beforeEach

Inside `beforeEach`:

1. **Create a new rental instance**:

   * The `rental` object must include:

     * `customer`
     * `movie`
   * `dateOut` is automatically set by Mongoose because it has a default value.

2. **Setting up the customer**:

   The customer subdocument requires:

   * `name` (minimum 5 characters)
   * `isGold` (has a default value, so no need to set manually)
   * `phone`

   Also, an `_id` must be provided because it will be used during tests.

   Steps:

   * Create `customerId = mongoose.Types.ObjectId()`.
   * Assign it to both:

     * The rental’s `customer._id`
     * A variable for later use in requests.

3. **Setting up the movie**:

   Similar to the customer:

   * Create `movieId = mongoose.Types.ObjectId()`.
   * Assign to `movie._id`.
   * Set `title` to a value of at least 5 characters.
   * Set `dailyRentalRate`, for example, to 2.

4. **Save the rental** to the database using `await rental.save()`.

Because the rental object will be reused across tests, declare it as a variable outside of `beforeEach`.

---

## 5. Cleaning Up After Each Test

Inside `afterEach`:

* Close the server.
* Remove all rentals with `await Rental.remove({})`.

---

## 6. Verifying That Setup Works

Before writing production code, ensure that test setup is correct.

Add a simple test:

* Title: `it("should work", ...)`
* In the test:

  * Use `Rental.findById(rental._id)` to fetch the rental.
  * Expect the result to be non-null.

Remember to mark both `beforeEach` and the test function as `async`.

Example corrections:

* Add `async` to `beforeEach`.
* Add `async` to the test function.

Once corrected:

* Run tests in the terminal.
* The test should pass, confirming that setup code works properly.

---

### Conclusion

The environment for the returns endpoint tests is now correctly set up.
In the next step, the first real test case will be implemented.


*** 5- Testing the Authorization ***
---

# Implementing the First Test Case (Unauthorized Client)

## Introduction

We are now ready to implement the first test case for the `/api/returns` endpoint.
The goal is to enforce that **only authenticated users** can call this endpoint. If the client is not logged in, the server should return **401 Unauthorized**.

This first example demonstrates the TDD workflow. For following test cases, you should actively attempt the exercise before watching the solution.

---

# 1. Writing the First Test Case

### Test Description

* Test name:
  **"should return 401 if client is not logged in"**
* Purpose:
  Ensure the endpoint rejects unauthenticated users.

### Steps

1. Modify the test description.
2. Remove temporary test code.
3. Import `supertest` using `const request = require("supertest");`
4. Use `request(server).post("/api/returns")` to call the endpoint.
5. Provide a valid request body:

   * `customerId`
   * `movieId`
6. Await the response.
7. Expect the status code to be `401`.

Using shorthand object syntax keeps the body clean and concise.

---

# 2. Running the Test for the First Time

Since the endpoint does not exist yet:

* Express returns **404 Not Found**.
* This causes the test to fail.
* This is expected.

Following TDD, we now write the simplest production code that makes this test pass.

---

# 3. Implementing the Endpoint

### Step 1: Create the Route

Inside `routes/`, create a new file:

-------------------code----------------------
returns.js
-------------------code----------------------

Load Express, create a router, and define a POST route. Start by copying the basic structure from the genres route file.

### Step 2: Export the Router

Use:

-------------------code----------------------
module.exports = router;
-------------------code----------------------

### Step 3: Register the Route in the Application

Open the `startup/routes.js` file and:

* Require the new returns module.
* Add:

  -------------------code----------------------
  app.use("/api/returns", returns);
  -------------------code----------------------

This connects the new endpoint to the application.

---

# 4. Minimal Production Code to Pass the Test

With TDD, the goal is to write **the simplest possible code** that makes the test pass.

Inside `returns.js`, modify the route handler to:

-------------------code----------------------
res.status(401).send();
-------------------code----------------------

There is no need yet to handle authentication properly.
TDD will force us to improve this later when other tests fail.

---

# 5. Fixing the "Address in Use" Error

When running tests, an error occurs:

**"Listen EADDRINUSE: address already in use"**

Cause:

* The server is not fully closed between tests.
* `server.close()` returns a promise.

Solution:

* Add `await` before `server.close()` in `afterEach` inside:

  * `genres.test.js`
  * `returns.test.js`
  * Any test suite using the server

This ensures the port is properly released before starting the next test.

---

# 6. Final Result

After applying all fixes:

* All tests pass.
* The first TDD cycle is complete.
* We built the simplest possible implementation.

---

# 7. Exercise (For You)

The next test case to implement:

**Return 400 if customerId is not provided**

Instructions:

1. Write the failing test.
2. Write the minimal production code to make both tests pass.
3. Only write the amount of logic needed for these two tests.

You will see the solution in the next lecture.

---

*** 6- Testing the Input ***
---

# Lecture Notes: Validating Input in Test-Driven Development (TDD)

## 1. Second Test Case: Missing Customer ID

**Goal:** Ensure the API returns `400 Bad Request` if `customerId` is not provided.

### Steps in the Test

1. Duplicate the previous test and rename it to
   **"should return 400 if customer ID is not provided"**.
2. The test requires an authentication token:

   * Load the `User` class.
   * Create a new `User` instance.
   * Generate an authentication token using `generateAuthToken()`.
3. Attach the token to the request header:

   * `x-auth-token: token`.
4. Modify the request body by removing `customerId`.
5. Expect the response status to be **400**.

### Observed Test Failure

* Expected: `400`
* Received: `401`
  This happens because the route handler always returns `401` for invalid input.

### Fix in Production Code

Add the simplest possible input validation:

-------------------code----------------------
if (!req.body.customerId)
  return res.status(400).send("Customer ID not provided");
-------------------code----------------------

Refactoring to use Joi or other validation libraries can be done later once the test suite is complete.

### Result

After fixing, the test passes.

---

## 2. Third Test Case: Missing Movie ID

**Goal:** Ensure the API returns `400 Bad Request` when `movieId` is missing.

### Steps in the Test

1. Duplicate the previous test and rename it to
   **"should return 400 if movie ID is not provided"**.
2. Keep `customerId` but remove `movieId` from the request body.
3. Expect the response to be **400**.

### Observed Test Failure

* Expected: `400`
* Received: `401`

### Fix in Production Code

Duplicate the earlier validation and adjust it:

-------------------code----------------------
if (!req.body.movieId)
  return res.status(400).send("Movie ID not provided");
-------------------code----------------------

### Result

All tests pass successfully.

---

*** 7- Refactoring Tests ***
---

# Lecture Notes: Refactoring Tests in TDD

## 1. Importance of Tests

* Tests are **first-class citizens** in your codebase.
* They are **as important as production code**.
* Always **refactor tests** to make them cleaner and reduce duplication.

---

## 2. Problem with Current Tests

* Several lines are repeated in multiple tests:

  * Generating authentication tokens.
  * Sending requests with `supertest`.
* This duplication makes tests harder to maintain.

---

## 3. Refactoring Strategy: Masha’s Technique

1. Define the **happy path** for a request.
2. For each test, **change only one parameter** to simulate an edge case.
3. Use a helper function (`exec`) to encapsulate request logic:

   * Sends the request.
   * Accepts parameters like `customerId`, `movieId`, and `token`.
   * Returns the response.

---

## 4. Implementing the Happy Path

* At the top of the test suite, define the `exec` function:

-------------------code----------------------
let token;
let customerId;
let movieId;

const exec = () => {
  return request(server)
    .post("/api/returns")
    .set("x-auth-token", token)
    .send({ customerId, movieId });
};
-------------------code----------------------

* `beforeEach` sets **valid values** for happy path:

-------------------code----------------------
beforeEach(async () => {
  server = require("../../index");

  customerId = mongoose.Types.ObjectId();
  movieId = mongoose.Types.ObjectId();

  token = new User().generateAuthToken();

  rental = new Rental({
    customer: { _id: customerId, name: "12345", phone: "12345" },
    movie: { _id: movieId, title: "12345", dailyRentalRate: 2 },
  });
  await rental.save();
});
-------------------code----------------------

---

## 5. Updating Tests

* Replace repeated request logic with calls to `exec()`:

  * **Authorization test:** remove token
  * **Missing customer ID test:** set `customerId = ""` or delete from payload
  * **Missing movie ID test:** set `movieId = ""` or delete from payload

### Example:

-------------------code----------------------
it("should return 401 if client is not logged in", async () => {
  token = "";
  const res = await exec();
  expect(res.status).toBe(401);
});

it("should return 400 if customer ID is not provided", async () => {
  customerId = "";
  const res = await exec();
  expect(res.status).toBe(400);
});

it("should return 400 if movie ID is not provided", async () => {
  movieId = "";
  const res = await exec();
  expect(res.status).toBe(400);
});
-------------------code----------------------

* Optional approach: define a `payload` object and modify it per test:

-------------------code----------------------
let payload = { customerId, movieId };
delete payload.customerId; // For missing customer ID test
-------------------code----------------------

---

## 6. Next Steps

* Implement further tests such as:

  * **Return 404** if no rental is found for the given customer and movie combination.
* This approach keeps tests **DRY**, readable, and easier to maintain.

---

# Refactored Test Code

-------------------code----------------------
const request = require("supertest");
const mongoose = require("mongoose");
const { Rental } = require("../../models/rental");
const { User } = require("../../models/user");

let server;
let rental;
let customerId;
let movieId;
let token;

describe("/api/returns", () => {
  const exec = () => {
    return request(server)
      .post("/api/returns")
      .set("x-auth-token", token)
      .send({ customerId, movieId });
  };

  beforeEach(async () => {
    server = require("../../index");

    customerId = mongoose.Types.ObjectId();
    movieId = mongoose.Types.ObjectId();

    token = new User().generateAuthToken();

    rental = new Rental({
      customer: { _id: customerId, name: "12345", phone: "12345" },
      movie: { _id: movieId, title: "12345", dailyRentalRate: 2 },
    });

    await rental.save();
  });

  afterEach(async () => {
    await server.close();
    await Rental.deleteMany({});
  });

  it("should return 401 if client is not logged in", async () => {
    token = "";
    const res = await exec();
    expect(res.status).toBe(401);
  });

  it("should return 400 if customer ID is not provided", async () => {
    customerId = "";
    const res = await exec();
    expect(res.status).toBe(400);
  });

  it("should return 400 if movie ID is not provided", async () => {
    movieId = "";
    const res = await exec();
    expect(res.status).toBe(400);
  });

  // Next exercise: implement test for 404 if no rental found
});
-------------------code----------------------

---

*** 8- Looking Up an Object ***
---

# Lecture Notes: Handling “Rental Not Found” in TDD

## 1. Goal

* Implement a test to return **404** if no rental exists for a given customer and movie combination.

---

## 2. Writing the Test

### Steps:

1. Duplicate the last test.
2. Modify it to describe the new behavior:

   * **"should return 404 if no rental found for the customer/movie combination"**
3. Simulate the edge case:

   * Delete the rental created in `beforeEach`.
   * Use `rental.remove({})` or `Rental.deleteMany({})` to clean the collection.
4. Execute the request with the same `exec()` function.
5. Assert that the response status is **404**.

**Example Test:**

-------------------code----------------------
it("should return 404 if no rental found for the customer/movie combination", async () => {
  await Rental.deleteMany({}); // remove all rentals

  const res = await exec();

  expect(res.status).toBe(404);
});
-------------------code----------------------

* Running the test at this point will fail (expected 404, got 401).

---

## 3. Updating Production Code

### Logic:

1. Load the `Rental` model at the top:

-------------------code----------------------
const { Rental } = require("../models/rental");
-------------------code----------------------

2. In the route handler:

   * Find the rental for the given `customerId` and `movieId`.
   * Use `Rental.findOne()` for a single match.
   * Query object example:

-------------------code----------------------
const rental = await Rental.findOne({
  "customer._id": req.body.customerId,
  "movie._id": req.body.movieId,
});
-------------------code----------------------

* Dot notation is used to access properties in embedded documents.

3. If no rental is found:

-------------------code----------------------
if (!rental) return res.status(404).send("Rental not found");
-------------------code----------------------

* Save the changes.
* Running tests now should pass.

---

## 4. Next Exercise (Preview)

* Write a test to return **400** if a rental is already processed.

  * A rental is considered processed if `dateReturned` is already set.
  * This ensures a rental cannot be returned twice.
* This will follow the same pattern:

  * Update `exec()` to simulate the edge case.
  * Assert the correct status code.

---

*** 9- Testing if Rental Processed  ***
---

### Lecture Topic: TDD – Handling Return Already Processed Scenario

**1. Objective:**

* Test case: Return **400** if a return is already processed.

**2. Steps to Simulate the Test Case:**

1. Duplicate the previous test.
2. Retrieve the rental object.
3. Set the `dateReturned` field to the current date and time.
4. Save the rental object (use `await`).
5. Sign the request.
6. Assert that the response status is **400**.

**3. Observations in Terminal:**

* Initial failing test returned **401** (expected as user not authenticated).
* After adding rental check logic, test passes with **400**.

**4. Implementation Logic in Route Handler:**

* Check if the rental object exists.
* If `rental.dateReturned` is already set:
-------------------code----------------------
if (rental.dateReturned)
    return res.status(400).send("Rental is already processed");
-------------------code----------------------

  * Return `res.status(400).send("Return already processed")`.
* Save changes.

**5. TDD Best Practices Demonstrated:**

* Keep tests clean and focused (3–4 lines per test).
* Refactor code efficiently.
* Change **one parameter per test** to simulate a single test case.
* Follow **step-by-step approach**: write test → make it pass → move to next test.
-------------------code----------------------
it("should return 400 if a return is already processed", async () => {
    rental.dateReturned = new Date();
    await rental.save();

    const res = await exec();

    expect(res.status).toBe(400);
  });
-------------------code----------------------

**6. Next Exercise:**

* Implement the test case for **Return 200** when a valid request is received.

---

*** 10- Testing the Valid Request ***
---

### Lecture Topic: TDD – Handling Valid Return Requests

**1. Objective:**

* Test case: Return **200** if we have a valid request.

**2. Steps to Implement the Test Case:**

1. Duplicate the last test.
2. Set the test title: `should return 200 if we have a valid request`.
3. Remove unnecessary lines from the previous test.
4. Send a valid request and assert that the response status is **200**.

**3. Observations in Terminal:**

* Initial failing test appears (expected, since route logic is not complete).

**4. Simplest Route Handler Logic to Pass Test:**

1. Check if the rental is already processed.
2. If not, it is a valid request → return:

   -------------------code----------------------
   res.status(200).send();
   -------------------code----------------------

   * **Important:** Always call `send()` to actually return a response.

**5. Handling Authorization:**

* After implementing the 200 response, the first test for authentication fails (should return **401** for unauthenticated clients).
* Fix: Import and apply authorization middleware:

  -------------------code----------------------
  const auth = require('../middleware/auth');
  router.post('/', auth, async (req, res) => { ... });
  -------------------code----------------------
* After adding middleware, all tests should pass.

**6. Next Exercise:**

* When processing a return, ensure that the `dateReturned` is **set on the rental object**.
* Solution will be provided next.

---

*** 11- Testing the ReturnDate ***
---

# Test-Driven Development Lecture Notes

### Setting the Return Date and Preparing the Next Exercise

## 1. Duplicating the Test

* Create a new test with the title:
  **"it should set the return date if input is valid"**.
* In this test, send a valid request to the return endpoint.

## 2. Reloading the Rental Document

* After executing the request, load the updated rental from the database:

  * Use `Rental.findById(rental._id)` and store the result in `rentalInDb`.
  * Do not rely on the in-memory `rental` object because the database has been modified elsewhere.

## 3. Initial Assertion (General)

* Assert that `rentalInDb.dateReturned` is defined.
* This is intentionally general, because the property could be set to an incorrect value such as a boolean or a number.
-------------------code----------------------
it("should return returnDate if input is valid", async () => {
    const res = await exec();

    const rentalInDb = await Rental.findById(rental._id);
    const diff = new Date() - rentalInDb.dateReturned;
    expect(diff).toBeLessThan(10 * 1000);
  });
-------------------code----------------------
## 4. Running the Test

* Save and run the test; it will fail as expected.

## 5. Writing Minimal Production Code

* In the route handler, set:

  -------------------code----------------------
  rental.dateReturned = 1;
  await rental.save();
  -------------------code----------------------
* Run the test again; it will pass.
* This demonstrates why the original assertion is too general.

## 6. Improving the Assertion

* In production, `dateReturned` must be set to the current time.
* In tests, you cannot assert the exact timestamp because the test time and production time will differ.
* Proper approach:

  * Compute `Date.now() - rentalInDb.dateReturned`.
  * Assert that the difference is less than a threshold, such as 10 seconds.
  * This covers worst-case situations where the test execution is slow.

## 7. Updating Production Code

* Replace the incorrect placeholder:

  -------------------code----------------------
  rental.dateReturned = new Date();
  -------------------code----------------------
* Save and run tests again; all tests should pass.

---

# Next Exercise

Write a new test case for the next requirement:

### **Requirement**

When processing a valid return request:

* The system must calculate and set the **rental fee**.

### **Definition**

`rentalFee = numberOfDays * movie.dailyRentalRate`

Where:

* `numberOfDays` = difference between `dateOut` and `dateReturned` (rounded appropriately).
* `dailyRentalRate` comes from the referenced movie document.

### **Your task**

1. Write the test for this behavior.
2. Run the test, confirm that it fails.
3. Implement production code to make the test pass.

*** 12- Testing the RentalFee ***

---

# Test-Driven Development Lecture Notes

### Setting the Rental Fee Using Moment and Preparing the Next Exercise

## 1. Duplicating the Test

* Create a new test titled:
  **"it should set the rental fee if input is valid"**.

## 2. The Problem with Default `dateOut`

* When the rental is first saved in `beforeEach`, Mongoose assigns `dateOut` as the current timestamp.
* For this test, you must simulate a situation where the movie has been out for at least one day.
* Setting it to a few seconds ago is not sufficient.

## 3. Modifying `dateOut`

* Before calling the execution function, update the rental document manually so that `dateOut` is in the past.
* The easiest way to work with dates is using **Moment.js**.

### Steps:

1. Install `moment`:

   * It can be installed as a development dependency or a production dependency.
   * In this context, it is installed as a production dependency because the production code will also use it.
2. Import moment at the top of the test file:

   -------------------code----------------------
   const moment = require('moment');
   -------------------code----------------------
3. In the test:

   * Call `moment()` to get the current datetime.
   * Call `.add(-7, 'days')` to shift the time seven days back.
   * Convert it to a JavaScript Date using `.toDate()`.
   * Assign it to `rental.dateOut`, then save and await:

     -------------------code----------------------
     rental.dateOut = moment().add(-7, 'days').toDate();
     await rental.save();
     -------------------code----------------------

## 4. Setting the Daily Rental Rate

* Set `movie.dailyRentalRate = 2` and save it.
* This ensures the rental fee calculation has realistic values.

## 5. Execute the Request

* Call `exec()` to simulate returning the movie.

## 6. Reload Rental From Database

* Always reload the rental record using:

  -------------------code----------------------
  const rentalInDb = await Rental.findById(rental._id);
  -------------------code----------------------

## 7. Assertion

* You can start with a generic assertion like:

  -------------------code----------------------
  expect(rentalInDb.rentalFee).toBeDefined();
  -------------------code----------------------
* Or make it specific:

  * Since the movie was out for seven days and the daily rate is two:

  -------------------code----------------------
  expect(rentalInDb.rentalFee).toBe(14);
  -------------------code----------------------

## 8. Writing Production Code

* In the return route handler:

  1. Import moment:

     -------------------code----------------------
     const moment = require('moment');
     -------------------code----------------------
  2. After setting `dateReturned`, calculate rental days:

     -------------------code----------------------
     const rentalDays = moment().diff(rental.dateOut, 'days');
     -------------------code----------------------
  3. Set rental fee:

     -------------------code----------------------
     rental.rentalFee = rentalDays * rental.movie.dailyRentalRate;
     -------------------code----------------------

## 9. Verify

* After saving, run tests again.
* All tests should pass.


*** 13- Testing the Movie Stock ***
---

# Test-Driven Development Lecture Notes

### Increasing Movie Stock When Processing a Return

## 1. Preparing the Movie in `beforeEach`

* Before sending the request, the movie must already exist in the database.
* This allows the test to verify that the movie stock increases by one.

### Steps:

1. Define a `movie` variable at the top of the test file.
2. In `beforeEach`, initialize it:

   * Set `_id` to the same `movieId` used in the rental.
   * Set `title` to a placeholder value.
   * Set `dailyRentalRate` to `2`.
   * Set `genre` with a required name field.
   * Set `numberInStock` to `10`.
3. Save the movie and await the operation.

---

## 2. Writing the Test

* Duplicate the previous test and rename it:
  **"it should increase the movie stock"**.
* Remove any irrelevant setup lines from the duplicated test.
* Import the Movie model at the top of the test file.
* Replace rental lookup with a movie lookup:

-------------------code----------------------
const movieInDb = await Movie.findById(movieId);
-------------------code----------------------

* Assert that `numberInStock` has increased by one:

  -------------------code----------------------
  expect(movieInDb.numberInStock).toBe(11);
  -------------------code----------------------

### Alternative Assertion

To avoid a magic number inside the expectation:

-------------------code----------------------
expect(movieInDb.numberInStock).toBe(movie.numberInStock + 1);
-------------------code----------------------

This makes the intention clearer.

---

## 3. Running the Test

* Save and run the test suite.
* The test should fail, which is the correct behavior at this stage.

---

## 4. Implementing the Production Code

* Open the return route handler.
* Import the Movie model.
* After saving the rental changes, update the movie stock.

### Using the update-first approach:

-------------------code----------------------
await Movie.update(
  { _id: rental.movie._id },
  {
    $inc: { numberInStock: 1 }
  }
);
-------------------code----------------------

* The important detail: this operation returns a promise.
  You must use `await` or the test will read the old value before the update completes.

---

## 5. Fixing the Bug

* If the test shows that stock remains `10`, it means the update was not awaited.
* Adding `await` ensures the stock is incremented before returning the response.

---

## 6. Cleaning Up

* After adding movies in `beforeEach`, ensure you delete them in `afterEach`:

  -------------------code----------------------
  await Movie.remove({});
  -------------------code----------------------

---

## 7. Next Exercise

**Implement the last test case:**
When a return is processed successfully, the API should return the rental object in the body of the response.

*** 14- Testing the Response ***
---

# Notes: Returning the Rental Object in the Response

## 1. Goal of the Final Test Case

We want to verify that when the input is valid, the route handler returns the complete rental object in the response body.

### Test Title

* **"should return the rental if input is valid"**

## 2. Initial Attempt: Matching the Entire Object

In the test, we attempted to assert:

* `expect(res.body).toMatchObject(updatedRental)`
  where `updatedRental` is the rental retrieved from the database after being updated.

Steps in the test:

1. Execute the request.
2. Retrieve the rental from the database using:

   -------------------code----------------------
   const rentalInDb = await Rental.findById(rental._id);
   -------------------code----------------------
3. Try to assert full object equality.

## 3. Reason the Test Fails

Mongoose stores `dateOut` and `dateReturned` as JavaScript `Date` objects.

However, when the response is sent as JSON:

* Dates are converted to ISO strings.

Therefore:

* `rentalInDb.dateReturned` is a Date object.
* `res.body.dateReturned` is a string.

Directly matching objects fails because the types differ.

## 4. Improving the Test: Checking for the Existence of Properties

Instead of matching the entire object, check that required properties exist.

We focus on validating the presence of the following fields:

* `dateOut`
* `dateReturned`
* `rentalFee`
* `customer`
* `movie`

Initial approach:

-------------------code----------------------
expect(res.body).toHaveProperty("dateOut");
expect(res.body).toHaveProperty("dateReturned");
expect(res.body).toHaveProperty("rentalFee");
expect(res.body).toHaveProperty("customer");
expect(res.body).toHaveProperty("movie");
-------------------code----------------------

This works but is repetitive.

## 5. Cleaner Approach: Using `Object.keys` and `arrayContaining`

A more concise version:

-------------------code----------------------
expect(Object.keys(res.body)).toEqual(
  expect.arrayContaining([
    "dateOut",
    "dateReturned",
    "rentalFee",
    "customer",
    "movie"
  ])
);
-------------------code----------------------

### Explanation:

* `Object.keys(res.body)` extracts all property names from the returned rental object.
* `expect.arrayContaining([...])` checks that these required properties exist, without requiring an exact match of all properties or their order.

This makes the test:

* More maintainable
* Less brittle
* Focused on validating structure, not internal serialization formats

## 6. Updating the Route Handler

To make the test pass, modify the final line of the route handler to return the rental object instead of an empty response:

-------------------code----------------------
return res.status(200).send(rental);
-------------------code----------------------

## 7. Final Result

After switching to property existence checks and returning the rental object, all tests pass successfully.

---


*** 15- Refactoring the Validation Logic ***
---

# Lecture Notes: Refactoring Validation Using Joi and Middleware

## 1. The Value of Test-Driven Development (TDD)

* Our `/api/returns` route handler is fully covered by tests.
* Full test coverage allows us to:

  * Refactor the function confidently.
  * Improve the implementation.
  * Ensure nothing breaks (all tests must pass after refactoring).

---

## 2. Refactoring Input Validation with Joi

### Original Implementation

* Validation was done manually using `if` statements:

-------------------code----------------------
if (!req.body.customerId) return res.status(400).send("Customer ID not provided");
if (!req.body.movieId) return res.status(400).send("Movie ID not provided");
-------------------code----------------------

### Refactored Approach

* Use Joi for validation (consistent with genre validation).

* Steps:

  1. Copy the `validate` function from the `genre` module into `returns.js`.
  2. Rename the function to `validateReturn`.
  3. Rename the parameter to `request`.
  4. Define the expected properties:

     * `customerId`: required, ObjectId
     * `movieId`: required, ObjectId
  5. Update the route handler to use:

     -------------------code----------------------
     const { error } = validateReturn(req.body);
     if (error) return res.status(400).send(error.details[0].message);
     -------------------code----------------------
  6. Import Joi at the top:

     -------------------code----------------------
     const Joi = require("joi");
     -------------------code----------------------

* **Result:** Tests continue to pass; validation is now standardized.

---

## 3. Creating a Reusable Validation Middleware

### Motivation

* Validation logic (`validateReturn`) is repeated in many route handlers.
* We can move it into a **middleware function**, similar to authentication.

### Implementation Steps

1. Create a `validate.js` middleware file:

-------------------code----------------------
function validate(validator) {
  return (req, res, next) => {
    const { error } = validator(req.body);
    if (error) return res.status(400).send(error.details[0].message);
    next();
  };
}

module.exports = validate;
-------------------code----------------------

2. Update `/api/returns` route to use middleware:

-------------------code----------------------
const validate = require("../middleware/validate");
const { validateReturn } = require("../models/return");

router.post(
  "/",
  [auth, validate(validateReturn)],
  async (req, res) => {
    // route handler logic
  }
);
-------------------code----------------------

### Key Points

* `validate` is **dynamic**: accepts any Joi validator function.
* Returns a standard Express middleware function (`req, res, next`).
* Improves code reuse and reduces repetition across routes.

---

## 4. Benefits of Refactoring

* Tests ensure safety: all 37 tests pass after changes.
* Cleaner, modular code.
* Easier to extend validation for other route handlers:

  * Simply pass the appropriate Joi validator function.
* Makes route handlers shorter and more readable.

---

## 5. Next Steps

* Move `validateReturn` function to `returns` module if not already done.
* Use `validate` middleware in other route handlers (e.g., genre, movie).
* Always write tests before refactoring existing handlers:

  * At minimum, test validation logic.

---

### Summary

* Refactored manual validation to **Joi-based validation**.
* Encapsulated validation in a **reusable middleware**.
* Leveraged **TDD** to refactor confidently.
* All tests pass, ensuring the application remains stable.
* Next lecture will continue cleaning up and improving the route handler.

---

*** 16- Mongoose Static Methods ***

---

### Improving Rental Lookup

* **Problem:** Current rental lookup uses:

  -------------------code----------------------
  await Rental.findOne({ "customer._id": req.body.customerId, "movie._id": req.body.movieId });
  -------------------code----------------------

  * Inconvenient if we need to look up a rental in multiple places.
  * We want a simpler interface:

    -------------------code----------------------
    const rental = await Rental.lookup(customerId, movieId);
    -------------------code----------------------

---

### Terminology

* **Instance Method**

  * Defined on an object (instance of a class).
  * Example: `user.generateAuthToken()`.
  * Works on a particular object.

* **Static Method**

  * Defined on the class itself.
  * Example: `Rental.lookup()`.
  * Used when the method doesn’t operate on a specific object but rather the class as a whole.

---

### Adding a Static Method to Rental

1. **Extract Schema**

   -------------------code----------------------
   const rentalSchema = new mongoose.Schema({
     customer: {
       _id: mongoose.Schema.Types.ObjectId,
       name: String,
       phone: String
     },
     movie: {
       _id: mongoose.Schema.Types.ObjectId,
       title: String,
       dailyRentalRate: Number
     },
     dateOut: { type: Date, default: Date.now },
     dateReturned: Date,
     rentalFee: Number
   });
   -------------------code----------------------

2. **Add Static Method**

   -------------------code----------------------
   rentalSchema.statics.lookup = function(customerId, movieId) {
     return this.findOne({
       "customer._id": customerId,
       "movie._id": movieId
     });
   };
   -------------------code----------------------

3. **Export the Model**

   -------------------code----------------------
   const Rental = mongoose.model("Rental", rentalSchema);
   module.exports = { Rental };
   -------------------code----------------------

---

### Updating the Returns Module

* Replace the old `findOne` code with the new static method:

  -------------------code----------------------
  const rental = await Rental.lookup(req.body.customerId, req.body.movieId);
  -------------------code----------------------
* **Important Notes**

  * Do **not** use `request.body` inside the static method.
  * Do **not** use arrow functions for methods that use `this` inside Mongoose schema.

---

### Benefits

* Cleaner code when looking up rentals.
* Centralized logic for rental lookup.
* Reduces repetition across the codebase.
* Automated tests catch mistakes immediately, preventing tedious manual testing.

---

### Common Pitfall

* Accidentally including `req.body` inside the static method.

  -------------------code----------------------
  // Mistake
  rentalSchema.statics.lookup = function() {
    return this.findOne({
      "customer._id": req.body.customerId, // should not reference req
      "movie._id": req.body.movieId
    });
  };
  -------------------code----------------------

  * Fix: Pass arguments to the method explicitly.

---

### Result

* After removing the incorrect `req.body` reference and using `Rental.lookup(customerId, movieId)`, all tests pass.
* Code is now cleaner, more reusable, and easier to maintain.

---

*** 17- Refactoring the Domain Logic ***
### Refactoring the Returns Route Handler

#### Problem

* The current route handler is **too busy**:

  * Calculates the rental fee.
  * Sets the return date.
  * Updates movie stock.
* This mixes **business logic** with **route handling**, making the code harder to maintain.

---

### Applying the Information Expert Principle

* **Principle:** Let the object that has the information also be responsible for the logic.
* Example:

  * User class generates an authentication token because it has all necessary data.
* Similarly:

  * Rental object knows its `dateOut` and `movie` details.
  * Therefore, the rental should be responsible for:

    * Setting the return date.
    * Calculating the rental fee.

---

### Creating an Instance Method on Rental

1. **Add a `return` method** on the rental schema:

   -------------------code----------------------
   rentalSchema.methods.return = function() {
       this.dateReturned = new Date();

       // Calculate rental fee
       const rentalDays = moment().diff(this.dateOut, "days");
       this.rentalFee = rentalDays * this.movie.dailyRentalRate;
   };
   -------------------code----------------------

2. **Key Points:**

   * Use **`methods`**, not `statics`, because this is an **instance method**.
   * No parameters are needed; the method works with the rental object itself.
   * Separates **setting return date** and **calculating fee** into logically grouped lines.

---

### Updating the Returns Route Handler

* Replace the old logic with a simple call to the new method:

  -------------------code----------------------
  const rental = await Rental.lookup(req.body.customerId, req.body.movieId);
  if (!rental) return res.status(404).send("Rental not found");
  if (rental.dateReturned) return res.status(400).send("Rental already processed");

  rental.return();
  await rental.save();
  -------------------code----------------------

* Advantages:

  * Cleaner route handler.
  * All rental-related logic is encapsulated in the rental object.
  * Improves readability and maintainability.

---

### Handling Dependencies

* **Moment.js** is now only needed in the rental model:

  -------------------code----------------------
  const moment = require("moment");
  -------------------code----------------------

* No need to set `res.status(200)` explicitly; Express sets this by default for successful requests.

---

### Result

* After moving logic to the rental instance method and importing `moment` in the rental model:

  * All tests pass.
  * Route handler is simplified.
  * Business logic is encapsulated in the object that has the relevant information.

---

This refactoring follows **object-oriented best practices**, reduces code duplication, and leverages your automated tests to ensure no regressions occur.

---
