*** 1- What is Test-driven Development ***
### Test-Driven Development (TDD)

#### 1. Definition

Test-driven development (TDD), also called *test first*, is a software development approach in which tests are written **before** the application (production) code.

---

### 2. The TDD Workflow

TDD consists of a simple repetitive cycle:

1. **Write a failing test**

   * The test must fail initially because no application code exists to satisfy it.

2. **Write the simplest code to make the test pass**

   * Implement only the minimal logic required.
   * Avoid over-engineering, premature class design, or unnecessary complexity.

3. **Refactor the code**

   * Clean up the implementation while keeping all tests passing.

These three steps are repeated until the entire feature is implemented.

---

### 3. Why Use TDD?

#### a. Immediate Testability

Your code is testable from the first line since tests come before implementation.

#### b. High Test Coverage

Every line of production code exists only because a test required it.
This leads to complete test coverage, making refactoring and deployment safer.

#### c. Reduced Complexity

Starting with tests prevents over-engineering.
If all tests pass and the system meets all requirements, additional code is unnecessary.
New requirements start with new failing tests.

---

### 4. TDD vs. Code-First Approach

#### TDD (Test First)

* Tests drive the design and implementation.
* Offers strong safety through full test coverage.
* Often leads to simpler and cleaner designs.

#### Code First

* The developer writes application code first, then tests afterward.
* This is how most beginners and many teams naturally work.

---

### 5. Which Approach Is Better?

* **In theory:** TDD provides better quality, better design, and safer refactoring.
* **In practice:** TDD can grow complex and sometimes slow down development.
* When TDD becomes impractical, switching to the code-first approach is reasonable.

---

*** 2- Implementing the Returns ***
---

### Implementing a New Feature with Test-Driven Development

**Goal:** Add the ability to return a movie.

---

### 1. Rental Model Overview

The `Rental` model has the following properties:

* `customer`
* `movie`
* `dateOut`
* `dateReturned`
* `rentalFee`

The last two properties (`dateReturned` and `rentalFee`) are initially undefined.
When a customer returns a movie, the system must:

1. Set the return date.
2. Calculate the rental fee.

---

### 2. API Design Considerations

#### Existing behavior

The current `/api/rentals` endpoint supports only creating a new rental through a POST request.

#### Incorrect approach

One idea might be to add an update route to modify an existing rental.
However, this approach is flawed:

* The client should **not** set `dateReturned` or `rentalFee`.
  If allowed, a client could send incorrect or manipulated values, such as a rental fee of zero.
* The client should also not modify `dateOut`, the `customer`, or other protected fields.

These values must be calculated and set **only** on the server.

---

### 3. Correct API Approach

Create a new endpoint dedicated to processing movie returns.

**Endpoint:**
`POST /api/returns`

**Request Body:**

* `customerId`
* `movieId`

**Server Responsibilities:**

1. Look up the rental associated with the given `customerId` and `movieId`.
2. Set the `dateReturned` to the current date/time.
3. Calculate the `rentalFee`.
4. Save the updated rental and return a response.

This endpoint becomes the contract exposed to clients for returning movies.

---

### 4. Preparing for Test-Driven Development

Now that the endpoint design and behavior are defined, we can begin writing test cases.
The tests will specify how this endpoint should behave before writing the actual implementation.

---

*** 3- Test Cases ***

---

### Brainstorming Test Cases for the Returns Endpoint

Before writing the implementation, we first identify all the test cases for the `POST /api/returns` endpoint.
This list may evolve as the feature becomes clearer.

---

## 1. Negative Test Cases

These tests ensure the endpoint correctly handles invalid or incomplete requests.

### a. Authentication

* **Return 401** if the client is not logged in.
  Only authenticated users should be able to call this endpoint.

### b. Missing Input

* **Return 400** if `customerId` is not provided.
* **Return 400** if `movieId` is not provided.

### c. Rental Not Found

* **Return 404** if there is no rental matching the provided `customerId` and `movieId`.

### d. Rental Already Processed

* **Return 400** if the rental exists but has already been returned
  (meaning `dateReturned` is already set).

---

## 2. Positive Test Cases

These tests cover correct behavior when the request is valid.

### a. Valid Request

* **Return 200** for a successful return operation.

### b. Set Return Date

* The endpoint should set `dateReturned` to the current date and time.

### c. Calculate Rental Fee

* The rental fee should be computed based on the rental duration and movie daily rental rate.

### d. Update Movie Inventory

* The movie’s stock count should be increased by one.

### e. Response Body

* The endpoint should return the updated rental object, including:

  * `dateOut`
  * `dateReturned`
  * `rentalFee`
  * `customer`
  * `movie`
  * Any other relevant properties

---

### Summary

These test cases define how the `/api/returns` endpoint should behave under different conditions.
In the next steps, each test will be implemented using the TDD cycle.

---

*** 4- Populating the Database ***
---

### Setting Up the Test Environment for the Returns Endpoint

We begin by creating a new integration test file for the returns feature.

---

## 1. Creating the Test File

* Navigate to the `tests/integration` folder.
* Add a new file named `returns.test.js`.
* Start with a test suite titled `/api/returns`.

---

## 2. Preparing the Test Suite Structure

Just like other integration tests:

* Load the server in `beforeEach`.
* Close the server in `afterEach`.
* Prepare necessary database records before each test.
* Clean up after each test.

To save time, copy the `beforeEach` and `afterEach` code from `genres.test.js` and modify as needed.

---

## 3. Importing Required Modules

Inside `returns.test.js`:

* Define `let server;` at the top.
* Import the `Rental` model from `models/rental`.
* Import `mongoose` to create object IDs.

---

## 4. Creating the Rental Object in beforeEach

Inside `beforeEach`:

1. **Create a new rental instance**:

   * The `rental` object must include:

     * `customer`
     * `movie`
   * `dateOut` is automatically set by Mongoose because it has a default value.

2. **Setting up the customer**:

   The customer subdocument requires:

   * `name` (minimum 5 characters)
   * `isGold` (has a default value, so no need to set manually)
   * `phone`

   Also, an `_id` must be provided because it will be used during tests.

   Steps:

   * Create `customerId = mongoose.Types.ObjectId()`.
   * Assign it to both:

     * The rental’s `customer._id`
     * A variable for later use in requests.

3. **Setting up the movie**:

   Similar to the customer:

   * Create `movieId = mongoose.Types.ObjectId()`.
   * Assign to `movie._id`.
   * Set `title` to a value of at least 5 characters.
   * Set `dailyRentalRate`, for example, to 2.

4. **Save the rental** to the database using `await rental.save()`.

Because the rental object will be reused across tests, declare it as a variable outside of `beforeEach`.

---

## 5. Cleaning Up After Each Test

Inside `afterEach`:

* Close the server.
* Remove all rentals with `await Rental.remove({})`.

---

## 6. Verifying That Setup Works

Before writing production code, ensure that test setup is correct.

Add a simple test:

* Title: `it("should work", ...)`
* In the test:

  * Use `Rental.findById(rental._id)` to fetch the rental.
  * Expect the result to be non-null.

Remember to mark both `beforeEach` and the test function as `async`.

Example corrections:

* Add `async` to `beforeEach`.
* Add `async` to the test function.

Once corrected:

* Run tests in the terminal.
* The test should pass, confirming that setup code works properly.

---

### Conclusion

The environment for the returns endpoint tests is now correctly set up.
In the next step, the first real test case will be implemented.


*** 5- Testing the Authorization ***
---

# Implementing the First Test Case (Unauthorized Client)

## Introduction

We are now ready to implement the first test case for the `/api/returns` endpoint.
The goal is to enforce that **only authenticated users** can call this endpoint. If the client is not logged in, the server should return **401 Unauthorized**.

This first example demonstrates the TDD workflow. For following test cases, you should actively attempt the exercise before watching the solution.

---

# 1. Writing the First Test Case

### Test Description

* Test name:
  **"should return 401 if client is not logged in"**
* Purpose:
  Ensure the endpoint rejects unauthenticated users.

### Steps

1. Modify the test description.
2. Remove temporary test code.
3. Import `supertest` using `const request = require("supertest");`
4. Use `request(server).post("/api/returns")` to call the endpoint.
5. Provide a valid request body:

   * `customerId`
   * `movieId`
6. Await the response.
7. Expect the status code to be `401`.

Using shorthand object syntax keeps the body clean and concise.

---

# 2. Running the Test for the First Time

Since the endpoint does not exist yet:

* Express returns **404 Not Found**.
* This causes the test to fail.
* This is expected.

Following TDD, we now write the simplest production code that makes this test pass.

---

# 3. Implementing the Endpoint

### Step 1: Create the Route

Inside `routes/`, create a new file:

```
returns.js
```

Load Express, create a router, and define a POST route. Start by copying the basic structure from the genres route file.

### Step 2: Export the Router

Use:

```
module.exports = router;
```

### Step 3: Register the Route in the Application

Open the `startup/routes.js` file and:

* Require the new returns module.
* Add:

  ```
  app.use("/api/returns", returns);
  ```

This connects the new endpoint to the application.

---

# 4. Minimal Production Code to Pass the Test

With TDD, the goal is to write **the simplest possible code** that makes the test pass.

Inside `returns.js`, modify the route handler to:

```
res.status(401).send();
```

There is no need yet to handle authentication properly.
TDD will force us to improve this later when other tests fail.

---

# 5. Fixing the "Address in Use" Error

When running tests, an error occurs:

**"Listen EADDRINUSE: address already in use"**

Cause:

* The server is not fully closed between tests.
* `server.close()` returns a promise.

Solution:

* Add `await` before `server.close()` in `afterEach` inside:

  * `genres.test.js`
  * `returns.test.js`
  * Any test suite using the server

This ensures the port is properly released before starting the next test.

---

# 6. Final Result

After applying all fixes:

* All tests pass.
* The first TDD cycle is complete.
* We built the simplest possible implementation.

---

# 7. Exercise (For You)

The next test case to implement:

**Return 400 if customerId is not provided**

Instructions:

1. Write the failing test.
2. Write the minimal production code to make both tests pass.
3. Only write the amount of logic needed for these two tests.

You will see the solution in the next lecture.

---

