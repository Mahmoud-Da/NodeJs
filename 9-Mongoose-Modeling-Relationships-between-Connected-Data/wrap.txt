*** 1- Modelling Relationships ***
### Lecture Notes: Working with Related Objects in MongoDB

#### 1. Introduction

* In previous examples, we worked with single, self-contained documents.
* In real-world applications, entities are often related.

  * Example: A **course** has an **author**.
  * An author is more than a name; it may include fields such as `name`, `website`, `image`, etc.
* MongoDB allows two main approaches for modeling such relationships:

  1. **Using References (Normalization)**
  2. **Using Embedded Documents (Denormalization)**

---

#### 2. Approach 1: Using References (Normalization)

* Each entity has its own collection:

  * `authors` collection → stores author documents.
  * `courses` collection → stores course documents with an **author ID reference**.
* Example:

  -------------------code----------------------
  author: ObjectId("12345")
  -------------------code----------------------
* This means the course refers to an author document by its ID.

**Key Points:**

* In **relational databases**, relationships enforce data integrity.
* In **MongoDB**, relationships are **not enforced**.

  * MongoDB will not check if the referenced ID exists or is valid.
* A course can have **multiple authors** by storing an array of author IDs.

**Advantages:**

* **Consistency:** There is a single source of truth for each author.

  * Changing an author’s name automatically affects all referencing courses.

**Disadvantages:**

* **Performance:** Requires multiple queries.

  * You must query the author separately when loading a course.

---

#### 3. Approach 2: Using Embedded Documents (Denormalization)

* Instead of a separate collection, embed the author document directly inside the course document.
* Example:

  -------------------code----------------------
  {
    title: "Course A",
    author: {
      name: "Mosh",
      website: "example.com"
    }
  }
  -------------------code----------------------

**Advantages:**

* **Performance:** Only one query is needed to retrieve a course and its author.
* Ideal when query speed is critical.

**Disadvantages:**

* **Inconsistency:**

  * If an author’s name changes, it must be updated in multiple documents.
  * If updates fail, data may become inconsistent.

---

#### 4. Trade-off Between Consistency and Performance

| Approach                   | Consistency | Performance                 |
| -------------------------- | ----------- | --------------------------- |
| References (Normalization) | High        | Lower (needs extra queries) |
| Embedded (Denormalization) | Lower       | High (fewer queries)        |

* You must decide which is more important based on your application’s needs.
* Always design your schema with **query requirements** in mind.

---

#### 5. Approach 3: Hybrid Approach

* Combines both normalization and denormalization.
* Example:

  * Maintain a separate `authors` collection with full author details.
  * In each `course` document, embed only **partial author data** (e.g., `id` and `name`).

  -------------------code----------------------
  {
    title: "Course A",
    author: {
      id: ObjectId("12345"),
      name: "Mosh"
    }
  }
  -------------------code----------------------

**Advantages:**

* Balances **query performance** and **data consistency**.
* Avoids full data duplication.
* Useful for maintaining **data snapshots**.

**Example Use Case:**

* **E-commerce orders:**

  * You want to store the product details (e.g., price) at the time of purchase.
  * Even if the product price changes later, the order should retain the original data.

---

#### 6. Summary

* **Normalization (References):**

  * Pros: Data consistency, single source of truth.
  * Cons: Slower queries, multiple lookups.
* **Denormalization (Embedded Documents):**

  * Pros: Faster reads, fewer queries.
  * Cons: Risk of inconsistent data on updates.
* **Hybrid Approach:**

  * Mix of both methods for balance and flexibility.
* The choice depends entirely on the **application’s design and query patterns**.

---

#### 7. Next Steps

* The following lectures will cover practical implementation of:

  1. Normalized relationships
  2. Denormalized relationships
  3. Hybrid structures

*** 2- Referencing Documents ***
### Lecture Notes: Referencing Documents in MongoDB

#### 1. Overview

* In this lecture, the goal is to **reference one document from another** in MongoDB using **Mongoose**.
* We’ll use a file named **`population.js`** that contains two models:

  1. **Author** model – with properties: `name`, `bio`, and `website`.
  2. **Course** model – with property: `name`.
* We will add an additional property `author` to the **Course** model to reference an **Author** document.

---

#### 2. Preparation Steps

1. Open **MongoDB Compass**.
2. **Delete the “playground” database** to start fresh.

   * Type `playground` in the search field and delete the database.
3. Open the terminal in the project directory.

---

#### 3. Creating the Author

* At the bottom of `population.js`, there is a call to `createAuthor()`.

  -------------------code----------------------
  createAuthor('Mosh', 'Author bio', 'Website URL');
  -------------------code----------------------
* Run the following command in the terminal:

  -------------------code----------------------
  node population.js
  -------------------code----------------------
* This will create one **Author** document and return its **Object ID** in the terminal.

**Example output:**

-------------------code----------------------
Author created:
{
  _id: 665abc12345,
  name: "Mosh",
  bio: "...",
  website: "..."
}
-------------------code----------------------

* Copy the **author ID** from the terminal for the next step.

---

#### 4. Creating the Course and Referencing the Author

* Comment out the `createAuthor()` line in the code.
* Uncomment or enable the `createCourse()` call, passing the **author ID** as a string.

Example:

-------------------code----------------------
createCourse('Node Course', '665abc12345');
-------------------code----------------------

* The `createCourse()` function creates a course object with two properties:

  -------------------code----------------------
  name: "Node Course"
  author: "665abc12345"
  -------------------code----------------------

* Run the script again:

  -------------------code----------------------
  node population.js
  -------------------code----------------------

* You will see the created course ID and name in the terminal, but not the author.

---

#### 5. Updating the Course Model to Include the Author Reference

* The reason the author was not saved is that the **Course schema** only included the `name` property.
* You must explicitly define the `author` field in the schema.

Update the Course schema as follows:

-------------------code----------------------
const courseSchema = new mongoose.Schema({
  name: String,
  author: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Author'
  }
});
-------------------code----------------------

**Explanation:**

* `type: mongoose.Schema.Types.ObjectId` → defines the data type as an **Object ID**.
* `ref: 'Author'` → indicates that this field references the **Author** collection.

---

#### 6. Running the Updated Code

* Save the file and re-run the script:

  -------------------code----------------------
  node population.js
  -------------------code----------------------
* Output example:

  -------------------code----------------------
  Course created:
  {
    _id: 665def67890,
    name: "Node Course",
    author: "665abc12345"
  }
  -------------------code----------------------

---

#### 7. Verifying in MongoDB Compass

* Open **MongoDB Compass** and check the **“playground”** database.
* Navigate to the **courses** collection.
* You will now see two course documents:

  1. The first (older) one has no author.
  2. The second (new) one includes an `author` field with an **Object ID** reference.

Example:

-------------------code----------------------
{
  "_id": ObjectId("665def67890"),
  "name": "Node Course",
  "author": ObjectId("665abc12345")
}
-------------------code----------------------

---

#### 8. Key Takeaways

* Defining a reference in Mongoose requires specifying both **type** and **ref** in the schema.
* MongoDB does **not enforce foreign key relationships**.

  * You can store an invalid or non-existent author ID, and MongoDB will not raise an error.
* Referencing is useful when you want **consistency** and to avoid duplicating data across collections.

---

#### 9. Summary of Steps

1. Create and save an **Author** document.
2. Copy the author’s ID.
3. Add an **author** field to the **Course** schema using `ObjectId` and `ref`.
4. Create a **Course** document with the author’s ID.
5. Verify the stored relationship in **MongoDB Compass**.

This sets the foundation for learning how to populate referenced documents, which will be covered in upcoming lectures.

*** 3- Population ***

### Lecture Notes: Populating Referenced Documents in MongoDB

#### 1. Introduction

* The goal of this lecture is to **load related documents** in MongoDB using **Mongoose’s `populate()` method**.
* We will retrieve all courses along with their corresponding authors.

---

#### 2. Preparing the Code

* In the `population.js` file, scroll to the bottom where the `listCourses()` function is defined.
* Enable this function call to execute it when running the script.
* Inside the function, the code retrieves all courses from the database:

  -------------------code----------------------
  const courses = await Course.find().select('name');
  -------------------code----------------------
* Run the script in the terminal:

  -------------------code----------------------
  node population.js
  -------------------code----------------------
* Output: only the `_id` and `name` fields of each course are shown.

---

#### 3. Including the Author Field

* Modify the code to also select the `author` field:

  -------------------code----------------------
  const courses = await Course.find().select('name author');
  -------------------code----------------------
* Run the script again.
* Now, the output shows each course’s `_id`, `name`, and `author` fields.
* However, the `author` currently appears only as an **ObjectId** reference.

---

#### 4. Using the `populate()` Method

* To load full author details instead of just the ObjectId, use the `populate()` method:

  -------------------code----------------------
  const courses = await Course
    .find()
    .select('name author')
    .populate('author');
  -------------------code----------------------
* **Explanation:**

  * `populate('author')` tells Mongoose to replace the `author` ObjectId with the actual author document.
  * When defining the Course schema, the `author` field was declared as:

    -------------------code----------------------
    author: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Author'
    }
    -------------------code----------------------

    This `ref` allows Mongoose to know which collection to query when populating.

---

#### 5. Running the Code

* Run again in the terminal:

  -------------------code----------------------
  node population.js
  -------------------code----------------------
* Output:

  * Courses without an author show no `author` field.
  * Courses with an author now display the full author document (e.g., `name`, `bio`, `website`).

---

#### 6. Selecting Specific Author Properties

* In real-world scenarios, authors may have many properties.
* When listing courses, you may not want to retrieve all of them.
* You can limit which fields to populate by adding a **second argument** to `populate()`:

  -------------------code----------------------
  const courses = await Course
    .find()
    .select('name author')
    .populate('author', 'name');
  -------------------code----------------------
* Run again:

  * The output now includes only `name` and `_id` for the author.

---

#### 7. Excluding the Author’s `_id`

* To exclude a property, prefix it with a minus (`-`):

  -------------------code----------------------
  const courses = await Course
    .find()
    .select('name author')
    .populate('author', 'name -_id');
  -------------------code----------------------
* Run again:

  * The author object now contains only the `name` field.

---

#### 8. Populating Multiple References

* You can populate more than one field by chaining multiple `populate()` calls.
* Example (if `course` also has a `category` field):

  -------------------code----------------------
  const courses = await Course
    .find()
    .select('name author category')
    .populate('author', 'name -_id')
    .populate('category', 'name');
  -------------------code----------------------
* Each `populate()` specifies which related document and fields to include.

---

#### 9. Handling Invalid References

* MongoDB does **not enforce relationships** for data integrity.
* You can assign an invalid ObjectId as a reference without error.
* Example: if you modify a course’s author ID to an invalid one in MongoDB Compass (e.g., change `0c` to `1c`),
  MongoDB will accept it without complaint.
* When running the script again:

  -------------------code----------------------
  node population.js
  -------------------code----------------------

  The result shows:

  -------------------code----------------------
  "author": null
  -------------------code----------------------

  because Mongoose cannot find a matching author document.

---

#### 10. Key Takeaways

* `.populate()` is used to load referenced documents automatically.
* You can control which fields to include or exclude using the second argument of `populate()`.
* Multiple `populate()` calls can load different related fields.
* MongoDB allows invalid references; Mongoose will simply return `null` for those.
* Always design your schema and queries based on your application’s data integrity requirements.

---

#### 11. Summary of the `listCourses()` Function Example

Final version of the function:

-------------------code----------------------
async function listCourses() {
  const courses = await Course
    .find()
    .select('name author')
    .populate('author', 'name -_id');
  console.log(courses);
}
-------------------code----------------------

**Result:**
Courses are listed with each author’s name, while ignoring unnecessary fields and invalid references.


*** 4- Embedding Documents ***
**Lecture Notes: Embedding Documents in MongoDB (Mongoose)**

---

### 1. Overview

In this lecture, we learn an alternative to referencing documents: **embedding documents**.
Embedding allows us to store a document directly inside another document as a **subdocument**.

---

### 2. Setup

* File used: **embedding.js**
* Existing structure:

  * **Author Schema**: `name`, `bio`, `website`
  * **Course Schema**: currently has only `name`

We will modify the **Course Schema** to embed an author document.

---

### 3. Embedding the Author Schema

Previously, in the reference model, we defined:

-------------------code----------------------
author: {
  type: mongoose.Schema.Types.ObjectId,
  ref: 'Author'
}
-------------------code----------------------

Now, we replace that with:

-------------------code----------------------
author: authorSchema
-------------------code----------------------

This embeds the entire author object inside the course document rather than just its reference ID.

---

### 4. Creating a Course with Embedded Author

* The `createCourse` function initializes a new course with an embedded author and saves it.
* Before running, clear the database in MongoDB Compass for a clean start.

Run in terminal:

-------------------code----------------------
node embedding.js
-------------------code----------------------

**Result:**
The course document will include:

-------------------code----------------------on
{
  "_id": "...",
  "name": "Node Course",
  "author": {
    "_id": "...",
    "name": "Mosh"
  }
}
-------------------code----------------------

Here, `author` is a **subdocument**.

---

### 5. Subdocument Behavior

* Subdocuments behave like normal documents:

  * Support **validation**.
  * Can have **required** fields.
* However, **they cannot be saved independently** — only within their parent document.

---

### 6. Updating a Subdocument (Method 1)

To update an embedded author’s name:

-------------------code----------------------
async function updateAuthor(courseId) {
  const course = await Course.findById(courseId);
  course.author.name = "Mosh Hamidani";
  await course.save();
}
-------------------code----------------------

Run:

-------------------code----------------------
node embedding.js
-------------------code----------------------

Check in MongoDB Compass:
The embedded author’s name should now be **"Mosh Hamidani"**.

---

### 7. Updating a Subdocument (Method 2 — Direct Update)

You can update without fetching the document first:

-------------------code----------------------
await Course.updateOne(
  { _id: courseId },
  { $set: { "author.name": "John Smith" } }
);
-------------------code----------------------

This modifies the subdocument directly in the database.

---

### 8. Removing a Subdocument

To remove an embedded document or a specific field, use `$unset`:

-------------------code----------------------
await Course.updateOne(
  { _id: courseId },
  { $unset: { author: "" } } // removes the entire author object
);
-------------------code----------------------

After running:

-------------------code----------------------
node embedding.js
-------------------code----------------------

Check Compass — the `author` field will no longer exist.

---

### 9. Validation for Embedded Documents

You can enforce validation on subdocuments just like top-level documents.

**Example:**

To make `author` required in the course schema:

-------------------code----------------------
author: {
  type: authorSchema,
  required: true
}
-------------------code----------------------

To make a specific property (like `author.name`) required:

-------------------code----------------------
name: {
  type: String,
  required: true
}
-------------------code----------------------

---

### 10. Summary

| Feature      | Referencing                 | Embedding                      |
| ------------ | --------------------------- | ------------------------------ |
| Relationship | Uses ObjectId reference     | Directly includes the document |
| Querying     | Requires population         | No need for population         |
| Performance  | Good for large, shared data | Faster read for related data   |
| Redundancy   | Minimal                     | May have duplicate data        |
| Independence | Documents separate          | Embedded depends on parent     |

---

**Next Topic:** Working with an **array of subdocuments** in Mongoose.


*** 5- Using an Array of Sub-documents ***
**Lecture Notes: Working with Arrays of Subdocuments in MongoDB (Mongoose)**

---

### 1. Introduction

In the previous lecture, we learned how to embed a single author subdocument inside a course document.
In this lecture, we extend that idea to **an array of subdocuments**, allowing each course to have **multiple authors**.

---

### 2. Updating the Schema

**Before:**

-------------------code----------------------
author: authorSchema
-------------------code----------------------

**Now:**
We rename the property to `authors` and make it an array of subdocuments:

-------------------code----------------------
authors: [authorSchema]
-------------------code----------------------

This allows multiple author objects to be stored within a single course document.

---

### 3. Creating a Course with Multiple Authors

When creating a course, we now pass an array of authors:

-------------------code----------------------
async function createCourse(name, authors) {
  const course = new Course({
    name,
    authors
  });
  await course.save();
}
-------------------code----------------------

Example usage:

-------------------code----------------------
createCourse("Node Course", [
  { name: "Mosh" },
  { name: "John" }
]);
-------------------code----------------------

---

### 4. Resetting the Database

Before running the code, open **MongoDB Compass**, delete the current `courses` collection, and then run:

-------------------code----------------------
node embedding.js
-------------------code----------------------

**Result:**
Each course document will now contain an array of author objects:

-------------------code----------------------on
{
  "_id": "...",
  "name": "Node Course",
  "authors": [
    { "_id": "...", "name": "Mosh" },
    { "_id": "...", "name": "John" }
  ]
}
-------------------code----------------------

---

### 5. Adding an Author to the Array

To add a new author after a course already exists:

-------------------code----------------------
async function addAuthor(courseId, author) {
  const course = await Course.findById(courseId);
  course.authors.push(author);
  await course.save();
}
-------------------code----------------------

Example call:

-------------------code----------------------
addAuthor("66a3c...", { name: "Amy" });
-------------------code----------------------

**Steps:**

1. Find the course using its ID.
2. Push the new author object into the `authors` array.
3. Save the updated course document.

After running:

-------------------code----------------------
node embedding.js
-------------------code----------------------

Check in MongoDB Compass — the course document now includes the new author `Amy`.

---

### 6. Removing an Author from the Array

To remove an existing author:

-------------------code----------------------
async function removeAuthor(courseId, authorId) {
  const course = await Course.findById(courseId);
  const author = course.authors.id(authorId);
  author.remove();
  await course.save();
}
-------------------code----------------------

Example call:

-------------------code----------------------
removeAuthor("66a3c...", "66a4f...");
-------------------code----------------------

NOTE: for new version of mongoose the remove method is deprecated
so we have two ways:
-------------------code----------------------
1- using filter JS method

 async function removeAuthor(courseId, authorId) {
  const course = await Course.findById(courseId);
  if (!course) return console.log("Course not found");

  // Filter out the author by ID
  course.authors = course.authors.filter(a => a._id.toString() !== authorId);
  
  await course.save();
  console.log("Author removed successfully");
}
-------------------code----------------------

2- using mongoose "pull()" method
-------------------code----------------------
async function removeAuthor(courseId, authorId) {
  const course = await Course.findById(courseId);
  if (!course) return console.log("Course not found");

  course.authors.pull({ _id: authorId }); // removes matching subdocument
  await course.save();
  console.log("Author removed successfully");
}
-------------------code----------------------


- pull() vs filter():

| Aspect                   | `.pull()`                                                    | `.filter()`                                         |
| ------------------------ | ------------------------------------------------------------ | --------------------------------------------------- |
| **Performance**          | ⚡ Slightly faster (internally optimized for Mongoose arrays) | A bit slower (creates a new array and reassigns it) |
| **Readability**          | Cleaner, more expressive for removing subdocs                | Slightly more verbose                               |
| **Mongoose integration** | Fully aware of subdocument tracking and change detection     | Works fine, but you rely on manual reassignment     |
| **Mutation**             | Mutates the array in place                                   | Creates a new array (non-mutating)                  |


**Explanation:**

* `course.authors.id(authorId)` retrieves the embedded author by its `_id`.
* `author.remove()` removes that specific subdocument from the array.
* Finally, `course.save()` persists the changes.

After running:

-------------------code----------------------
node embedding.js
-------------------code----------------------

In MongoDB Compass, refresh the collection — the specified author will be removed.

---

### 7. Key Notes on Arrays of Subdocuments

| Operation           | Method                    |
| ------------------- | ------------------------- |
| Add new subdocument | `array.push(subdocument)` |
| Remove by ID        | `array.id(id).remove()`   |
| Save changes        | `document.save()`         |

**Characteristics:**

* Subdocuments in arrays are fully functional Mongoose documents.
* They support validation and schema rules.
* They cannot be saved independently; they must be saved through their parent.

---

### 8. Summary

* Changed a single embedded document into an **array of subdocuments**.
* Learned how to **add** and **remove** authors within that array.
* Used Mongoose methods like `.push()`, `.id()`, and `.remove()` to manipulate nested data.

---

### 9. Next Lecture

In the next lecture, we will discuss **design trade-offs between embedding and referencing** — when to use each approach depending on the application’s requirements.


*** 6- Project- Build the Movies API ***
---

## Lecture Notes: Building the Movie API (VidLib Project)

### 1. Overview

In this exercise, the goal is to build an API to manage a list of movies in MongoDB.
This task is more challenging than managing the list of genres. Each movie document will embed a genre document inside it to improve query performance.

### 2. Movie Schema Design

#### Movie Object Structure

Each **movie** will have the following properties:

* **title** (string)
* **genre** (embedded document)
* **numberInStock** (number)
* **dailyRentalRate** (number)

#### Design Decision: Embedded Genre

Although there is a separate `genres` collection, a genre document is **embedded** inside each movie document.
**Reasoning:**

* Improves query performance.
* Genre names (e.g., Sci-Fi, Thriller) rarely change, so data inconsistency is unlikely.
* The `genres` collection is still useful for UI components, such as dropdowns for selecting a movie’s genre.

### 3. Detailed Schema Definition

#### Title Property

* **Type:** String
* **Required:** Yes
* **Trim:** Enabled (removes extra spaces)
* **Min Length:** 5 characters
* **Max Length:** 255 characters
* **Purpose:** Prevents invalid or maliciously long strings.

#### Genre Property

* **Type:** `genreSchema` (embedded)
* The `genreSchema` is imported from the `genre` module.
* The schema was extracted into a separate constant in the `genre` module and exported for reuse.

#### Number in Stock

* **Type:** Number
* **Required:** Yes
* **Min:** 0
* **Max:** 255
* **Purpose:** Prevents invalid negative or excessively large values.

#### Daily Rental Rate

* **Type:** Number
* **Required:** Yes
* **Min:** 0
* **Max:** 255

### 4. Validation Schema (Joi)

#### Purpose

The Joi validation schema is different from the Mongoose schema. It defines **what the client sends** to the API.

#### Joi Schema Example

* **genreId:** String, required

  * The client sends only the genre’s ID, not the full genre object.
* **title**, **numberInStock**, and **dailyRentalRate:** Validated similarly to Mongoose schema.

**Note:**

* The **Mongoose schema** represents how data is stored in MongoDB.
* The **Joi schema** represents how data is received from the client.

### 5. Creating a Movie (Route Handler)

#### Steps

1. **Validate the request body** using Joi.

   * If invalid, return **400 Bad Request**.
2. **Find the genre by ID.**

   * If not found, return **400 Invalid Genre**.
3. **Create the movie object.**

   * `title`: From request body.
   * `genre`: An embedded object with only `_id` and `name`.

     * Only selected fields are embedded to avoid unnecessary data such as version keys (`__v`) or extra properties.
   * `numberInStock` and `dailyRentalRate`: From request.

#### Example Snippet

-------------------code----------------------
const movie = new Movie({
  title: req.body.title,
  genre: {
    _id: genre._id,
    name: genre.name
  },
  numberInStock: req.body.numberInStock,
  dailyRentalRate: req.body.dailyRentalRate
});
-------------------code----------------------

### 6. Key Takeaways

* **Hybrid approach:** Combines embedding (for performance) with referencing (for reusability).
* **Separated schemas:** Joi for validation, Mongoose for persistence.
* **Selective embedding:** Only store necessary fields from related documents.
* **Validation and safety:** Input checks prevent malformed or malicious data.

---


*** 7- Project- Build the Rentals API ***
---

## Lecture Notes: Building the Rentals API (VidLib Project)

### 1. Overview

At this stage, the application already has APIs for **customers**, **genres**, and **movies**.
The next step is to build an API for **rentals**.

The Rentals API should allow:

* **Creating a new rental** (`POST /api/rentals`)
* **Getting a list of rentals** (`GET /api/rentals`)

---

### 2. Rental Model Design

#### Schema Location

A new file named **rental.js** is created in the `models` folder.

#### Rental Schema Structure

Each rental document in MongoDB will contain the following properties:

1. **customer**

   * **Type:** Custom schema (not reusing the full `Customer` schema)
   * **Reason:**

     * The customer object may have many properties (e.g., 50 or more).
     * Only the essential fields needed for displaying rentals are included.
   * **Included Fields:**

     * `name`
     * `isGold` (used for potential discounts)
     * `phone`
     * `_id` (so we can retrieve full customer info later if needed)

2. **movie**

   * **Type:** Custom schema (not reusing the full `Movie` schema)
   * **Included Fields:**

     * `title`
     * `dailyRentalRate`
     * `_id`
   * **Reason:**

     * Movies can have many properties; only the necessary ones for rentals are stored.
     * This allows calculating the rental fee without extra queries.

3. **dateOut**

   * **Type:** Date
   * **Required:** Yes
   * **Default:** Current date and time (set automatically by Mongoose)

4. **dateReturned**

   * **Type:** Date
   * **Required:** No (because it's initially unset until the movie is returned)

5. **rentalFee**

   * **Type:** Number
   * **Min:** 0

---

### 3. Validation Schema (Joi)

The Joi validation schema differs from the Mongoose schema.
It defines what the **client** must send when creating a new rental.

#### Required Client Inputs

* `customerId`
* `movieId`

#### Server-Handled Properties

* `dateOut` → automatically set to current date/time
* `dateReturned` → initially empty, updated later
* `rentalFee` → calculated by the server

**Purpose:**
Prevents clients from manipulating system-controlled fields.

---

### 4. Rentals API Implementation

#### a. Get All Rentals

**Endpoint:** `GET /api/rentals`

* Returns the list of all rentals.
* Rentals are **sorted by `dateOut` in descending order** (most recent first).

-------------------code----------------------
const rentals = await Rental.find().sort('-dateOut');
res.send(rentals);
-------------------code----------------------

#### b. Create a New Rental

**Endpoint:** `POST /api/rentals`

**Steps:**

1. **Validate request body** using Joi.

   * If invalid → return **400 Bad Request**.

2. **Validate `customerId`**

   * Find customer by ID.
   * If not found → return **400 Invalid Customer**.

3. **Validate `movieId`**

   * Find movie by ID.
   * If not found → return **400 Invalid Movie**.

4. **Check stock availability**

   * If `movie.numberInStock` is 0 → return **400 Movie not in stock**.

5. **Create a new rental object**

   -------------------code----------------------
   const rental = new Rental({
     customer: {
       _id: customer._id,
       name: customer.name,
       phone: customer.phone
     },
     movie: {
       _id: movie._id,
       title: movie.title,
       dailyRentalRate: movie.dailyRentalRate
     }
   });
   -------------------code----------------------

   * `dateOut` is automatically set by Mongoose’s default value.

6. **Update movie stock**

   -------------------code----------------------
   movie.numberInStock--;
   -------------------code----------------------

7. **Save both changes**

   * Save rental and movie updates.

---

### 5. Transaction Problem

**Issue:**
Saving the rental and updating the movie stock are **two separate operations**.
If something fails after the first operation (e.g., server crash, lost connection), the data could become inconsistent.

**Ideal Solution:**
Use a **transaction** so both operations either:

* Complete successfully, or
* Roll back entirely.

**In MongoDB:**

* Transactions are not natively supported for standalone operations.
* A concept called **Two-Phase Commit** can simulate this behavior, but it’s an advanced topic.

**Next Step:**
In the following lecture, an **NPM package** will be introduced to simulate transaction-like behavior in Mongoose.

---

### 6. Key Takeaways

* Use **embedded custom schemas** for efficiency and simplicity.
* Keep only **essential fields** in embedded documents.
* Let the **server handle computed fields** (e.g., rental fee, dates).
* Apply **input validation** using Joi.
* Understand the need for **transaction safety** when performing multiple database updates.

---

### What is wo-phase commit (2PC)?
A **two-phase commit (2PC)** is a method used in databases to make sure a **transaction involving multiple operations or databases** either:

* **Fully succeeds (all changes are saved)**, or
* **Fully fails (nothing is changed)**

— so that data stays consistent everywhere.

---

### Simple Explanation

Imagine you have two bank accounts in **different databases**, and you want to **transfer money** from one to the other.

1. **Phase 1 — Prepare (Ask everyone if ready):**
   The system asks both databases:
   “Can you complete this operation successfully?”
   Each one checks and replies “Yes” or “No”.

2. **Phase 2 — Commit or Rollback (Do it or cancel):**

   * If **all** databases said “Yes,” the system tells them to **commit** (actually save the changes).
   * If **any** said “No,” the system tells **everyone to rollback** (cancel their changes).

---

### Why It Matters

Without this system, one database might update while another fails — causing inconsistent data.
Two-phase commit ensures **either all changes happen together or none do**.

---

### In MongoDB

MongoDB doesn’t have traditional transactions (like SQL databases), so it uses a **two-phase commit technique** to simulate this behavior — ensuring that multiple related operations act like a single, all-or-nothing transaction.

Would you like me to show you a short example of how MongoDB simulates a two-phase commit using code (like with the `Fawn` library)?




### Example: Two-Phase Commit with Fawn

Let’s say we have a movie rental app.
When a customer rents a movie, we want to:

1. **Create a new rental record**
2. **Decrease the movie stock by 1**

Both operations must happen **together** — if one fails, the other should be canceled.
This is where two-phase commit helps.

---

### 1. Install Fawn

-------------------code----------------------
npm install fawn
-------------------code----------------------

---

### 2. Import and Initialize Fawn

-------------------code----------------------
const mongoose = require('mongoose');
const Fawn = require('fawn');

Fawn.init(mongoose);
-------------------code----------------------

This connects Fawn to MongoDB and prepares it to simulate transactions.

---

### 3. Create a “Transaction” (Task)

Here’s how to perform both operations as a single transaction:

-------------------code----------------------
router.post('/', async (req, res) => {
  const rental = new Rental({
    customer: req.body.customerId,
    movie: req.body.movieId
  });

  try {
    // Start a Fawn task
    new Fawn.Task()
      // Operation 1: Save the rental document
      .save('rentals', rental)

      // Operation 2: Update the movie stock
      .update('movies', { _id: rental.movie }, {
        $inc: { numberInStock: -1 } // Decrease stock by 1
      })

      // Commit both operations together
      .run();

    res.send(rental);
  } catch (err) {
    res.status(500).send('Something failed.');
  }
});
-------------------code----------------------

---

### 4. How It Works Internally (the two phases)

**Phase 1 – Prepare:**
Fawn adds a temporary document in a hidden collection in MongoDB (for example, `_fawn_jobs`).
This stores all the operations that need to be executed.

**Phase 2 – Commit or Rollback:**
Fawn runs each operation one by one:

* If all succeed → The temporary document is deleted (transaction committed).
* If one fails → All changes are rolled back (transaction canceled).

---

### 5. Why Use It

MongoDB (before version 4.0) didn’t support multi-document transactions natively, so libraries like `Fawn` were built to simulate them using the **two-phase commit** idea.

Now, modern MongoDB versions have real multi-document transactions, but this concept remains important for understanding **how atomicity was achieved before that**.

---



*** 8- Transactions ***
---

## Lecture Notes: Implementing Transactions in MongoDB with Fawn

### 1. Introduction to Transactions

In relational databases such as **SQL Server** or **MySQL**, a **transaction** is a group of operations that must be executed as a single unit:

* Either **all operations succeed**, and the database is updated.
* Or, if **one operation fails**, all previous operations are **rolled back**, leaving the database unchanged.

This ensures **data consistency**.

---

### 2. Transactions in MongoDB

MongoDB does **not** natively support transactions in the same way as relational databases (at least in standalone setups).
Instead, MongoDB uses a technique called the **Two-Phase Commit**, which ensures that multiple operations either complete together or not at all.

To learn more about this mechanism:

* Reference: *MongoDB Documentation → Perform Two-Phase Commits.*

However, the two-phase commit process is complex and beyond the scope of this course.
Instead, a library named **Fawn** is introduced, which **simulates transactions** in Mongoose using this two-phase commit internally.

---

### 3. Installing and Setting Up Fawn

#### Installation

-------------------code----------------------
npm install fawn
-------------------code----------------------

Version used: **2.1.5**

#### Initialization

In the `rentals.js` file:

-------------------code----------------------
const Fawn = require('fawn');
Fawn.init(mongoose);
-------------------code----------------------

* `Fawn` is a class.
* You must call `Fawn.init()` and pass the `mongoose` object to initialize it.

---

### 4. Using Fawn to Create a Transaction

Previously, the code explicitly:

1. Created and saved a rental document.
2. Decremented the movie stock count.
3. Saved the movie again.

Now, both steps will be handled **as a single transaction** using Fawn.

#### Creating a Transaction Task

-------------------code----------------------
try {
  new Fawn.Task()
    .save('rentals', rental) // 1. Save rental
    .update('movies', { _id: movie._id }, {
      $inc: { numberInStock: -1 } // 2. Decrement stock
    })
    .run(); // Execute the transaction
}
catch (ex) {
  res.status(500).send('Something failed.');
}
-------------------code----------------------

**Explanation:**

* `Fawn.Task()` creates a new transaction-like task.
* `.save()` and `.update()` define operations to perform.
* Collection names (e.g., `'rentals'`, `'movies'`) must match MongoDB’s actual lowercase collection names.
* `.run()` executes all operations as one atomic unit.
* If anything fails, no operation is applied.
* Wrapped in a **try-catch block** to handle exceptions.

---

### 5. Error Handling and Logging

If a transaction fails:

* The server responds with **HTTP 500 (Internal Server Error)**.
* In a real-world application, the exception should be **logged** for later investigation.

Error handling and logging are covered in a separate course section.

---

### 6. Demonstration and Verification

#### Step 1: Check Current Stock

Before creating a rental:

* The movie in the database shows `numberInStock = 8`.

#### Step 2: Create a Rental (Postman)

* Send a POST request to `/api/rentals` with valid `customerId` and `movieId`.

#### Step 3: Verify Transaction

* Response shows the new rental with properties such as `_id`, `customer`, `movie`, and `dateOut`.
* After refreshing the movies collection in MongoDB Compass,
  `numberInStock` becomes **7**, confirming that the transaction succeeded.

---

### 7. Understanding Default Values in Mongoose

After running the transaction:

* The rental document contains `_id` and `dateOut`, even though these weren’t set manually.

**Reason:**

* These values are automatically assigned by **Mongoose**, not MongoDB.
* Mongoose uses the schema definition to:

  * Generate `_id` before saving the document.
  * Set default values such as the current date for `dateOut`.

---

### 8. Fawn’s Internal Mechanism

After executing a Fawn transaction, a new collection appears in the database.
This collection is automatically created and managed by Fawn.

**Purpose:**

* Fawn temporarily stores transaction metadata in this collection while operations are in progress.
* Once all operations complete successfully, the corresponding document is deleted.
* This mechanism simulates **two-phase commits** within MongoDB.

---

### 9. Key Takeaways

* **Transactions** ensure that multiple operations succeed or fail together.
* **MongoDB** lacks native transactions like relational databases, but **Fawn** simulates them using a **two-phase commit**.
* **Fawn workflow:**

  1. Initialize with `Fawn.init(mongoose)`.
  2. Chain operations with `.save()` and `.update()`.
  3. Finalize with `.run()`.
* Always **wrap transactions in try-catch blocks** for safety.
* Mongoose automatically sets default values like `_id` and `dateOut`.
* Fawn creates an internal collection to manage transaction states.

---


*** 9- ObjectID ***
---

## Lecture Notes: Understanding Object IDs in MongoDB

### 1. Overview

When you store a document in MongoDB, the database automatically assigns a unique `_id` value to it.
This ID looks like a long string of 24 hexadecimal characters — each pair of characters represents **1 byte**, making it a total of **12 bytes**.

---

### 2. Structure of an ObjectID (12 bytes)

| Component          | Size    | Description                                                                |
| ------------------ | ------- | -------------------------------------------------------------------------- |
| Timestamp          | 4 bytes | Time when the document was created.                                        |
| Machine Identifier | 3 bytes | Identifies the machine on which the document was created.                  |
| Process Identifier | 2 bytes | Identifies the process that created the document.                          |
| Counter            | 3 bytes | Ensures uniqueness among documents created in the same process and second. |

Because the timestamp is embedded within the ObjectID:

* You don’t need a separate `createdAt` field.
* You can sort documents by `_id` to get them in creation order.

---

### 3. How Uniqueness Works

Each ObjectID is almost unique because of its combination of timestamp, machine ID, process ID, and counter.

#### Byte breakdown:

* 1 byte = 8 bits
* Possible combinations per byte = 2⁸ = 256
* The 3-byte counter = 2²⁴ = 16 million possibilities

This means within the same machine, process, and second, MongoDB can safely generate about **16 million unique ObjectIDs** before the counter overflows.
If more than 16 million documents are created in the same second under identical conditions, there is a tiny chance of collision — but it’s extremely rare.

---

### 4. Why MongoDB Doesn’t Guarantee 100% Uniqueness

Relational databases (like MySQL or SQL Server) use **auto-incrementing IDs** that are guaranteed to be unique but reduce scalability, since they rely on a central sequence generator.

MongoDB instead generates IDs **client-side** using the **MongoDB Driver**, not the database server.
This allows:

* Higher scalability.
* No dependency on a central authority to create unique IDs.
* Multiple database instances to generate IDs independently.

---

### 5. Role of Mongoose and MongoDB Driver

When building applications with **Node.js** and **Mongoose**:

* Mongoose is an abstraction layer built over the MongoDB driver.
* When you create a new document, Mongoose communicates with the driver, which generates a new ObjectID before saving to the database.

---

### 6. Creating ObjectIDs Manually

You can generate ObjectIDs manually without inserting a document into MongoDB.

-------------------code----------------------
const mongoose = require('mongoose');

// Create a new ObjectID
const id = new mongoose.Types.ObjectId();
console.log(id);
-------------------code----------------------

Running this will print a unique ObjectID, created in memory.

---

### 7. Extracting the Timestamp

The first 4 bytes of the ObjectID contain a timestamp.
You can extract it like this:

-------------------code----------------------
console.log(id.getTimestamp());
-------------------code----------------------

This shows the exact time the ObjectID was generated.

---

### 8. Validating ObjectIDs

Mongoose provides a static method to validate if a string is a valid ObjectID.

-------------------code----------------------
const isValid = mongoose.Types.ObjectId.isValid('1234');
console.log(isValid); // false
-------------------code----------------------

---

### 9. Summary

* MongoDB ObjectIDs are 12-byte identifiers that are almost always unique.
* Structure: 4 bytes timestamp + 3 bytes machine ID + 2 bytes process ID + 3 bytes counter.
* Generated by the MongoDB driver (client-side), not the database.
* Ensures scalability without relying on a central unique ID generator.
* You can generate, inspect, and validate ObjectIDs directly using Mongoose.

---
