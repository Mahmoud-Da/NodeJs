*** 1- Modelling Relationships ***
### Lecture Notes: Working with Related Objects in MongoDB

#### 1. Introduction

* In previous examples, we worked with single, self-contained documents.
* In real-world applications, entities are often related.

  * Example: A **course** has an **author**.
  * An author is more than a name; it may include fields such as `name`, `website`, `image`, etc.
* MongoDB allows two main approaches for modeling such relationships:

  1. **Using References (Normalization)**
  2. **Using Embedded Documents (Denormalization)**

---

#### 2. Approach 1: Using References (Normalization)

* Each entity has its own collection:

  * `authors` collection → stores author documents.
  * `courses` collection → stores course documents with an **author ID reference**.
* Example:

  -------------------code----------------------
  author: ObjectId("12345")
  -------------------code----------------------
* This means the course refers to an author document by its ID.

**Key Points:**

* In **relational databases**, relationships enforce data integrity.
* In **MongoDB**, relationships are **not enforced**.

  * MongoDB will not check if the referenced ID exists or is valid.
* A course can have **multiple authors** by storing an array of author IDs.

**Advantages:**

* **Consistency:** There is a single source of truth for each author.

  * Changing an author’s name automatically affects all referencing courses.

**Disadvantages:**

* **Performance:** Requires multiple queries.

  * You must query the author separately when loading a course.

---

#### 3. Approach 2: Using Embedded Documents (Denormalization)

* Instead of a separate collection, embed the author document directly inside the course document.
* Example:

  -------------------code----------------------
  {
    title: "Course A",
    author: {
      name: "Mosh",
      website: "example.com"
    }
  }
  -------------------code----------------------

**Advantages:**

* **Performance:** Only one query is needed to retrieve a course and its author.
* Ideal when query speed is critical.

**Disadvantages:**

* **Inconsistency:**

  * If an author’s name changes, it must be updated in multiple documents.
  * If updates fail, data may become inconsistent.

---

#### 4. Trade-off Between Consistency and Performance

| Approach                   | Consistency | Performance                 |
| -------------------------- | ----------- | --------------------------- |
| References (Normalization) | High        | Lower (needs extra queries) |
| Embedded (Denormalization) | Lower       | High (fewer queries)        |

* You must decide which is more important based on your application’s needs.
* Always design your schema with **query requirements** in mind.

---

#### 5. Approach 3: Hybrid Approach

* Combines both normalization and denormalization.
* Example:

  * Maintain a separate `authors` collection with full author details.
  * In each `course` document, embed only **partial author data** (e.g., `id` and `name`).

  -------------------code----------------------
  {
    title: "Course A",
    author: {
      id: ObjectId("12345"),
      name: "Mosh"
    }
  }
  -------------------code----------------------

**Advantages:**

* Balances **query performance** and **data consistency**.
* Avoids full data duplication.
* Useful for maintaining **data snapshots**.

**Example Use Case:**

* **E-commerce orders:**

  * You want to store the product details (e.g., price) at the time of purchase.
  * Even if the product price changes later, the order should retain the original data.

---

#### 6. Summary

* **Normalization (References):**

  * Pros: Data consistency, single source of truth.
  * Cons: Slower queries, multiple lookups.
* **Denormalization (Embedded Documents):**

  * Pros: Faster reads, fewer queries.
  * Cons: Risk of inconsistent data on updates.
* **Hybrid Approach:**

  * Mix of both methods for balance and flexibility.
* The choice depends entirely on the **application’s design and query patterns**.

---

#### 7. Next Steps

* The following lectures will cover practical implementation of:

  1. Normalized relationships
  2. Denormalized relationships
  3. Hybrid structures

*** 2- Referencing Documents ***
### Lecture Notes: Referencing Documents in MongoDB

#### 1. Overview

* In this lecture, the goal is to **reference one document from another** in MongoDB using **Mongoose**.
* We’ll use a file named **`population.js`** that contains two models:

  1. **Author** model – with properties: `name`, `bio`, and `website`.
  2. **Course** model – with property: `name`.
* We will add an additional property `author` to the **Course** model to reference an **Author** document.

---

#### 2. Preparation Steps

1. Open **MongoDB Compass**.
2. **Delete the “playground” database** to start fresh.

   * Type `playground` in the search field and delete the database.
3. Open the terminal in the project directory.

---

#### 3. Creating the Author

* At the bottom of `population.js`, there is a call to `createAuthor()`.

  -------------------code----------------------
  createAuthor('Mosh', 'Author bio', 'Website URL');
  -------------------code----------------------
* Run the following command in the terminal:

  -------------------code----------------------
  node population.js
  -------------------code----------------------
* This will create one **Author** document and return its **Object ID** in the terminal.

**Example output:**

-------------------code----------------------
Author created:
{
  _id: 665abc12345,
  name: "Mosh",
  bio: "...",
  website: "..."
}
-------------------code----------------------

* Copy the **author ID** from the terminal for the next step.

---

#### 4. Creating the Course and Referencing the Author

* Comment out the `createAuthor()` line in the code.
* Uncomment or enable the `createCourse()` call, passing the **author ID** as a string.

Example:

-------------------code----------------------
createCourse('Node Course', '665abc12345');
-------------------code----------------------

* The `createCourse()` function creates a course object with two properties:

  -------------------code----------------------
  name: "Node Course"
  author: "665abc12345"
  -------------------code----------------------

* Run the script again:

  -------------------code----------------------
  node population.js
  -------------------code----------------------

* You will see the created course ID and name in the terminal, but not the author.

---

#### 5. Updating the Course Model to Include the Author Reference

* The reason the author was not saved is that the **Course schema** only included the `name` property.
* You must explicitly define the `author` field in the schema.

Update the Course schema as follows:

-------------------code----------------------
const courseSchema = new mongoose.Schema({
  name: String,
  author: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Author'
  }
});
-------------------code----------------------

**Explanation:**

* `type: mongoose.Schema.Types.ObjectId` → defines the data type as an **Object ID**.
* `ref: 'Author'` → indicates that this field references the **Author** collection.

---

#### 6. Running the Updated Code

* Save the file and re-run the script:

  -------------------code----------------------
  node population.js
  -------------------code----------------------
* Output example:

  -------------------code----------------------
  Course created:
  {
    _id: 665def67890,
    name: "Node Course",
    author: "665abc12345"
  }
  -------------------code----------------------

---

#### 7. Verifying in MongoDB Compass

* Open **MongoDB Compass** and check the **“playground”** database.
* Navigate to the **courses** collection.
* You will now see two course documents:

  1. The first (older) one has no author.
  2. The second (new) one includes an `author` field with an **Object ID** reference.

Example:

-------------------code----------------------
{
  "_id": ObjectId("665def67890"),
  "name": "Node Course",
  "author": ObjectId("665abc12345")
}
-------------------code----------------------

---

#### 8. Key Takeaways

* Defining a reference in Mongoose requires specifying both **type** and **ref** in the schema.
* MongoDB does **not enforce foreign key relationships**.

  * You can store an invalid or non-existent author ID, and MongoDB will not raise an error.
* Referencing is useful when you want **consistency** and to avoid duplicating data across collections.

---

#### 9. Summary of Steps

1. Create and save an **Author** document.
2. Copy the author’s ID.
3. Add an **author** field to the **Course** schema using `ObjectId` and `ref`.
4. Create a **Course** document with the author’s ID.
5. Verify the stored relationship in **MongoDB Compass**.

This sets the foundation for learning how to populate referenced documents, which will be covered in upcoming lectures.

*** 3- Population ***

### Lecture Notes: Populating Referenced Documents in MongoDB

#### 1. Introduction

* The goal of this lecture is to **load related documents** in MongoDB using **Mongoose’s `populate()` method**.
* We will retrieve all courses along with their corresponding authors.

---

#### 2. Preparing the Code

* In the `population.js` file, scroll to the bottom where the `listCourses()` function is defined.
* Enable this function call to execute it when running the script.
* Inside the function, the code retrieves all courses from the database:

  -------------------code----------------------
  const courses = await Course.find().select('name');
  -------------------code----------------------
* Run the script in the terminal:

  -------------------code----------------------
  node population.js
  -------------------code----------------------
* Output: only the `_id` and `name` fields of each course are shown.

---

#### 3. Including the Author Field

* Modify the code to also select the `author` field:

  -------------------code----------------------
  const courses = await Course.find().select('name author');
  -------------------code----------------------
* Run the script again.
* Now, the output shows each course’s `_id`, `name`, and `author` fields.
* However, the `author` currently appears only as an **ObjectId** reference.

---

#### 4. Using the `populate()` Method

* To load full author details instead of just the ObjectId, use the `populate()` method:

  -------------------code----------------------
  const courses = await Course
    .find()
    .select('name author')
    .populate('author');
  -------------------code----------------------
* **Explanation:**

  * `populate('author')` tells Mongoose to replace the `author` ObjectId with the actual author document.
  * When defining the Course schema, the `author` field was declared as:

    -------------------code----------------------
    author: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Author'
    }
    -------------------code----------------------

    This `ref` allows Mongoose to know which collection to query when populating.

---

#### 5. Running the Code

* Run again in the terminal:

  -------------------code----------------------
  node population.js
  -------------------code----------------------
* Output:

  * Courses without an author show no `author` field.
  * Courses with an author now display the full author document (e.g., `name`, `bio`, `website`).

---

#### 6. Selecting Specific Author Properties

* In real-world scenarios, authors may have many properties.
* When listing courses, you may not want to retrieve all of them.
* You can limit which fields to populate by adding a **second argument** to `populate()`:

  -------------------code----------------------
  const courses = await Course
    .find()
    .select('name author')
    .populate('author', 'name');
  -------------------code----------------------
* Run again:

  * The output now includes only `name` and `_id` for the author.

---

#### 7. Excluding the Author’s `_id`

* To exclude a property, prefix it with a minus (`-`):

  -------------------code----------------------
  const courses = await Course
    .find()
    .select('name author')
    .populate('author', 'name -_id');
  -------------------code----------------------
* Run again:

  * The author object now contains only the `name` field.

---

#### 8. Populating Multiple References

* You can populate more than one field by chaining multiple `populate()` calls.
* Example (if `course` also has a `category` field):

  -------------------code----------------------
  const courses = await Course
    .find()
    .select('name author category')
    .populate('author', 'name -_id')
    .populate('category', 'name');
  -------------------code----------------------
* Each `populate()` specifies which related document and fields to include.

---

#### 9. Handling Invalid References

* MongoDB does **not enforce relationships** for data integrity.
* You can assign an invalid ObjectId as a reference without error.
* Example: if you modify a course’s author ID to an invalid one in MongoDB Compass (e.g., change `0c` to `1c`),
  MongoDB will accept it without complaint.
* When running the script again:

  -------------------code----------------------
  node population.js
  -------------------code----------------------

  The result shows:

  -------------------code----------------------
  "author": null
  -------------------code----------------------

  because Mongoose cannot find a matching author document.

---

#### 10. Key Takeaways

* `.populate()` is used to load referenced documents automatically.
* You can control which fields to include or exclude using the second argument of `populate()`.
* Multiple `populate()` calls can load different related fields.
* MongoDB allows invalid references; Mongoose will simply return `null` for those.
* Always design your schema and queries based on your application’s data integrity requirements.

---

#### 11. Summary of the `listCourses()` Function Example

Final version of the function:

-------------------code----------------------
async function listCourses() {
  const courses = await Course
    .find()
    .select('name author')
    .populate('author', 'name -_id');
  console.log(courses);
}
-------------------code----------------------

**Result:**
Courses are listed with each author’s name, while ignoring unnecessary fields and invalid references.


*** 4- Embedding Documents ***
**Lecture Notes: Embedding Documents in MongoDB (Mongoose)**

---

### 1. Overview

In this lecture, we learn an alternative to referencing documents: **embedding documents**.
Embedding allows us to store a document directly inside another document as a **subdocument**.

---

### 2. Setup

* File used: **embedding.js**
* Existing structure:

  * **Author Schema**: `name`, `bio`, `website`
  * **Course Schema**: currently has only `name`

We will modify the **Course Schema** to embed an author document.

---

### 3. Embedding the Author Schema

Previously, in the reference model, we defined:

-------------------code----------------------
author: {
  type: mongoose.Schema.Types.ObjectId,
  ref: 'Author'
}
-------------------code----------------------

Now, we replace that with:

-------------------code----------------------
author: authorSchema
-------------------code----------------------

This embeds the entire author object inside the course document rather than just its reference ID.

---

### 4. Creating a Course with Embedded Author

* The `createCourse` function initializes a new course with an embedded author and saves it.
* Before running, clear the database in MongoDB Compass for a clean start.

Run in terminal:

-------------------code----------------------
node embedding.js
-------------------code----------------------

**Result:**
The course document will include:

-------------------code----------------------on
{
  "_id": "...",
  "name": "Node Course",
  "author": {
    "_id": "...",
    "name": "Mosh"
  }
}
-------------------code----------------------

Here, `author` is a **subdocument**.

---

### 5. Subdocument Behavior

* Subdocuments behave like normal documents:

  * Support **validation**.
  * Can have **required** fields.
* However, **they cannot be saved independently** — only within their parent document.

---

### 6. Updating a Subdocument (Method 1)

To update an embedded author’s name:

-------------------code----------------------
async function updateAuthor(courseId) {
  const course = await Course.findById(courseId);
  course.author.name = "Mosh Hamidani";
  await course.save();
}
-------------------code----------------------

Run:

-------------------code----------------------
node embedding.js
-------------------code----------------------

Check in MongoDB Compass:
The embedded author’s name should now be **"Mosh Hamidani"**.

---

### 7. Updating a Subdocument (Method 2 — Direct Update)

You can update without fetching the document first:

-------------------code----------------------
await Course.updateOne(
  { _id: courseId },
  { $set: { "author.name": "John Smith" } }
);
-------------------code----------------------

This modifies the subdocument directly in the database.

---

### 8. Removing a Subdocument

To remove an embedded document or a specific field, use `$unset`:

-------------------code----------------------
await Course.updateOne(
  { _id: courseId },
  { $unset: { author: "" } } // removes the entire author object
);
-------------------code----------------------

After running:

-------------------code----------------------
node embedding.js
-------------------code----------------------

Check Compass — the `author` field will no longer exist.

---

### 9. Validation for Embedded Documents

You can enforce validation on subdocuments just like top-level documents.

**Example:**

To make `author` required in the course schema:

-------------------code----------------------
author: {
  type: authorSchema,
  required: true
}
-------------------code----------------------

To make a specific property (like `author.name`) required:

-------------------code----------------------
name: {
  type: String,
  required: true
}
-------------------code----------------------

---

### 10. Summary

| Feature      | Referencing                 | Embedding                      |
| ------------ | --------------------------- | ------------------------------ |
| Relationship | Uses ObjectId reference     | Directly includes the document |
| Querying     | Requires population         | No need for population         |
| Performance  | Good for large, shared data | Faster read for related data   |
| Redundancy   | Minimal                     | May have duplicate data        |
| Independence | Documents separate          | Embedded depends on parent     |

---

**Next Topic:** Working with an **array of subdocuments** in Mongoose.


*** 5- Using an Array of Sub-documents ***
**Lecture Notes: Working with Arrays of Subdocuments in MongoDB (Mongoose)**

---

### 1. Introduction

In the previous lecture, we learned how to embed a single author subdocument inside a course document.
In this lecture, we extend that idea to **an array of subdocuments**, allowing each course to have **multiple authors**.

---

### 2. Updating the Schema

**Before:**

-------------------code----------------------
author: authorSchema
-------------------code----------------------

**Now:**
We rename the property to `authors` and make it an array of subdocuments:

-------------------code----------------------
authors: [authorSchema]
-------------------code----------------------

This allows multiple author objects to be stored within a single course document.

---

### 3. Creating a Course with Multiple Authors

When creating a course, we now pass an array of authors:

-------------------code----------------------
async function createCourse(name, authors) {
  const course = new Course({
    name,
    authors
  });
  await course.save();
}
-------------------code----------------------

Example usage:

-------------------code----------------------
createCourse("Node Course", [
  { name: "Mosh" },
  { name: "John" }
]);
-------------------code----------------------

---

### 4. Resetting the Database

Before running the code, open **MongoDB Compass**, delete the current `courses` collection, and then run:

-------------------code----------------------
node embedding.js
-------------------code----------------------

**Result:**
Each course document will now contain an array of author objects:

-------------------code----------------------on
{
  "_id": "...",
  "name": "Node Course",
  "authors": [
    { "_id": "...", "name": "Mosh" },
    { "_id": "...", "name": "John" }
  ]
}
-------------------code----------------------

---

### 5. Adding an Author to the Array

To add a new author after a course already exists:

-------------------code----------------------
async function addAuthor(courseId, author) {
  const course = await Course.findById(courseId);
  course.authors.push(author);
  await course.save();
}
-------------------code----------------------

Example call:

-------------------code----------------------
addAuthor("66a3c...", { name: "Amy" });
-------------------code----------------------

**Steps:**

1. Find the course using its ID.
2. Push the new author object into the `authors` array.
3. Save the updated course document.

After running:

-------------------code----------------------
node embedding.js
-------------------code----------------------

Check in MongoDB Compass — the course document now includes the new author `Amy`.

---

### 6. Removing an Author from the Array

To remove an existing author:

-------------------code----------------------
async function removeAuthor(courseId, authorId) {
  const course = await Course.findById(courseId);
  const author = course.authors.id(authorId);
  author.remove();
  await course.save();
}
-------------------code----------------------

Example call:

-------------------code----------------------
removeAuthor("66a3c...", "66a4f...");
-------------------code----------------------

NOTE: for new version of mongoose the remove method is deprecated
so we have two ways:
-------------------code----------------------
1- using filter JS method

 async function removeAuthor(courseId, authorId) {
  const course = await Course.findById(courseId);
  if (!course) return console.log("Course not found");

  // Filter out the author by ID
  course.authors = course.authors.filter(a => a._id.toString() !== authorId);
  
  await course.save();
  console.log("Author removed successfully");
}
-------------------code----------------------

2- using mongoose "pull()" method
-------------------code----------------------
async function removeAuthor(courseId, authorId) {
  const course = await Course.findById(courseId);
  if (!course) return console.log("Course not found");

  course.authors.pull({ _id: authorId }); // removes matching subdocument
  await course.save();
  console.log("Author removed successfully");
}
-------------------code----------------------


- pull() vs filter():

| Aspect                   | `.pull()`                                                    | `.filter()`                                         |
| ------------------------ | ------------------------------------------------------------ | --------------------------------------------------- |
| **Performance**          | ⚡ Slightly faster (internally optimized for Mongoose arrays) | A bit slower (creates a new array and reassigns it) |
| **Readability**          | Cleaner, more expressive for removing subdocs                | Slightly more verbose                               |
| **Mongoose integration** | Fully aware of subdocument tracking and change detection     | Works fine, but you rely on manual reassignment     |
| **Mutation**             | Mutates the array in place                                   | Creates a new array (non-mutating)                  |


**Explanation:**

* `course.authors.id(authorId)` retrieves the embedded author by its `_id`.
* `author.remove()` removes that specific subdocument from the array.
* Finally, `course.save()` persists the changes.

After running:

-------------------code----------------------
node embedding.js
-------------------code----------------------

In MongoDB Compass, refresh the collection — the specified author will be removed.

---

### 7. Key Notes on Arrays of Subdocuments

| Operation           | Method                    |
| ------------------- | ------------------------- |
| Add new subdocument | `array.push(subdocument)` |
| Remove by ID        | `array.id(id).remove()`   |
| Save changes        | `document.save()`         |

**Characteristics:**

* Subdocuments in arrays are fully functional Mongoose documents.
* They support validation and schema rules.
* They cannot be saved independently; they must be saved through their parent.

---

### 8. Summary

* Changed a single embedded document into an **array of subdocuments**.
* Learned how to **add** and **remove** authors within that array.
* Used Mongoose methods like `.push()`, `.id()`, and `.remove()` to manipulate nested data.

---

### 9. Next Lecture

In the next lecture, we will discuss **design trade-offs between embedding and referencing** — when to use each approach depending on the application’s requirements.
