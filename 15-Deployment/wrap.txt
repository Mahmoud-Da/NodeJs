*** 1- Introduction ***
---

## Deploying Node Applications

### Overview

There are two primary options for deploying Node applications:

1. Using a Platform-as-a-Service (PaaS) provider
2. Using Docker

---

## 1. Platform-as-a-Service (PaaS)

### Definition

A PaaS provider handles most of the infrastructure tasks for you.

### When to Use

Choose a PaaS if you do not want to manage:

* Servers
* Load balancers
* Reverse proxies
* Application restarts after crashes

### Common Providers

* Heroku
* Google Cloud Platform
* AWS
* Azure

Different developers prefer different providers, but Heroku is used in this course because:

* It is easy to start with
* It has strong documentation
* It provides a comprehensive set of features

### Summary

Use a PaaS if you prefer simplicity and do not want to deal with infrastructure details.

---

## 2. Docker Deployment

### Definition

Docker allows you to package your application into an image.

### When to Use

Use Docker if you:

* Want full control over your deployment
* Want to deploy to your own web servers
* Need consistent environments across machines

### How It Works

You build a Docker image of your application and deploy that image to any server you choose.

---

## Focus of This Section

This section focuses on deploying Node applications to **Heroku**.

---

*** 2- Preparing the App for Production ***
---

## Preparing a Node Application for Production

### Purpose

Before deploying the application, certain production-ready middleware should be added to improve security and performance.

---

## Required Production Packages

### 1. Helmet

* Installed using: `npm install helmet`
* Purpose: Provides security by protecting the application from well-known web vulnerabilities.
* Previously introduced in the "Express Advanced Topics" section.

### 2. Compression

* Installed using: `npm install compression`
* Purpose: Compresses HTTP responses to reduce bandwidth and improve performance.

---

## Creating the Production Startup Module

### File Setup

* Create a new file: `startup/prd.js`
* This file will contain all middleware used specifically for the production environment.

### Module Implementation

Steps inside `prod.js`:

1. Import the required packages:

   -------------------code----------------------
   const helmet = require('helmet');
   const compression = require('compression');
   -------------------code----------------------

2. Export a function that takes the Express `app` object:

   -------------------code----------------------
   module.exports = function(app) {
       app.use(helmet());
       app.use(compression());
   };
   -------------------code----------------------

3. Both `helmet` and `compression` are functions, so they must be called before passing to `app.use`.

---

## Registering the Production Module

### Modifying `index.js`

* Import the production startup module:
* Call the function and pass in the Express application object:

  -------------------code----------------------
  require("./startup/prod")(app);
  -------------------code----------------------

### Conditional Loading (Optional)

* It is possible to load this module only when `NODE_ENV` is set to `production`, but for this course it is not essential.

---

## Summary

* Installed security and performance-related middleware.
* Organized production-specific configuration inside `startup/prd.js`.
* Registered the production middleware in the main entry module.
* The application is now prepared for deployment.

Next, the lecture moves on to deployment using Heroku.


*** 3- Getting Started with Heroku ***
---

## Deploying the Vidly Application to Heroku

### Overview

To deploy a Node application to Heroku, you must complete two initial setup steps:

1. Create a Heroku account
2. Install the Heroku CLI

---

## 1. Creating a Heroku Account

* Go to the Heroku website.
* Registration is simple, free, and takes only a few seconds.

---

## 2. Installing the Heroku CLI

### How to Install

* Search for "Heroku CLI" in your browser.
* Open the first link.
* Download the installer for your operating system.

### Example Installation Methods

* macOS: Can install easily using Homebrew.
* Windows and Linux: Use the platform-specific installer provided on the site.

---

## 3. Verifying Installation

After installation, open the terminal and run:

-------------------code----------------------
heroku -v
-------------------code----------------------

* This prints the installed CLI version.
* Even if an update is available, the commands shown in the lecture work with different versions.

---

## 4. Logging into Heroku

Use the following command:

-------------------code----------------------
heroku login
-------------------code----------------------

* Enter the email and password used for your Heroku account.
* Successful login will display a confirmation message.

---

## 5. Handling Login Issues (Proxy Settings)

If login fails due to a firewall or proxy:

### Set the Proxy Environment Variable

For macOS or Linux:

-------------------code----------------------
export HTTP_PROXY=http://proxy.server.com:port
-------------------code----------------------

For Windows:

-------------------code----------------------
set HTTP_PROXY=http://proxy.server.com:port
-------------------code----------------------

After setting the proxy variable, run `heroku login` again.

---

## Summary

* Create a Heroku account.
* Install and verify the Heroku CLI.
* Log in using your Heroku credentials.
* If behind a firewall, configure proxy settings.
* After these steps, the application will be ready for deployment preparation.

Next steps involve preparing the Vidly application for deployment to Heroku.


*** 4- Preparing the App for Heroku ***

---

## Preparing the Application for Deployment to Heroku

To deploy a Node application to Heroku, a few key updates must be made in `package.json`.

---

## 1. Define the Start Script

### Why This Is Needed

* Heroku starts applications by running `npm start`.
* If no `start` script is defined in `package.json`, Heroku will not know how to launch the app.

### Action

In `package.json`, under the `scripts` section, add:

-------------------code----------------------
"start": "node index.js"
-------------------code----------------------

Notes:

* Use `node`, not `nodemon`.
* `nodemon` is for development only; it watches file changes and restarts automatically.
* Production should always use `node`.

### Test Locally

Run:

-------------------code----------------------
npm start
-------------------code----------------------

You should see confirmation that the application starts and listens on port 3000.

---

## 2. Specify the Node Version (Engines Section)

### Why This Is Needed

* Heroku uses this information to match your Node runtime environment.
* Ensures your application runs with the correct version of Node.

### Action

1. Check your local Node version:

   -------------------code----------------------
   node -v
   -------------------code----------------------
2. Add the `engines` section in `package.json`:

-------------------code----------------------
"engines": {
  "node": "your_version_here"
}
-------------------code----------------------

Example:

-------------------code----------------------
"node": "8.9.1"
-------------------code----------------------

Use your actual version.

---

## Summary

To make the application ready for Heroku deployment:

1. Add a `start` script to run `node index.js` in production.
2. Add an `engines` section to specify the Node version.

With these changes, the application is fully prepared for deployment to Heroku.

PS: when we have error to let the nodemon to stop restarts during development

Create a nodemon.json file:
-------------------code----------------------
{
  "ignore": ["*.log"]
}
-------------------code----------------------

This prevents nodemon from restarting when log files change.

*** 5- Adding the Code to a Git Repository  ***


---

## Preparing the Application for Deployment to Heroku with Git

Before deploying to Heroku, the application must be inside a Git repository.

---

### 1. Install Git

* Go to [git-scm.com](https://git-scm.com) and download the installer for your operating system.
* After installation, verify it by running:

-------------------code----------------------
git --version
-------------------code----------------------

---

### 2. Initialize a Git Repository

In the root of your project folder (`vidly`), run:

-------------------code----------------------
git init
-------------------code----------------------

* This creates an empty Git repository in your project.

---

### 3. Create a `.gitignore` File

* In the root of your project, create a file named `.gitignore`.
* Purpose: Exclude certain files and folders from being tracked by Git.

Example contents:

-------------------code----------------------
node_modules/
coverage/
-------------------code----------------------

* `node_modules/` is excluded because it contains thousands of files and can be restored using `npm install`.
* `coverage/` is excluded because it contains code coverage reports generated by tests.

---

### 4. Stage Files for Commit

Run:

-------------------code----------------------
git add .
-------------------code----------------------

* Stages all files for commit, except those listed in `.gitignore`.

---

### 5. Commit the Changes

Run:

-------------------code----------------------
git commit -m "First commit"
-------------------code----------------------

* Creates the initial commit in your repository with the message `"First commit"`.

---

### Next Steps

* In the next lecture, you will learn how to use the **Heroku CLI** to deploy the application.

*** 6- Deploying to Heroku ***
---

## Deploying the Application to Heroku

Now that the source code is in a Git repository, we can deploy it to Heroku using the Heroku CLI.

---

### 1. Create a Heroku Application

Run:

-------------------code----------------------
heroku create
-------------------code----------------------

* This command does two things:

  1. Creates a new application on Heroku.
  2. Creates a Git remote called `heroku` in your local repository.

* You can optionally provide a name for the app:

-------------------code----------------------
heroku create vidly
-------------------code----------------------

* The name must be unique. If the name is taken, Heroku will assign a random name.
* After creation, Heroku provides:

  * The URL of your application: `https://your-app-name.herokuapp.com`
  * The Git repository URL: `git@heroku.com:your-app-name.git`

---

### 2. Verify the Git Remote

Run:

-------------------code----------------------
git remote -v
-------------------code----------------------

* You should see the `heroku` remote pointing to your Heroku repository.

---

### 3. Deploy the Application

Run:

-------------------code----------------------
git push heroku master
-------------------code----------------------

* **git push**: Pushes changes from the local repository.
* **heroku**: The remote repository you want to push to.
* **master**: The branch containing the latest code (default in Git).

Heroku will then:

1. Install the Node engine version specified in `package.json`.
2. Install dependencies (`node_modules`).
3. Deploy the application.

---

### 4. Test the Application

* Copy the Heroku app URL.
* Open Postman or a browser and send a request to your API endpoint, for example:

-------------------code----------------------
https://your-app-name.herokuapp.com/api/genres
-------------------code----------------------

* You may sometimes see a **503 Service Unavailable** error.

  * This is common and usually related to configuration or startup issues.
  * In the next lecture, you will learn how to **check logs on Heroku** to diagnose and fix problems.

---

### Notes

* Every time you make changes to your application:

  1. Commit the changes in your local Git repository.
  2. Push them to Heroku using `git push heroku master`.
* Heroku automatically redeploys the updated code when pushed.

*** 7- Viewing Logs ***
---

## Diagnosing Application Crashes on Heroku

When a deployed application crashes, you can use logs to identify the cause.

---

### 1. Checking Logs in the Terminal

* Run the command:

-------------------code----------------------
heroku logs
-------------------code----------------------

* Scroll through the output to find the error.
* Example:

-------------------code----------------------
Process exited with status 1
JWT private key is not defined
-------------------code----------------------

* This shows the stack trace and error messages.
* The terminal logs are usually easier to read than the dashboard logs.

---

### 2. Checking Logs via the Heroku Dashboard

* Open your application in the Heroku dashboard.
* Click **More → View Logs**.
* Logs in the dashboard may not always show detailed application errors.

---

### 3. Understanding the Difference Between Logs

* **Heroku logs**: Show system-level logs, app crashes, and console output.
* **Application logs**: Generated by Winston (or another logger) within your app, e.g., `uncaughtExceptions.log`.

---

### 4. Viewing Application Logs on Heroku

Two options:

1. **Using SSH (Heroku Dyno)**:

   * Connect to the server:

     -------------------code----------------------
     heroku run bash
     -------------------code----------------------

   * List files:

     -------------------code----------------------
     ls
     -------------------code----------------------

   * View the log:

     -------------------code----------------------
     cat uncaughtExceptions.log
     -------------------code----------------------

   * Or use `less uncaughtExceptions.log` for easier reading.

2. **Using Dashboard Console**:

   * Click **More → Run Console → Bash**.
   * Navigate and read the log as above.

---

### 5. Identifying the Cause

* Example error from the log:

-------------------code----------------------
JWT private key is not defined
-------------------code----------------------

* This indicates a missing **environment variable** that the application depends on.

* The next step is to define the required environment variables to prevent crashes.


*** 8- Setting Environment Variables ***
---

## Setting Environment Variables on Heroku

Heroku allows you to define environment variables for your application using the Heroku CLI.

---

### 1. Setting Environment Variables

Use the command:

-------------------code----------------------
heroku config:set VAR_NAME=value
-------------------code----------------------

* Example for your application:

-------------------code----------------------
heroku config:set vidly_JWT_PRIVATE_KEY=your_jwt_secret
heroku config:set NODE_ENV=production
-------------------code----------------------

* `NODE_ENV=production` improves performance and reduces verbose logging.
* Environment variables are **case sensitive**. Always use the correct casing.

---

### 2. Viewing Environment Variables

Run:

-------------------code----------------------
heroku config
-------------------code----------------------

* Displays all environment variables set for the application.
* Example output:

-------------------code----------------------
NODE_ENV: production
vidly_JWT_PRIVATE_KEY: your_jwt_secret
-------------------code----------------------

---

### 3. How Environment Variables Work on Heroku

* Heroku applications run on servers called **dynos**.
* Each dyno has a **temporary file system** that is wiped when restarted.
* Dynos share only **environment variables**, which are replicated automatically across all dynos.
* Setting variables at the application level means you do **not** need to configure each dyno individually.
* Any changes to environment variables automatically restart the application.

---

### 4. Common Issues

* After setting environment variables, your app may still crash if it depends on services not available in Heroku.
* Example:

-------------------code----------------------
MongoNetworkError: failed to connect to server
-------------------code----------------------

* Cause: The connection string points to `localhost`, but Heroku does not have a local MongoDB instance by default.
* Resolution: Connect to a cloud-hosted MongoDB service. This will be covered in the next lecture.


*** 9- MongoDB in the Cloud ***
---

## Creating a MongoDB Database in the Cloud and Connecting It to Heroku
---

### 1. Using Add-ons in Heroku

* Go to your application dashboard → **Resources** tab → **Add-ons**.
* Click **Find more add-ons**.
* Categories include: data stores, monitoring, logging, email/SMS, caching, metrics, analytics, etc.
* Example add-on: **mLab** for MongoDB.

  * Free tier available, but installing through Heroku may require a credit card.
  * Alternative: create a free account directly on [mlab.com](https://mlab.com).

---

### 2. Creating a Cloud MongoDB Database

1. Log in to mLab and click **Create New Deployment**.
2. Choose a cloud provider: AWS, Google Cloud, or Azure.
3. Select **Sandbox plan** (completely free).
4. Select region (e.g., California for AWS).
5. Name your database (e.g., `vidly`).
6. Submit and the database is created.

---

### 3. Creating a Database User

* Go to **Users** tab → **Create User**.
* Example:

-------------------code----------------------
Username: vidly_user
Password: 1234
-------------------code----------------------

* Note: Password used here is only for demo purposes.

---

### 4. Configuring the Connection String

* On the database page, copy the MongoDB connection string.
* Modify it with your username and password.
* **Do not store credentials in source code**. Use environment variables instead.

---

### 5. Setting Environment Variables on Heroku

1. Open **Custom Environment Variables** in Heroku dashboard.
2. Add a key-value pair:

-------------------code----------------------
Key: VIDLY_DB
Value: <MongoDB connection string>
-------------------code----------------------

* Alternatively, using CLI:

-------------------code----------------------
heroku config:set VIDLY_DB="mongodb://vidly_user:1234@<host>/<database>"
-------------------code----------------------

* This ensures the application can access the database in production.

---

### 6. Updating Application Code

* Modify `config/default.json` to use the environment variable `VIDLY_DB` for production.
* Stage and commit the changes:

-------------------code----------------------
git add .
git commit -m "Add support for connection string via environment variable"
-------------------code----------------------

* Push to Heroku:

-------------------code----------------------
git push heroku master
-------------------code----------------------

---

### 7. Testing the Application

1. Check Heroku logs:

-------------------code----------------------
heroku logs --tail
-------------------code----------------------

* Confirm the app connects to MongoDB and listens on the dynamically assigned port.

2. Test API in Postman:

* GET request to `/api/genres` should return an empty array (new database).

3. Creating a new user:

* POST request to `/api/users` with JSON body:

-------------------code----------------------
{
  "name": "Mosh Hamidani",
  "email": "programmingwithmosh@gmail.com",
  "password": "12345"
}
-------------------code----------------------

* Copy the authentication token from the response.

4. Adding a new genre:

* POST request to `/api/genres` with body:

-------------------code----------------------
{
  "name": "Thriller"
}
-------------------code----------------------

* Include the token in header `x-auth-token`.
* Response shows the new genre stored in MongoDB.

---

### Summary

* Created a cloud MongoDB database using mLab.
* Set up a database user and connection string as environment variables.
* Updated source code to use environment variables for production.
* Deployed updated application to Heroku.
* Successfully tested creating users and genres via API.

---

