*** 1- Introduction ***
**Lecture Notes: Express Framework Introduction**

**1. Recap of the HTTP Module**

* In Section 2, we learned about Node’s module system and the use of the built-in **HTTP module**.
* The HTTP module allows us to create a **web server** that listens on a specific port (e.g., port **3000**) and responds to requests sent to various **endpoints** such as:

  * `/` (root)
  * `/api/courses`

**2. Limitation of the HTTP Module Approach**

* While using the HTTP module directly works for small projects, it becomes inefficient and difficult to manage in **large or complex applications**.
* The main problem is the need to **hard-code multiple `if` statements** to handle different routes and endpoints, which quickly makes the code messy and hard to maintain.

**3. Introduction to Express**

* **Express** is a **fast, lightweight, and flexible framework** for building web applications and APIs in Node.js.
* It simplifies the process of:

  * Handling routes
  * Managing HTTP requests and responses
  * Organizing code in a clean and modular way

**4. Next Topic**

* The next section will cover **RESTful services**, a key concept in building structured and scalable web APIs using Express.


*** 2- RESTful Services ***
**Lecture Notes: Introduction to RESTful Services (RESTful APIs)**

**1. Overview**

* REST stands for **Representational State Transfer**.
* RESTful services (or RESTful APIs) are a **convention for building HTTP services** that enable communication between clients (frontends) and servers (backends).
* These services allow applications to **create, read, update, and delete (CRUD)** data using standard **HTTP protocol** principles.

---

**2. Client-Server Architecture Recap**

* Most modern applications follow the **client-server model**.

  * **Client (frontend)**: The app users interact with.
  * **Server (backend)**: Manages and provides data or functionality.
* Communication between the client and server occurs through **HTTP requests**, the same protocol used for web browsing.
* The server exposes services (APIs) that clients can call to perform actions such as retrieving or saving data.

---

**3. Purpose of REST**

* REST provides a **standardized convention** for designing and accessing these HTTP services.
* It allows developers to use existing HTTP methods to perform CRUD operations:

  * **Create** → `POST`
  * **Read** → `GET`
  * **Update** → `PUT`
  * **Delete** → `DELETE`

---

**4. Example: Vidly Movie Rental Company**
Imagine a company called **Vidly** that rents movies.

* The client app manages a list of customers.
* The server exposes a RESTful service at an endpoint like:

  -------------------code----------------------
  https://vidly.com/api/customers
  -------------------code----------------------

**Endpoint Structure Explained:**

1. **HTTP or HTTPS:**

   * `HTTP` for normal communication.
   * `HTTPS` for secure communication (encrypted data transfer).
2. **Domain:**

   * Example: `vidly.com`
3. **/api:**

   * Common convention to indicate that the path refers to API services (optional but widely used).
   * Could also appear as a subdomain, e.g., `https://api.vidly.com/customers`
4. **/customers:**

   * Refers to a **resource** in the application.
   * In REST, resources represent data entities such as customers, movies, or rentals.

---

**5. HTTP Methods and Their Uses**

| Method     | Purpose       | Example Endpoint          | Description                                                                                  |
| ---------- | ------------- | ------------------------- | -------------------------------------------------------------------------------------------- |
| **GET**    | Retrieve data | `GET /api/customers`      | Returns a list of all customers.                                                             |
|            |               | `GET /api/customers/1`    | Returns details of a single customer by ID.                                                  |
| **POST**   | Create data   | `POST /api/customers`     | Creates a new customer; the client sends the customer object in the request body.            |
| **PUT**    | Update data   | `PUT /api/customers/1`    | Updates an existing customer; includes the full updated customer object in the request body. |
| **DELETE** | Remove data   | `DELETE /api/customers/1` | Deletes the customer with the specified ID.                                                  |

---

**6. Key Concepts in REST**

* **Resources:** Entities such as `customers`, `movies`, or `rentals` that the API exposes.
* **Endpoints:** URLs that represent these resources.
* **HTTP Methods (Verbs):** Indicate the desired operation (GET, POST, PUT, DELETE).
* **Request Body:** Data sent by the client when creating or updating a resource (POST and PUT).

---

**7. What We Will Build**

* In this section, we will use the **Express framework** to build a RESTful service for managing a list of customers.
* Instead of connecting to a database, we will use a **simple in-memory array** to store customer data for simplicity.
* Later in the course, we will integrate a **database** for persistent storage.

---

**Summary**

* REST is a structured way of building HTTP services that follow predictable patterns.
* Each resource is accessed through a meaningful endpoint and standard HTTP methods.
* Express simplifies the creation of RESTful APIs, allowing developers to easily define endpoints and handle requests.

*** 3- Introducing Express ***
**Lecture Notes: Introduction to Express Framework Setup**

**1. Recap of HTTP Module**

* In the earlier section about Node’s core modules, we used the **HTTP module** to create a basic web server.
* The server used a **callback function** that received two parameters:

  * **request (req):** Contains information about the incoming request, including the URL.
  * **response (res):** Used to send a response back to the client.
* Using the request object, we could check the URL and define routes, for example:

  * If the request URL is `/api/courses`, respond with a list of courses.

**2. Problem with This Approach**

* Although this method works, it quickly becomes **unmaintainable** as the application grows.
* Each new route requires another **if statement** in the callback function, making the code repetitive and hard to manage.

**3. The Need for a Framework**

* A **framework** provides structure and organization to the application.
* It allows us to:

  * Easily define multiple routes.
  * Keep the code clean and maintainable.
  * Focus on business logic instead of low-level HTTP handling.

**4. Introduction to Express**

* **Express** is the most popular framework for building web applications and servers in Node.js.
* It is known for being:

  * **Fast**
  * **Lightweight**
  * **Well-documented**
* According to npm statistics:

  * Over **700,000 downloads per day**.
  * Over **15 million downloads per month**.

**5. Setting Up an Express Project**

* Visit **npmjs.org** (or **npmjs.com**) to view details and documentation about Express.
* To start a new project:

  1. **Create a new folder** for the project:

     -------------------code----------------------
     mkdir express-demo
     -------------------code----------------------
  2. **Navigate into the folder:**

     -------------------code----------------------
     cd express-demo
     -------------------code----------------------
  3. **Initialize the project with npm:**

     -------------------code----------------------
     npm init -y
     -------------------code----------------------

     This creates a `package.json` file.
  4. **Install Express:**

     -------------------code----------------------
     npm install express
     -------------------code----------------------
* After installation, Express will be added as a dependency in the `package.json` file.

**6. Next Step**

* In the next lecture, you will learn how to **build your first web server using Express**.

*** 4- Building Your First Web Server ***
**Lecture Notes: Building the First Express Web Server**

---

### **1. Setting Up the File**

* Create a new file in VS Code named **`index.js`** (or **`app.js`**, the name does not matter).
* This file will contain the code for the Express application.

---

### **2. Loading and Initializing Express**

-------------------code----------------------
const express = require('express');
const app = express();
-------------------code----------------------

* The `require('express')` statement **loads the Express module**.
* Calling `express()` **returns an application object**, which represents the Express app.
* By convention, this object is stored in a constant named **`app`**.

---

### **3. Understanding Express Methods**

* The `app` object provides several methods that correspond to **HTTP verbs**:

  * `app.get()` → Handle HTTP **GET** requests
  * `app.post()` → Handle HTTP **POST** requests
  * `app.put()` → Handle HTTP **PUT** requests
  * `app.delete()` → Handle HTTP **DELETE** requests
* These methods are used to define **routes** (endpoints) for the application.

---

### **4. Defining the First Route**

-------------------code----------------------
app.get('/', (req, res) => {
  res.send('Hello World');
});
-------------------code----------------------

* The `app.get()` method defines a route for **GET requests** to the **root URL (`/`)**.
* It takes two arguments:

  1. **Path/URL** – `"/"` in this case represents the root of the site.
  2. **Callback function** – called when the route is requested.

     * It receives two parameters:

       * `req`: The **request object**, containing details about the incoming request.
       * `res`: The **response object**, used to send data back to the client.
* In this example, the server responds with `"Hello World"`.

---

### **5. Exploring the Request Object**

* The `req` (request) object contains many useful properties, such as:

  * `baseUrl`
  * `body`
  * `cookies`
  * `hostname`
  * `ip`
  * `method`
  * `originalUrl`
  * `params`
* To see all available properties, refer to the **Express documentation** at
  [expressjs.com → API Reference (version 4)](https://expressjs.com/en/4x/api.html).

---

### **6. Listening on a Port**

-------------------code----------------------
app.listen(3000, () => {
  console.log('Listening on port 3000...');
});
-------------------code----------------------

* The `app.listen()` method starts the web server on the specified port (e.g., **3000**).
* The optional callback function runs once the server starts listening, logging a confirmation message.

---

### **7. Running the Server**

In the terminal:

-------------------code----------------------bash
node index.js
-------------------code----------------------

* Open a browser and navigate to **`http://localhost:3000`**.
* You should see the **“Hello World”** message.

---

### **8. Adding Another Route**

-------------------code----------------------
app.get('/api/courses', (req, res) => {
  res.send([1, 2, 3]);
});
-------------------code----------------------

* Defines a new **GET** route for `/api/courses`.
* In a real-world scenario, this endpoint would retrieve data from a database.
* For simplicity, it currently returns an **array of numbers** `[1, 2, 3]`.
* To apply changes:

  1. Stop the running process with **Ctrl + C**.
  2. Restart with **`node index.js`**.
  3. Visit **`http://localhost:3000/api/courses`** in your browser.

  * You should see the array `[1, 2, 3]`.

---

### **9. Advantages of Using Express**

* Unlike the earlier HTTP module approach, Express allows defining routes cleanly without **nested `if` statements**.
* It provides a **structured and scalable** way to organize code.
* As the application grows:

  * Different routes can be moved into **separate files** (e.g., `courses.js` for course-related routes).
  * This improves maintainability and modularity.

---

### **Summary**

* `express()` initializes the app.
* `app.get()` defines routes for GET requests.
* `res.send()` sends a response to the client.
* `app.listen()` starts the server.
* Express gives structure to Node.js web applications, making them easier to scale and manage.
