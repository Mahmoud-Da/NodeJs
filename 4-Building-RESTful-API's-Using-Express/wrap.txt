*** 1- Introduction ***
**Lecture Notes: Express Framework Introduction**

**1. Recap of the HTTP Module**

* In Section 2, we learned about Node’s module system and the use of the built-in **HTTP module**.
* The HTTP module allows us to create a **web server** that listens on a specific port (e.g., port **3000**) and responds to requests sent to various **endpoints** such as:

  * `/` (root)
  * `/api/courses`

**2. Limitation of the HTTP Module Approach**

* While using the HTTP module directly works for small projects, it becomes inefficient and difficult to manage in **large or complex applications**.
* The main problem is the need to **hard-code multiple `if` statements** to handle different routes and endpoints, which quickly makes the code messy and hard to maintain.

**3. Introduction to Express**

* **Express** is a **fast, lightweight, and flexible framework** for building web applications and APIs in Node.js.
* It simplifies the process of:

  * Handling routes
  * Managing HTTP requests and responses
  * Organizing code in a clean and modular way

**4. Next Topic**

* The next section will cover **RESTful services**, a key concept in building structured and scalable web APIs using Express.


*** 2- RESTful Services ***
**Lecture Notes: Introduction to RESTful Services (RESTful APIs)**

**1. Overview**

* REST stands for **Representational State Transfer**.
* RESTful services (or RESTful APIs) are a **convention for building HTTP services** that enable communication between clients (frontends) and servers (backends).
* These services allow applications to **create, read, update, and delete (CRUD)** data using standard **HTTP protocol** principles.

---

**2. Client-Server Architecture Recap**

* Most modern applications follow the **client-server model**.

  * **Client (frontend)**: The app users interact with.
  * **Server (backend)**: Manages and provides data or functionality.
* Communication between the client and server occurs through **HTTP requests**, the same protocol used for web browsing.
* The server exposes services (APIs) that clients can call to perform actions such as retrieving or saving data.

---

**3. Purpose of REST**

* REST provides a **standardized convention** for designing and accessing these HTTP services.
* It allows developers to use existing HTTP methods to perform CRUD operations:

  * **Create** → `POST`
  * **Read** → `GET`
  * **Update** → `PUT`
  * **Delete** → `DELETE`

---

**4. Example: Vidly Movie Rental Company**
Imagine a company called **Vidly** that rents movies.

* The client app manages a list of customers.
* The server exposes a RESTful service at an endpoint like:

  -------------------code----------------------
  https://vidly.com/api/customers
  -------------------code----------------------

**Endpoint Structure Explained:**

1. **HTTP or HTTPS:**

   * `HTTP` for normal communication.
   * `HTTPS` for secure communication (encrypted data transfer).
2. **Domain:**

   * Example: `vidly.com`
3. **/api:**

   * Common convention to indicate that the path refers to API services (optional but widely used).
   * Could also appear as a subdomain, e.g., `https://api.vidly.com/customers`
4. **/customers:**

   * Refers to a **resource** in the application.
   * In REST, resources represent data entities such as customers, movies, or rentals.

---

**5. HTTP Methods and Their Uses**

| Method     | Purpose       | Example Endpoint          | Description                                                                                  |
| ---------- | ------------- | ------------------------- | -------------------------------------------------------------------------------------------- |
| **GET**    | Retrieve data | `GET /api/customers`      | Returns a list of all customers.                                                             |
|            |               | `GET /api/customers/1`    | Returns details of a single customer by ID.                                                  |
| **POST**   | Create data   | `POST /api/customers`     | Creates a new customer; the client sends the customer object in the request body.            |
| **PUT**    | Update data   | `PUT /api/customers/1`    | Updates an existing customer; includes the full updated customer object in the request body. |
| **DELETE** | Remove data   | `DELETE /api/customers/1` | Deletes the customer with the specified ID.                                                  |

---

**6. Key Concepts in REST**

* **Resources:** Entities such as `customers`, `movies`, or `rentals` that the API exposes.
* **Endpoints:** URLs that represent these resources.
* **HTTP Methods (Verbs):** Indicate the desired operation (GET, POST, PUT, DELETE).
* **Request Body:** Data sent by the client when creating or updating a resource (POST and PUT).

---

**7. What We Will Build**

* In this section, we will use the **Express framework** to build a RESTful service for managing a list of customers.
* Instead of connecting to a database, we will use a **simple in-memory array** to store customer data for simplicity.
* Later in the course, we will integrate a **database** for persistent storage.

---

**Summary**

* REST is a structured way of building HTTP services that follow predictable patterns.
* Each resource is accessed through a meaningful endpoint and standard HTTP methods.
* Express simplifies the creation of RESTful APIs, allowing developers to easily define endpoints and handle requests.

*** 3- Introducing Express ***
**Lecture Notes: Introduction to Express Framework Setup**

**1. Recap of HTTP Module**

* In the earlier section about Node’s core modules, we used the **HTTP module** to create a basic web server.
* The server used a **callback function** that received two parameters:

  * **request (req):** Contains information about the incoming request, including the URL.
  * **response (res):** Used to send a response back to the client.
* Using the request object, we could check the URL and define routes, for example:

  * If the request URL is `/api/courses`, respond with a list of courses.

**2. Problem with This Approach**

* Although this method works, it quickly becomes **unmaintainable** as the application grows.
* Each new route requires another **if statement** in the callback function, making the code repetitive and hard to manage.

**3. The Need for a Framework**

* A **framework** provides structure and organization to the application.
* It allows us to:

  * Easily define multiple routes.
  * Keep the code clean and maintainable.
  * Focus on business logic instead of low-level HTTP handling.

**4. Introduction to Express**

* **Express** is the most popular framework for building web applications and servers in Node.js.
* It is known for being:

  * **Fast**
  * **Lightweight**
  * **Well-documented**
* According to npm statistics:

  * Over **700,000 downloads per day**.
  * Over **15 million downloads per month**.

**5. Setting Up an Express Project**

* Visit **npmjs.org** (or **npmjs.com**) to view details and documentation about Express.
* To start a new project:

  1. **Create a new folder** for the project:

     -------------------code----------------------
     mkdir express-demo
     -------------------code----------------------
  2. **Navigate into the folder:**

     -------------------code----------------------
     cd express-demo
     -------------------code----------------------
  3. **Initialize the project with npm:**

     -------------------code----------------------
     npm init -y
     -------------------code----------------------

     This creates a `package.json` file.
  4. **Install Express:**

     -------------------code----------------------
     npm install express
     -------------------code----------------------
* After installation, Express will be added as a dependency in the `package.json` file.

**6. Next Step**

* In the next lecture, you will learn how to **build your first web server using Express**.

*** 4- Building Your First Web Server ***
**Lecture Notes: Building the First Express Web Server**

---

### **1. Setting Up the File**

* Create a new file in VS Code named **`index.js`** (or **`app.js`**, the name does not matter).
* This file will contain the code for the Express application.

---

### **2. Loading and Initializing Express**

-------------------code----------------------
const express = require('express');
const app = express();
-------------------code----------------------

* The `require('express')` statement **loads the Express module**.
* Calling `express()` **returns an application object**, which represents the Express app.
* By convention, this object is stored in a constant named **`app`**.

---

### **3. Understanding Express Methods**

* The `app` object provides several methods that correspond to **HTTP verbs**:

  * `app.get()` → Handle HTTP **GET** requests
  * `app.post()` → Handle HTTP **POST** requests
  * `app.put()` → Handle HTTP **PUT** requests
  * `app.delete()` → Handle HTTP **DELETE** requests
* These methods are used to define **routes** (endpoints) for the application.

---

### **4. Defining the First Route**

-------------------code----------------------
app.get('/', (req, res) => {
  res.send('Hello World');
});
-------------------code----------------------

* The `app.get()` method defines a route for **GET requests** to the **root URL (`/`)**.
* It takes two arguments:

  1. **Path/URL** – `"/"` in this case represents the root of the site.
  2. **Callback function** – called when the route is requested.

     * It receives two parameters:

       * `req`: The **request object**, containing details about the incoming request.
       * `res`: The **response object**, used to send data back to the client.
* In this example, the server responds with `"Hello World"`.

---

### **5. Exploring the Request Object**

* The `req` (request) object contains many useful properties, such as:

  * `baseUrl`
  * `body`
  * `cookies`
  * `hostname`
  * `ip`
  * `method`
  * `originalUrl`
  * `params`
* To see all available properties, refer to the **Express documentation** at
  [expressjs.com → API Reference (version 4)](https://expressjs.com/en/4x/api.html).

---

### **6. Listening on a Port**

-------------------code----------------------
app.listen(3000, () => {
  console.log('Listening on port 3000...');
});
-------------------code----------------------

* The `app.listen()` method starts the web server on the specified port (e.g., **3000**).
* The optional callback function runs once the server starts listening, logging a confirmation message.

---

### **7. Running the Server**

In the terminal:

-------------------code----------------------bash
node index.js
-------------------code----------------------

* Open a browser and navigate to **`http://localhost:3000`**.
* You should see the **“Hello World”** message.

---

### **8. Adding Another Route**

-------------------code----------------------
app.get('/api/courses', (req, res) => {
  res.send([1, 2, 3]);
});
-------------------code----------------------

* Defines a new **GET** route for `/api/courses`.
* In a real-world scenario, this endpoint would retrieve data from a database.
* For simplicity, it currently returns an **array of numbers** `[1, 2, 3]`.
* To apply changes:

  1. Stop the running process with **Ctrl + C**.
  2. Restart with **`node index.js`**.
  3. Visit **`http://localhost:3000/api/courses`** in your browser.

  * You should see the array `[1, 2, 3]`.

---

### **9. Advantages of Using Express**

* Unlike the earlier HTTP module approach, Express allows defining routes cleanly without **nested `if` statements**.
* It provides a **structured and scalable** way to organize code.
* As the application grows:

  * Different routes can be moved into **separate files** (e.g., `courses.js` for course-related routes).
  * This improves maintainability and modularity.

---

### **Summary**

* `express()` initializes the app.
* `app.get()` defines routes for GET requests.
* `res.send()` sends a response to the client.
* `app.listen()` starts the server.
* Express gives structure to Node.js web applications, making them easier to scale and manage.


*** 5- Nodemon ***
**Lecture Notes: Using Nodemon for Automatic Server Restart**

---

### **1. The Problem**

* Up to now, every time a change is made in the code, the process must be **manually stopped and restarted** using the terminal.
* This process becomes **tedious and inefficient**, especially during development when frequent changes are made.

---

### **2. Introducing Nodemon**

* **Nodemon** stands for **Node Monitor**.
* It automatically **watches your files** and **restarts the Node.js process** whenever a file changes.
* This eliminates the need to manually restart the server each time you modify your code.

---

### **3. Installing Nodemon**

In the terminal, run:

-------------------code----------------------
npm install -g nodemon
-------------------code----------------------

* The `-g` flag means installing **globally**, allowing you to use `nodemon` from any project directory.
* On macOS or Linux, if you encounter a permissions error, prefix the command with `sudo`:

-------------------code----------------------
sudo npm install -g nodemon
-------------------code----------------------

---

### **4. Running the Application with Nodemon**

Instead of using:

-------------------code----------------------
node index.js
-------------------code----------------------

use:

-------------------code----------------------
nodemon index.js
-------------------code----------------------

* Nodemon now **monitors all files** in the current folder (regardless of file extension).
* When a change is detected, it automatically **restarts the application**.

---

### **5. Demonstration**

1. Run the application using `nodemon index.js`.
2. Make a small change in your code (for example, change a message in a route).
3. Save the file.
4. Nodemon will detect the change and **restart the server automatically**.
5. Check the terminal — you will see a message like:

   -------------------code----------------------
   [nodemon] restarting due to changes...
   [nodemon] starting `node index.js`
   -------------------code----------------------
6. Refresh the browser (e.g., at `http://localhost:3000`) to see the updated output.

---

### **6. Benefits of Using Nodemon**

* Saves development time by eliminating the need to manually restart the server.
* Detects changes automatically in any file type within the project.
* Ideal for local development environments.

---

### **Summary**

* Nodemon improves the development workflow by automatically restarting the server when code changes.
* Install globally using `npm install -g nodemon`.
* Run your application with `nodemon index.js` instead of `node index.js`.
* Any saved file changes trigger an automatic restart, keeping the development process fast and efficient.


*** 6- Environment Variables ***
**Lecture Notes: Using Environment Variables for Dynamic Port Assignment**

---

### **1. The Problem with Hardcoded Port Numbers**

* In the current code, the server listens on a **hardcoded port (3000)**.
* While this works during development, it is **not suitable for production**.
* In production, the **hosting environment dynamically assigns a port** for the application to use.
* Therefore, hardcoding `3000` can cause the server to fail when deployed.

---

### **2. What Is an Environment Variable?**

* An **environment variable** is a variable that exists **outside the application’s code** but is part of the environment in which the process runs.
* It allows configuration settings (like port numbers, API keys, or database URLs) to be defined **externally**, without modifying the application code.
* Common in Node.js environments, one such variable is **`PORT`**.

---

### **3. Accessing Environment Variables in Node.js**

* Node provides a global object called **`process`**, which represents the current running process.
* To access environment variables, use:

  -------------------code----------------------
  process.env
  -------------------code----------------------
* To specifically access the port:

  -------------------code----------------------
  process.env.PORT
  -------------------code----------------------

---

### **4. Implementing Dynamic Port Assignment**

Replace the hardcoded port number with a value that checks for the environment variable first.
If it doesn’t exist, default to `3000`.

-------------------code----------------------
const port = process.env.PORT || 3000;

app.listen(port, () => {
  console.log(`Listening on port ${port}...`);
});
-------------------code----------------------

**Explanation:**

* `process.env.PORT`: Retrieves the value of the environment variable `PORT`.
* `|| 3000`: Uses port 3000 as a **fallback** if the environment variable is not set.
* Template strings (backticks) are used for dynamic output in the console message.

---

### **5. Setting Environment Variables**

#### **On macOS/Linux:**

-------------------code----------------------
export PORT=5000
-------------------code----------------------

#### **On Windows (Command Prompt):**

-------------------code----------------------
set PORT=5000
-------------------code----------------------

* After setting the variable, run the application again:

  -------------------code----------------------
  nodemon index.js
  -------------------code----------------------
* The server will now listen on **port 5000**, as specified by the environment variable.

---

### **6. Behavior When the Variable Is Not Set**

* If `PORT` is **not defined**, the fallback value `3000` is used automatically.
* Example terminal output:

  -------------------code----------------------
  Listening on port 3000...
  -------------------code----------------------
* After defining `PORT=5000`:

  -------------------code----------------------
  Listening on port 5000...
  -------------------code----------------------

---

### **7. Best Practice**

* Always configure your Node.js applications to **read the port from an environment variable**.
* This ensures flexibility between **development** and **production** environments.
* Typical pattern:

  -------------------code----------------------
  const port = process.env.PORT || 3000;
  -------------------code----------------------

---

### **Summary**

* Hardcoding port numbers limits portability.
* Use `process.env.PORT` to dynamically assign ports.
* Set environment variables using `export` (Mac/Linux) or `set` (Windows).
* Always include a default value (e.g., `3000`) for local development.
* This approach ensures your application can run reliably both locally and in hosting environments.

*** 7- Route Parameters ***
### Lecture Notes: Creating Routes with Parameters in Express

#### 1. **Overview**

* So far, we have a route that returns the list of all courses.
* In this lecture, we learn how to create a route that retrieves **a single course** based on its **ID**.

#### 2. **Defining a Route with Parameters**

* In RESTful services, to get a specific course, we include its **ID** in the URL.
  Example endpoint:

  -------------------code----------------------
  /api/courses/1
  -------------------code----------------------

  where `1` is the course ID.

#### 3. **Implementing the Route**

-------------------code----------------------
app.get('/api/courses/:id', (req, res) => {
  res.send(req.params.id);
});
-------------------code----------------------

* `:id` defines a **route parameter** named `id`.
* The parameter name can be anything, but `id` is standard and concise.
* To access the parameter, use:

  -------------------code----------------------
  req.params.id
  -------------------code----------------------
* Example: Requesting `/api/courses/1` will return `1`.

#### 4. **Multiple Route Parameters**

* We can define multiple parameters in a route.
  Example:

  -------------------code----------------------
  /api/posts/:year/:month
  -------------------code----------------------
* This allows fetching all posts for a specific month and year.
* Parameters are accessed as:

  -------------------code----------------------
  req.params.year
  req.params.month
  -------------------code----------------------
* The `req.params` object contains all route parameters:

  -------------------code----------------------
  { year: '2018', month: '1' }
  -------------------code----------------------

#### 5. **Query String Parameters**

* Query strings are used to send **optional or additional data** to the backend.
* Example:

  -------------------code----------------------
  /api/posts/2018/1?sortBy=name
  -------------------code----------------------

  * `sortBy` is a **query string parameter**.
  * Query parameters are added after a `?` and separated by `&` if there are multiple.

#### 6. **Reading Query Parameters**

* Access query string parameters using:

  -------------------code----------------------
  req.query
  -------------------code----------------------
* Example output:

  -------------------code----------------------
  { sortBy: 'name' }
  -------------------code----------------------

#### 7. **Summary**

* **Route parameters** (`req.params`) are used for **required** values that identify a specific resource (e.g., course ID).
* **Query parameters** (`req.query`) are used for **optional** information (e.g., sorting, filtering).
* Express makes it easy to define and retrieve both types of parameters for flexible API design.

*** 8- Handling HTTP GET Requests ***
### Lecture Notes: Implementing an Endpoint to Get a Single Course

#### 1. Creating the Courses Array

* Define a constant array called `courses` that contains three course objects.
* Each object includes two properties:

  * `id`
  * `name`
* Example:

  -------------------code----------------------
  const courses = [
    { id: 1, name: 'course1' },
    { id: 2, name: 'course2' },
    { id: 3, name: 'course3' }
  ];
  -------------------code----------------------

#### 2. Setting Up Endpoints

There will be two main endpoints:

1. **Get All Courses**

   * URL: `/api/courses`
   * Returns the entire `courses` array.

   -------------------code----------------------
   app.get('/api/courses', (req, res) => {
     res.send(courses);
   });
   -------------------code----------------------

2. **Get a Single Course by ID**

   * URL: `/api/courses/:id`
   * Retrieves a specific course based on its `id` parameter.

#### 3. Implementing Logic to Find a Single Course

* Use the `find()` method on the `courses` array:

  -------------------code----------------------
  app.get('/api/courses/:id', (req, res) => {
    const course = courses.find(c => c.id === parseInt(req.params.id));
  });
  -------------------code----------------------
* `find()` iterates over the array and returns the first course that matches the condition.
* The `req.params.id` value is a string, so it must be converted to an integer using `parseInt()` for accurate comparison.

#### 4. Choosing Between `var`, `let`, and `const`

* `var` is function-scoped and older; modern JavaScript prefers `let` and `const`.
* Use:

  * `let` when the variable will be reassigned.
  * `const` when the variable value should remain constant.
* In this case, `const` is appropriate since `course` will not change after being found.

#### 5. Handling Non-Existent Courses

* If the course is not found, return an HTTP status code `404` with a message:

  -------------------code----------------------
  if (!course) {
    res.status(404).send('The course with the given ID was not found');
  }
  -------------------code----------------------
* `404` indicates “Not Found” — a standard convention in RESTful APIs.

#### 6. Returning the Course if Found

* If the course exists, send it back in the response:

  -------------------code----------------------
  res.send(course);
  -------------------code----------------------

#### 7. Testing the Endpoint

* Access `/api/courses/1` → should return the course object `{ id: 1, name: 'course1' }`.
* Access `/api/courses/10` → should return a 404 response with the message “The course with the given ID was not found.”

#### 8. Verifying Status Code in Browser

* Open **Chrome Developer Tools** → **Network** tab.
* Refresh the page (`Ctrl + R` or `Cmd + R`).
* Check the request’s **Status** column:

  * `200` for successful responses.
  * `404` when the course does not exist.

---

**Summary:**
This lecture demonstrated how to:

* Create a static array of course objects.
* Implement two RESTful endpoints: one for fetching all courses and one for fetching a specific course by ID.
* Use `Array.find()` and `parseInt()` for precise matching.
* Return appropriate HTTP responses following REST conventions.


*** 9- Handling HTTP POST Requests ***
### Lecture Notes: Handling HTTP POST Requests in Express

#### 1. Overview

* Up to this point, we have created two routes that handle **HTTP GET** requests:

  * One to get all courses.
  * One to get a single course.
* In this lecture, we learn how to handle **HTTP POST** requests, which are used to **create new resources** — in this case, a new course.

---

#### 2. Creating a POST Endpoint

* Use `app.post()` instead of `app.get()`.
* The endpoint path is `/api/courses`, because we are adding a new course to the *collection* of courses.

**Syntax:**

-------------------code----------------------
app.post('/api/courses', (req, res) => {
  // Logic to create and return a new course
});
-------------------code----------------------

---

#### 3. Implementing the Route Handler

Inside the route handler:

1. **Create a new course object** using the data from the request body.
2. **Manually assign an ID** since there is no database yet.
3. **Add the new course** to the `courses` array.
4. **Return the new course** to the client.

**Example:**

-------------------code----------------------
app.post('/api/courses', (req, res) => {
  const course = {
    id: courses.length + 1,       // Manual ID assignment
    name: req.body.name           // Reading from the request body
  };

  courses.push(course);
  res.send(course);               // Return the created course
});
-------------------code----------------------

---

#### 4. Reading JSON Data from the Request Body

* By default, **Express does not parse JSON** request bodies automatically.
* To enable this feature, use built-in middleware provided by Express.
* Add the following line **at the top of your app file**, after creating the app object:

-------------------code----------------------
app.use(express.json());
-------------------code----------------------

##### Explanation:

* `express.json()` returns a **middleware function**.
* `app.use()` registers this middleware in the **request processing pipeline**.
* The middleware parses incoming JSON payloads and populates `req.body`.

This means that when a client sends a JSON object (like `{"name": "New Course"}`), you can access it using `req.body.name`.

---

#### 5. Returning the Created Course

* After adding the course to the array, return it in the response body using `res.send(course)`.
* This is a **RESTful convention**:
  When a resource is created on the server, the server should return the full representation of that new resource — including its server-assigned ID.

---

#### 6. Summary of Steps

1. Define a POST route using `app.post('/api/courses')`.
2. Use `app.use(express.json())` to enable JSON body parsing.
3. Create a new course object with an ID and name.
4. Push it into the `courses` array.
5. Send the created course object back to the client.

---

#### 7. Purpose of Returning the Course

* The **client needs to know the ID** assigned by the server.
* Returning the full course object allows the client to store or reference it later.

---

**In the next lecture:**
Testing this endpoint using a REST client (such as Postman or an HTTP request tool) to verify that POST requests successfully create and return new course objects.

*** 10- Calling Endpoints Using Postman ***
### Lecture Notes: Testing HTTP POST Requests with Postman

#### 1. Introduction to Postman

* To **call and test HTTP services**, we use a Chrome extension called **Postman**.
* Postman allows developers to send various types of HTTP requests (GET, POST, PUT, DELETE) to a server and inspect the responses.

---

#### 2. Installing Postman

1. Open Chrome and search for **“Postman Chrome extension”**.
2. Click **Add to Chrome** to install it.
3. Once installed, open it from the **Chrome Apps** menu.
4. When prompted to sign up, you can skip registration by clicking the link to go directly to the app interface.

---

#### 3. Creating a New HTTP Request

1. In Postman, click to create a **new request**.
2. From the **method dropdown**, choose **POST** (since we are sending data to the server).
3. In the **URL field**, enter your server’s address. For example:

   -------------------code----------------------
   http://localhost:3000/api/courses
   -------------------code----------------------

   * `localhost` refers to your own computer.
   * `3000` is the port where the Express app is running.
   * `/api/courses` is the endpoint that accepts POST requests.

---

#### 4. Setting the Request Body

1. In the request settings, go to the **Body** tab.
2. Select **raw** (to send raw data).
3. From the small dropdown next to “Text”, select **JSON**.
4. Enter a JSON object representing the new course:

   -------------------code----------------------
   {
     "name": "new course"
   }
   -------------------code----------------------

---

#### 5. Sending the Request and Viewing the Response

1. Click **Send** to make the request.
2. Look at the **response section** below:

   * The **status code** should be **200**, indicating the request was handled successfully.
   * The **response body** should display the newly created course object, for example:

     -------------------code----------------------
     {
       "id": 4,
       "name": "new course"
     }
     -------------------code----------------------

     Here, the `id` is automatically assigned based on the existing courses in the array.

---

#### 6. Summary of What Happened

* The **client (Postman)** sent an HTTP POST request with JSON data to the Express server.
* The **server** read the data, created a new course object, added it to the `courses` array, and returned that object in the response.
* The **status code 200** indicates success.

---

#### 7. Next Topic: Input Validation

* In this example, we assumed that the client always sends a valid object containing a `name` property.
* However, a client might forget to include `name`, or send an invalid or too-short name.
* To handle such cases, we need **input validation**, which will be covered in the next lecture.

*** 11- Input Validation ***
### Lecture Notes: Input Validation in Express Using Joi

#### 1. Importance of Input Validation

* **Never trust client input.** Always validate what the client sends to the server.
* Input validation ensures **security**, **data consistency**, and **application stability**.
* Even in simple examples like a course object with one property (`name`), validation must be applied.

---

#### 2. Manual Input Validation Example

A simple way to validate input manually:

-------------------code----------------------
if (!req.body.name || req.body.name.length < 3) {
  res.status(400).send('Name is required and should be a minimum of 3 characters.');
  return;
}
-------------------code----------------------

* `400` is the HTTP status code for **Bad Request**.
* This approach works, but it quickly becomes unmanageable for complex objects with many fields.

---

#### 3. Introducing Joi

* Joi is a popular **Node.js validation library** that simplifies and structures validation logic.
* It allows you to define **schemas** that describe the shape and rules of your data.

**Installation:**

-------------------code----------------------
npm install joi@13.1.0
-------------------code----------------------

(The version `13.1.0` is used in the example for consistency.)

---

#### 4. Setting Up Joi in the Application

1. **Require the module** at the top of the file:

   -------------------code----------------------
   const Joi = require('joi');
   -------------------code----------------------

   * The capitalized name `Joi` follows the **PascalCase** convention for classes.
   * It’s a best practice to keep all `require` statements at the top for clarity.

2. **Dependencies so far:**

   * `express` for the web framework.
   * `joi` for validation.

---

#### 5. Defining a Schema

A schema defines the structure and constraints of your input object.

**Example schema for a course:**

-------------------code----------------------
const schema = {
  name: Joi.string().min(3).required()
};
-------------------code----------------------

Explanation:

* `Joi.string()` — the property must be a string.
* `.min(3)` — must have at least 3 characters.
* `.required()` — this property is mandatory.

---

#### 6. Validating Request Data

Use `Joi.validate()` to check if the request body matches the schema:

-------------------code----------------------
const result = Joi.validate(req.body, schema);
-------------------code----------------------

* The `result` object has two properties:

  * `error` — contains details if validation fails.
  * `value` — contains the validated data if successful.

---

#### 7. Handling Validation Errors

Check for errors and return an appropriate response:

-------------------code----------------------
if (result.error) {
  res.status(400).send(result.error.details[0].message);
  return;
}
-------------------code----------------------

* If validation fails, `result.error` will be set.
* The `details` array contains one or more error messages.
* In this example, only the first message is sent to the client.

---

#### 8. Example of Full Implementation

-------------------code----------------------
const Joi = require('joi');
const express = require('express');
const app = express();

app.use(express.json());

const courses = [
  { id: 1, name: 'course1' },
  { id: 2, name: 'course2' },
  { id: 3, name: 'course3' }
];

app.post('/api/courses', (req, res) => {
  const schema = {
    name: Joi.string().min(3).required()
  };

  const result = Joi.validate(req.body, schema);

  if (result.error) {
    res.status(400).send(result.error.details[0].message);
    return;
  }

  const course = {
    id: courses.length + 1,
    name: req.body.name
  };
  courses.push(course);
  res.send(course);
});
-------------------code----------------------

---

#### 9. Testing with Postman

1. **Valid request:**

   -------------------code----------------------
   {
     "name": "new course"
   }
   -------------------code----------------------

   **Response:**

   -------------------code----------------------
   {
     "id": 4,
     "name": "new course"
   }
   -------------------code----------------------

2. **Invalid request (missing name):**

   -------------------code----------------------
   {}
   -------------------code----------------------

   **Response:**

   -------------------code----------------------
   "Name is required"
   -------------------code----------------------

3. **Invalid request (too short name):**

   -------------------code----------------------
   {
     "name": "a"
   }
   -------------------code----------------------

   **Response:**

   -------------------code----------------------
   "Name length must be at least 3 characters long"
   -------------------code----------------------

---

#### 10. Benefits of Using Joi

* Cleaner and more maintainable code.
* Standardized and expressive validation rules.
* Flexible schema definitions for complex objects.
* Detailed and customizable error messages.

---

**Summary:**
In this lecture, you learned how to:

* Perform basic manual validation for incoming data.
* Use **Joi** to create schema-based, reusable validation logic.
* Simplify input checking and return appropriate HTTP 400 responses with clear error messages.

*** 12- Handling HTTP PUT Requests ***
### Lecture Notes: Updating a Course (HTTP PUT Request)

---

#### 1. **Purpose**

In this lecture, we learn how to handle HTTP **PUT** requests to **update** an existing course in our RESTful API.

---

#### 2. **Creating the PUT Route**

We add a new route handler using the `PUT` method since it is used for updating existing resources.

-------------------code----------------------
app.put('/api/courses/:id', (req, res) => {
  // Logic goes here
});
-------------------code----------------------

* **Path**: `/api/courses/:id`
* **`:id`** is a route parameter used to identify the specific course to update.

---

#### 3. **Steps to Implement the Logic**

1. **Look up the course by ID**

   * If it doesn’t exist, return **404 (Not Found)**.

2. **Validate the request body**

   * Ensure the input data (course object) meets the schema requirements.
   * If invalid, return **400 (Bad Request)**.

3. **Update the course**

   * Modify the course’s properties using the request data.

4. **Return the updated course**

   * Send the updated course object back to the client.

---

#### 4. **Implementation**

##### Step 1: Look up the course

Reused logic from the “get a single course” route.

-------------------code----------------------
const course = courses.find(c => c.id === parseInt(req.params.id));
if (!course) return res.status(404).send('The course with the given ID was not found.');
-------------------code----------------------

##### Step 2: Validate the input

Reused schema and validation logic from the POST route (used for creating a course).

-------------------code----------------------
const schema = {
  name: Joi.string().min(3).required()
};

const result = Joi.validate(req.body, schema);

if (result.error) return res.status(400).send(result.error.details[0].message);
-------------------code----------------------

> Note: This results in **duplicated validation logic**, which will be refactored next.

##### Step 3: Update and send the course

-------------------code----------------------
course.name = req.body.name;
res.send(course);
-------------------code----------------------

---

#### 5. **Refactoring: Reusable Validation Function**

To avoid repeating validation code, define a **`validateCourse`** function:

-------------------code----------------------
function validateCourse(course) {
  const schema = {
    name: Joi.string().min(3).required()
  };

  return Joi.validate(course, schema);
}
-------------------code----------------------

Now, we can reuse this function in both **POST** and **PUT** routes:

-------------------code----------------------
const { error } = validateCourse(req.body);
if (error) return res.status(400).send(error.details[0].message);
-------------------code----------------------

---

#### 6. **Object Destructuring**

We use **object destructuring** to simplify access to the `error` property.

Instead of:

-------------------code----------------------
const result = validateCourse(req.body);
if (result.error) ...
-------------------code----------------------

We write:

-------------------code----------------------
const { error } = validateCourse(req.body);
if (error) ...
-------------------code----------------------

This makes the code cleaner and shorter.

---

#### 7. **Refactoring the POST Route**

We also update the **POST** route to use the new `validateCourse` function:

-------------------code----------------------
const { error } = validateCourse(req.body);
if (error) return res.status(400).send(error.details[0].message);
-------------------code----------------------

Now both **POST** and **PUT** routes use the same validation logic.

---

#### 8. **Testing the Endpoint**

Using **Postman**:

* **Valid Update**

  * Method: `PUT`
  * URL: `localhost:3000/api/courses/1`
  * Body: `{ "name": "new course" }`
  * Response: `200 OK`, updated course returned.

* **Invalid ID**

  * URL: `/api/courses/10`
  * Response: `404 Not Found`

* **Invalid Data**

  * Missing `name` property in body
  * Response: `400 Bad Request`
  * Error message: `"name" is required`

---

#### 9. **Summary**

* Used `PUT` for updating resources.
* Reused and refactored validation logic into a single function.
* Applied **object destructuring** for cleaner code.
* Tested all cases: valid update, invalid ID, invalid data.

---

**Next Lecture:** Handling **HTTP DELETE** requests.
