*** 1- Introduction ***
### Lecture Notes: Handling Unexpected Errors in Node.js and MongoDB (Vid.ly App)

---

#### 1. **Introduction**

In the current implementation of the Vid.ly application, the system assumes an *ideal environment* where all operations succeed.
However, in real-world applications, unexpected errors are inevitable — for example, the MongoDB connection might drop unexpectedly.

To build a reliable application, it is crucial to:

* Handle unexpected situations gracefully.
* Send meaningful error responses to the client.
* Log exceptions on the server for future debugging and improvement.

---

#### 2. **Demonstration of a Real-World Scenario**

**Setup:**

* The application runs with **Nodemon**.
* MongoDB server (`mongod`) runs in another terminal, listening on port `27017`.
* A **GET** request is sent from **Postman** to `/api/genres`.

**Normal Behavior:**

* The request returns a `200` response as expected.

**Simulated Failure:**

1. The MongoDB process is stopped using `Ctrl + C`.
2. A new GET request to `/api/genres` is sent.
3. The request hangs for about **30 seconds**.
4. The server terminal displays an **error message**:

   -------------------code----------------------
   UnhandledPromiseRejectionWarning: Unhandled promise rejection.
   Failed to reconnect after 30 attempts with interval 1000 milliseconds.
   -------------------code----------------------

---

#### 3. **MongoDB Driver Behavior**

* By default, if a MongoDB connection fails, the driver retries **30 times**, with **1-second intervals** between attempts.
* After 30 failed attempts, it throws an *unhandled promise rejection*.

---

#### 4. **Deprecation Warning and Node.js Behavior**

A warning appears:

-------------------code----------------------
DeprecationWarning: Unhandled promise rejections are deprecated.
In the future, unhandled rejections will terminate the Node.js process with a non-zero exit code.
-------------------code----------------------

**Implication:**

* Future versions of Node.js will automatically terminate the process if an unhandled promise rejection occurs.
* If the MongoDB server goes down temporarily (e.g., for 1 minute) and then restarts, the Node.js server will have already stopped and won’t be able to handle new client requests.

---

#### 5. **Why Proper Error Handling Matters**

* Without proper handling, a **temporary database outage** can completely **crash the Node process**.
* This means users will experience downtime, even if the database becomes available again shortly afterward.

---

#### 6. **Goal for This Section**

You will learn how to:

* Handle errors from MongoDB and other sources gracefully.
* Prevent the Node process from terminating unexpectedly.
* Log exceptions in a structured way for analysis.
* Maintain application availability during transient failures.

---

#### 7. **Key Takeaways**

* Always anticipate unexpected failures (database, network, etc.).
* Never leave promises unhandled.
* Implement global error handling to prevent server crashes.
* Log all exceptions for monitoring and improvement.
* Aim for fault-tolerant and resilient application design.

#### 8. how to run mango demon in split terminal?

To **run the MongoDB daemon (`mongod`) in a split terminal** while working on your Node.js app, follow these steps depending on your setup:

---

### **1. If You’re Using VS Code**

#### **Step-by-step:**

1. **Open the integrated terminal**
   Press <kbd>Ctrl</kbd> + <kbd>`</kbd> (backtick) or go to
   **View → Terminal**.

2. **Split the terminal**
   Click the **split terminal icon** (looks like two rectangles side by side), or press:

   -------------------code----------------------
   Ctrl + Shift + 5  (Windows/Linux)
   Cmd + Shift + 5   (macOS)
   -------------------code----------------------

3. **In the first terminal**, start your Node.js app:

   -------------------code----------------------
   npm start
   -------------------code----------------------

   or if using Nodemon:

   -------------------code----------------------
   nodemon index.js
   -------------------code----------------------

4. **In the second terminal**, start the MongoDB daemon:

   -------------------code----------------------
   mongod
   -------------------code----------------------

   This will start MongoDB’s background service, usually listening on port `27017`.

---

### **2. If You’re Using a System Installation (Mac/Linux/Windows)**

#### **Check if `mongod` is available**

-------------------code----------------------
mongod --version
-------------------code----------------------

If it’s not found, you need to install MongoDB:

* **macOS (Homebrew):**

  -------------------code----------------------
  brew services start mongodb-community@6.0
  -------------------code----------------------
* **Ubuntu/Debian:**

  -------------------code----------------------
  sudo systemctl start mongod
  -------------------code----------------------
* **Windows (using MongoDB Shell):**

  * Open a **new terminal** or **PowerShell** window.
  * Navigate to the MongoDB `bin` folder (e.g., `C:\Program Files\MongoDB\Server\6.0\bin`)
  * Run:

    -------------------code----------------------powershell
    mongod
    -------------------code----------------------

---

### **3. Using Two Tabs Instead of Split View (Optional)**

If your terminal doesn’t support splits:

* Open two terminal **tabs** or **windows**.
* In the first, run `mongod`.
* In the second, run your Node.js app.

---

### **4. Common Troubleshooting**

* **Port in use error**:

  -------------------code----------------------
  Address already in use on port 27017
  -------------------code----------------------

  → MongoDB may already be running. Check with:

  -------------------code----------------------
  ps aux | grep mongod
  -------------------code----------------------


  Find the process ID (the number right after your username) and stop it:

  -------------------code----------------------
  kill <PID>
  -------------------code----------------------
  
  Example:
  
  -------------------code----------------------
  kill 14321
  -------------------code----------------------
  
  Or, if it doesn’t stop:
  
  -------------------code----------------------
  kill -9 <PID>
  -------------------code----------------------

* **Data directory missing error**:

  -------------------code----------------------
  data/db not found
  -------------------code----------------------

  → Create it manually:

  -------------------code----------------------
  mkdir -p /data/db
  sudo chown -R $(whoami) /data/db
  -------------------code----------------------

---


* ** Data directory /data/db not found.
-------------------code----------------------
NonExistentPath: Data directory /data/db not found.
Create the missing directory or specify another path using --dbpath.
exitCode: 100
-------------------code----------------------

MongoDB is **not running** because it **couldn’t find the default data directory `/data/db`**.
Here’s the key part from your output:

-------------------code----------------------
NonExistentPath: Data directory /data/db not found.
Create the missing directory or specify another path using --dbpath.
exitCode: 100
-------------------code----------------------

Let’s fix that step-by-step on macOS:

---

if we have the DB file before 
-------------------code----------------------
mongod --dbpath /opt/homebrew/var/mongodb
-------------------code----------------------

if not use this instruction
### **1. Create the required data directory**

MongoDB stores its database files in `/data/db` by default.
Create it manually with the following commands:

-------------------code----------------------
sudo mkdir -p /data/db
sudo chown -R $(whoami) /data/db
-------------------code----------------------

Explanation:

* `mkdir -p /data/db` → creates the folder (including any missing parents)
* `chown -R $(whoami)` → gives you permission to read/write in it (MongoDB won’t run otherwise)

---

### **2. Start MongoDB again**

Now rerun:

-------------------code----------------------
mongod
-------------------code----------------------

You should see a long log ending with something like:

-------------------code----------------------
Waiting for connections on port 27017
-------------------code----------------------

That means MongoDB is now running successfully.

---

### **3. (Optional) Specify a custom data directory**

If you’d rather keep MongoDB’s data inside your project or your home folder, you can start it like this:

-------------------code----------------------
mongod --dbpath ~/mongodb-data
-------------------code----------------------

The first time, create that directory:

-------------------code----------------------
mkdir -p ~/mongodb-data
-------------------code----------------------

---

### **4. Verify MongoDB is working**

In a **new terminal tab** (keep `mongod` running), run:

-------------------code----------------------
mongosh
-------------------code----------------------

You should see:

-------------------code----------------------
test>
-------------------code----------------------

That means you’re successfully connected to your MongoDB server.

---

### **Summary**

| Problem                                    | Solution                                             |
| ------------------------------------------ | ---------------------------------------------------- |
| `NonExistentPath: /data/db not found`      | Create `/data/db` or specify `--dbpath`              |
| MongoDB shuts down immediately             | The data directory doesn’t exist or lacks permission |
| Want MongoDB to always start automatically | Use `brew services start mongodb-community@8.2`      |

---

*** 2- Handling Rejected Promises ***
---

### **Handling Unhandled Promise Rejections**

1. **Problem Overview**

   * An *unhandled promise rejection* occurs when a promise fails but its rejection is not properly handled.
   * This usually happens with asynchronous code, either using:

     * **Promise syntax (`then`)** without `catch`
     * **Async/await** without `try/catch`
   * If unhandled, Node.js may terminate the process in future versions, making the server unavailable to clients.

2. **Example in the Genres Module**

   * Current implementation:

     * Uses `await` to fetch genres.
     * No `try/catch` block is used to handle rejected promises.
   * Equivalent in promise syntax:

     -------------------code----------------------
     getGenres()
       .then(data => res.send(data))
       // Missing .catch to handle errors
     -------------------code----------------------

3. **Solution: Add Error Handling**

   * Wrap asynchronous code in a `try` block.
   * Use `catch` to handle exceptions.
   * Send a proper response to the client:

     -------------------code----------------------
     try {
       const genres = await Genre.find();
       res.send(genres);
     } catch (ex) {
       res.status(500).send('Something failed.');
       // Optional: log exception for debugging
       console.error(ex);
     }
     -------------------code----------------------
   * Key points:

     * **Async/await → use `try/catch`.**
     * **Promise `then` → always chain `catch`.**
     * Return appropriate HTTP status code (e.g., `500 Internal Server Error`) and a clear message.

4. **Demonstration Workflow**

   1. Start MongoDB (`mongod`) in one terminal.
   2. Run the Vid.ly Node application in another terminal.
   3. Test API endpoints using Postman:

      * Initially, requests succeed when MongoDB is running.
      * Stop MongoDB during testing to simulate a failure.
      * Send a request to `/api/genres`.
   4. Result:

      * Client receives `500 Internal Server Error` with message `'Something failed.'`
      * Terminal no longer shows unhandled promise rejection.
      * Server process continues running despite the temporary database outage.

5. **Key Takeaways**

   * Proper error handling prevents server crashes.
   * Always log exceptions for later debugging and analysis.
   * Incrementally improve the application by handling errors step by step.

---


*** 3- Express Error Middleware ***
### Lecture Notes: Centralized Error Handling in Express

---

#### 1. Problem with the Current Implementation

* In the previous implementation, each route handler used its own `try-catch` block to handle errors.
* This approach has several issues:

  * If we want to **change the error message** sent to the client, we must update it in **every route handler**.
  * In real-world applications, we often **log exceptions**. If we later decide to change how we log them, we must update **multiple files** again.
* The goal is to **centralize error handling** so that any changes in error handling or logging can be made in **a single place**.

---

#### 2. Express Error-Handling Middleware

* Express provides a **special type of middleware** for handling errors.
* This middleware function is defined with **four parameters**:

  -------------------code----------------------
  function (err, req, res, next) { ... }
  -------------------code----------------------
* It must be **registered after all other middleware** using:

  -------------------code----------------------
  app.use(errorMiddleware);
  -------------------code----------------------
* This ensures that if an error occurs anywhere in the app, it will eventually be passed to this middleware.

---

#### 3. Refactoring Error Handling

1. **In `index.js`**:

   * Register the error-handling middleware **after all other middleware**.
   * Example:

     -------------------code----------------------
     app.use(function (err, req, res, next) {
       // Centralized error-handling logic
     });
     -------------------code----------------------
2. **In `genres.js`** (or any route file):

   * Add the `next` parameter to the route handler.
   * Replace the `catch` logic with:

     -------------------code----------------------
     catch (ex) {
       next(ex);
     }
     -------------------code----------------------
   * This forwards the exception to the centralized error middleware.

---

#### 4. Creating a Dedicated Error Middleware Module

To improve **separation of concerns**, move the error-handling logic to its own file.

1. Create a new file:
   **`middleware/error.js`**

   -------------------code----------------------
   module.exports = function (err, req, res, next) {
     // Handle and log the error
     res.status(500).send('Something failed.');
   };
   -------------------code----------------------

2. In **`index.js`**, import and register it:

   -------------------code----------------------
   const error = require('./middleware/error');
   app.use(error);
   -------------------code----------------------

   Note: Pass the **reference** to the function, not its **execution** — do not use parentheses.

---

#### 5. Benefits of This Design

* **Single point of maintenance**: All error-handling logic is centralized.
* **Better separation of concerns**: Route handlers focus on business logic, not error management.
* **Easier future changes**: Updating logging behavior or error responses only requires modifying one module.

---

#### 6. Remaining Issue

* Each route still contains a **repetitive `try-catch` block**.
* This repetition can be avoided by improving the design further.
* The next lecture will cover how to **eliminate repetitive try-catch blocks** and make error handling even cleaner.

*** 4- Removing Try Catch Blocks ***
### Lecture Notes: Eliminating Repetitive Try-Catch Blocks Using Async Middleware in Express

---

#### 1. Problem with Repetitive Try-Catch Blocks

* Each route handler currently uses its own `try-catch` block to handle errors.
* This leads to:

  * **Repetition**: The same pattern appears in every route handler.
  * **Code clutter**: It distracts from the actual business logic of each route.
* The goal is to **remove repetitive try-catch logic** and handle it in one reusable function.

---

#### 2. Introducing the Async Middleware Pattern

* The idea is to create a **higher-order function** that wraps route handlers.
* This wrapper automatically catches errors and forwards them to the centralized error-handling middleware.

---

#### 3. Defining the Async Middleware Function

We start by creating a template function for handling async route functions:

-------------------code----------------------
function asyncMiddleware(handler) {
  return async (req, res, next) => {
    try {
      await handler(req, res);
    } catch (ex) {
      next(ex);
    }
  };
}
-------------------code----------------------

**Explanation:**

* The function `asyncMiddleware` takes a **route handler function** (`handler`) as an argument.
* It **returns a new function** that Express can call as a route handler.
* This returned function:

  * Accepts `(req, res, next)` — the standard Express parameters.
  * Executes the given handler inside a `try` block.
  * If an exception occurs, it automatically calls `next(ex)` to pass the error to the global error handler.

---

#### 4. Why We Return a Function

* In Express, when we define a route:

  -------------------code----------------------
  router.get('/', (req, res) => { ... });
  -------------------code----------------------

  we **pass a reference** to a handler function.
* Express itself calls that handler later and injects `req`, `res`, and `next`.
* Therefore, our middleware must **return** a function that Express can call later — not call it immediately.
* The `asyncMiddleware` serves as a **factory function**, producing a handler that Express can invoke.

---

#### 5. Using the Async Middleware in a Route

Instead of writing:

-------------------code----------------------
router.get('/', async (req, res, next) => {
  try {
    const genres = await Genre.find();
    res.send(genres);
  } catch (ex) {
    next(ex);
  }
});
-------------------code----------------------

We can now simplify it to:

-------------------code----------------------
router.get('/', asyncMiddleware(async (req, res) => {
  const genres = await Genre.find();
  res.send(genres);
}));
-------------------code----------------------

**Benefits:**

* No need to manually handle `try-catch` in each route.
* Cleaner and more readable route handlers.
* Errors are still properly forwarded to the central error middleware.

---

#### 6. Moving the Middleware to a Separate Module

To make this utility reusable, we extract it into its own file.

**File:** `middleware/async.js`

-------------------code----------------------
module.exports = function (handler) {
  return async (req, res, next) => {
    try {
      await handler(req, res);
    } catch (ex) {
      next(ex);
    }
  };
};
-------------------code----------------------

**Usage in a Route File (e.g., `genres.js`):**

-------------------code----------------------
const express = require('express');
const router = express.Router();
const asyncMiddleware = require('../middleware/async');

router.get('/', asyncMiddleware(async (req, res) => {
  const genres = await Genre.find();
  res.send(genres);
}));

module.exports = router;
-------------------code----------------------

---

#### 7. Benefits of This Approach

* **Removes repetitive try-catch blocks** from route handlers.
* **Improves readability**: The core logic of each route is clearer.
* **Promotes reuse**: The same `asyncMiddleware` function can be used across all routes.
* **Maintains centralized error handling**: All exceptions are still routed through the global error middleware.

---

#### 8. Summary

* We introduced an **async middleware** function that wraps route handlers.
* It automatically handles exceptions by passing them to Express’s error middleware.
* This approach enhances code **cleanliness**, **reusability**, and **maintainability**.
* The application now has:

  * A centralized error handler (in `error.js`).
  * A reusable async wrapper (in `async.js`).
  * Clean route handlers free of redundant try-catch logic.


*** 5- Express Async Errors ***
### Lecture Notes: Simplifying Async Error Handling with `express-async-errors`

---

#### 1. Background

* In the previous lecture, we created a custom `asyncMiddleware` function to handle asynchronous errors.
* This solved the problem of repetitive `try-catch` blocks but introduced another issue:

  * We had to **remember to wrap every route handler** with `asyncMiddleware`.
  * This added extra code noise and slightly reduced readability.

---

#### 2. Goal

* To **simplify the code further** by eliminating the need to manually wrap route handlers.
* We will use an existing **npm module** that automatically handles async errors in Express route handlers.

---

#### 3. Introducing the `express-async-errors` Module

* This module automatically patches Express to catch errors from asynchronous route handlers.
* It works by **monkey patching** Express’s internal behavior at runtime.
* Once imported, it wraps all async route handlers internally, so we don’t have to use our custom wrapper.

---

#### 4. Installing the Module

In the terminal, run:

-------------------code----------------------bash
npm install express-async-errors
-------------------code----------------------

**Note:**

* Be careful not to confuse it with a similar package called `express-async-error`.
* We are using `express-async-errors` (plural).
* Version used in the lecture: **2.1.0**

---

#### 5. Using the Module

In your main application file (`index.js`):

-------------------code----------------------
require('express-async-errors');
-------------------code----------------------

**Explanation:**

* You don’t need to assign the result to a constant.
* Just importing it is enough to enable its functionality.
* This must be done **at the start** of your application so it patches Express early.

---

#### 6. Simplifying Route Handlers

Now that `express-async-errors` is installed and loaded:

* You can remove the custom `asyncMiddleware` wrapper entirely.
* Your route handlers can return to their original, simpler form.

**Before (with asyncMiddleware):**

-------------------code----------------------
router.get('/', asyncMiddleware(async (req, res) => {
  const genres = await Genre.find();
  res.send(genres);
}));
-------------------code----------------------

**After (with express-async-errors):**

-------------------code----------------------
router.get('/', async (req, res) => {
  const genres = await Genre.find();
  res.send(genres);
});
-------------------code----------------------

**Also:**

* Remove the `require('../middleware/async')` line at the top of your file.
* The routes are now cleaner and more readable.

---

#### 7. Testing the Implementation

**Steps:**

1. Start MongoDB (`mongod`).
2. Run your application.
3. Test the endpoint (e.g., `GET /api/genres`) using Postman — it should return the expected data.
4. Stop MongoDB to simulate a database failure.
5. Send the same request again.

**Expected Result:**

* You should receive a **500 Internal Server Error** response.
* The global error-handling middleware in your app will handle and respond to the error automatically.

---

#### 8. Summary

* The `express-async-errors` module eliminates the need for manual `try-catch` or custom async wrappers.
* It provides a **cleaner and more maintainable** way to handle async errors in Express.
* Recommended approach:

  * Use `express-async-errors` for simplicity.
  * If it does not work properly in your environment, fall back to using your custom `asyncMiddleware` function.

---

#### 9. Final Recommendation

* For most modern Express applications, **`express-async-errors`** is the preferred solution for handling asynchronous errors.
* It offers:

  * **Less boilerplate**
  * **Better readability**
  * **Automatic error propagation** to centralized middleware
* Keep the `asyncMiddleware` file as a **backup** in case you encounter compatibility issues in the future.


*** 6- Logging Errors ***

### Lecture Notes: Logging Errors in Express Using Winston

---

#### 1. Introduction to Error Logging

* In enterprise applications, logging errors is **essential**.
* Logs help developers **review exceptions**, identify **problem areas**, and **improve reliability**.
* In this lecture, we introduce a **popular Node.js logging library** called **Winston**.

---

#### 2. About Winston

* Winston is one of the most widely used logging libraries in the Node.js ecosystem.
* It is **feature-rich**, **configurable**, and supports **multiple transports** (ways of storing or sending logs).
* Version used in the lecture: **2.4.0**
* Over **6.5 million monthly downloads** on NPM, indicating its popularity.

---

#### 3. Installation

In your terminal, run:

-------------------code----------------------
npm install winston
-------------------code----------------------

---

#### 4. Loading and Configuring Winston

In your `index.js` file:

-------------------code----------------------
const winston = require('winston');
-------------------code----------------------

* The `winston` object represents the **default logger**.
* For most small to medium-sized applications, the default logger is sufficient.
* Larger enterprise applications might create **custom loggers** with unique configurations for different modules.

---

#### 5. Understanding Winston Transports

A **transport** in Winston is a **storage mechanism** for logs.
It determines **where** your logs are written.

Common built-in transports:

* **Console** – logs messages to the terminal (default).
* **File** – logs messages to a file.
* **HTTP** – sends logs to a remote HTTP endpoint.

Other community plugins support:

* **MongoDB**
* **CouchDB**
* **Redis**
* **Loggly** (a cloud log management service)

By default, Winston logs to the **console**, but we can easily add a file transport.

---

#### 6. Adding a File Transport

In `index.js`, after importing Winston:

-------------------code----------------------
winston.add(winston.transports.File, { filename: 'logfile.log' });
-------------------code----------------------

* This line adds another transport to log messages to a file named `logfile.log`.
* Winston now logs both to the **console** and the **file** simultaneously.

---

#### 7. Using Winston in the Error Middleware

Open your **error-handling middleware** file (`middleware/error.js`):

-------------------code----------------------
const winston = require('winston');

module.exports = function (err, req, res, next) {
  winston.error(err.message, err);
  res.status(500).send('Something failed.');
};
-------------------code----------------------

**Explanation:**

* `winston.error()` logs an error-level message.
* The first argument is the message (`err.message`).
* The second argument (`err`) passes the full error object as metadata (includes the stack trace).
* This way, all error details are captured automatically.

---

#### 8. Logging Levels in Winston

Winston supports **different logging levels** that represent message importance:

| Level   | Purpose                              |
| ------- | ------------------------------------ |
| error   | Critical failures and exceptions     |
| warn    | Warnings or recoverable issues       |
| info    | General operational information      |
| verbose | Detailed logging information         |
| debug   | Developer-level debugging details    |
| silly   | Very fine-grained logs (rarely used) |

Example:

-------------------code----------------------
winston.error('Database connection failed');
winston.warn('Low disk space');
winston.info('Connected to MongoDB');
-------------------code----------------------

---

#### 9. Demonstration

1. In `genres.js`, simulate an error:

   -------------------code----------------------
   throw new Error('Could not get the genres');
   -------------------code----------------------
2. Run the application:

   -------------------code----------------------
   node index.js
   -------------------code----------------------
3. Send a request to `/api/genres` using Postman.
4. The error middleware will catch the exception and log it through Winston.

**Output:**

* In the **console**:

  -------------------code----------------------
  error: Could not get the genres
  Stack trace...
  -------------------code----------------------
* In the **logfile.log** file:

  -------------------code----------------------on
  {
    "message": "Could not get the genres",
    "stack": "...",
    "level": "error",
    "timestamp": "2025-11-13T09:00:00Z"
  }
  -------------------code----------------------

---

#### 10. Benefits of Using Winston

* Centralized and structured logging.
* Multiple output destinations via transports.
* JSON-formatted logs for easy analysis.
* Metadata support for full context (e.g., stack traces).
* Integration-ready with monitoring services like Loggly or ELK stack.

---

#### 11. Summary

* Logging is a crucial part of production-grade Express applications.
* **Winston** provides a flexible and scalable way to log application events and errors.
* Key points:

  * Install and import Winston.
  * Add a file transport for persistent logging.
  * Use `winston.error()` inside the error middleware.
  * Review `logfile.log` to analyze issues later.
* In the next lecture, we will extend Winston to **log errors to MongoDB** for even better traceability.





-------------------code----------------------
Error: Invalid transport, must be an object with a log method.
-------------------code----------------------

— means that the **transport** you passed to `winston.add()` was not constructed correctly.
This usually happens when using **newer versions of Winston (v3+)** but following the **old v2 syntax** from the lecture.

Let’s fix it step by step.

---

### 1. Identify the cause

In your code, you probably have something like this:

-------------------code----------------------
winston.add(winston.transports.File, { filename: 'logfile.log' });
-------------------code----------------------

That syntax was valid in **Winston v2**, but **invalid in v3 or later**.

In Winston 3+, transports must be instantiated with `new`.

---

### 2. Correct syntax for Winston 3+

Change your configuration in `index.js` to this:

-------------------code----------------------
const winston = require('winston');

winston.add(new winston.transports.File({ filename: 'logfile.log' }));
-------------------code----------------------

That’s it — this works correctly with Winston v3 and later.

---

### 3. Optional: Combine multiple transports

If you want to log both to the console and to a file, you can configure the logger like this:

-------------------code----------------------
const winston = require('winston');

winston.add(new winston.transports.Console());
winston.add(new winston.transports.File({ filename: 'logfile.log' }));
-------------------code----------------------

---

### 4. Use it in your error middleware

In your error-handling middleware (for example `middleware/error.js`):

-------------------code----------------------
const winston = require('winston');

module.exports = function (err, req, res, next) {
  winston.error(err.message, err);
  res.status(500).send('Something failed.');
};
-------------------code----------------------

---

### 5. Summary of fix

| Problem                                                                   | Fix                                                      |
| ------------------------------------------------------------------------- | -------------------------------------------------------- |
| Used old Winston 2 syntax (`winston.add(winston.transports.File, {...})`) | Use new syntax with `new winston.transports.File({...})` |
| Thrown error: “Invalid transport, must be an object with a log method.”   | Caused by missing `new` keyword when adding transport    |
| Version mismatch                                                          | Make sure you use proper API for the installed version   |

---

If you want to confirm which version of Winston you have, run:

-------------------code----------------------
npm list winston
-------------------code----------------------

If it shows **3.x or 4.x**, the new syntax above is required.


*** 7- Logging to MongoDB ***
### Lecture Notes: Logging Messages to MongoDB with Winston

---

#### 1. Introduction

In this lecture, we extend our logging setup to store log messages in **MongoDB** using the **winston-mongodb** transport module.

Logging to MongoDB is useful for centralizing logs, analyzing them, or integrating them into monitoring tools.

---

#### 2. Installing the MongoDB Transport

There is a known issue with the latest release candidate (`4.0.0`) of `winston-mongodb`, so we install the stable version `3.0.0` instead.

**Command:**

-------------------code----------------------
npm install winston-mongodb@3.0.0
-------------------code----------------------

Make sure to use this exact version, as the newer release candidate may not work with the examples shown here.

---

#### 3. Setting Up Winston with MongoDB Transport

In **index.js**, after requiring Winston, we also require `winston-mongodb`.

**Example setup:**

-------------------code----------------------
const winston = require('winston');
require('winston-mongodb');
-------------------code----------------------

We don’t need to assign the `require('winston-mongodb')` result to a variable — simply requiring it adds the MongoDB transport to Winston.

Now we can add a new transport to Winston.

**Example:**

-------------------code----------------------
winston.add(winston.transports.MongoDB, {
  db: 'mongodb://localhost/vidly'
});
-------------------code----------------------

This tells Winston to log messages to the MongoDB database named `vidly`.

---

#### 4. Logging in Practice

We already have Winston configured to log errors (from our error middleware).
Now, every time an error occurs, Winston will automatically:

* Log it to the console
* Log it to a log file
* Log it to MongoDB (via the new transport)

---

#### 5. Testing the Configuration

1. Run the application:

   -------------------code----------------------
   node index.js
   -------------------code----------------------

2. In **Postman**, send a request to the `/api/genres` endpoint (which throws an error).

3. Open **MongoDB Compass** and refresh the `vidly` database.

4. You’ll see a new collection named **log**.

Each document in the **log** collection includes:

* **timestamp** – when the error occurred
* **level** – the logging level (e.g., `error`)
* **message** – the log message
* **meta** – the metadata (stack trace and error details)

Example structure:

-------------------code----------------------on
{
  "_id": "...",
  "timestamp": "2025-11-13T10:25:00Z",
  "level": "error",
  "message": "Could not get the genres",
  "meta": {
    "message": "Could not get the genres",
    "name": "Error",
    "stack": "Error: Could not get the genres\n   at ..."
  }
}
-------------------code----------------------

---

#### 6. Logging Levels

Winston supports multiple logging levels:

1. **error**
2. **warn**
3. **info**
4. **verbose**
5. **debug**
6. **silly**

You can restrict which levels get stored in MongoDB.

For example, if you only want to log **errors**, modify the transport configuration:

-------------------code----------------------
winston.add(winston.transports.MongoDB, {
  db: 'mongodb://localhost/vidly',
  level: 'error'
});
-------------------code----------------------

If you set the level to `info`, Winston will log **error**, **warn**, and **info** messages — but not `debug` or `verbose`.

---

#### 7. Summary

| Step            | Description                                                                    |
| --------------- | ------------------------------------------------------------------------------ |
| Install package | `npm install winston-mongodb@3.0.0`                                            |
| Require module  | `require('winston-mongodb')`                                                   |
| Add transport   | `winston.add(winston.transports.MongoDB, { db: 'mongodb://localhost/vidly' })` |
| Test            | Trigger an error and view the `log` collection in MongoDB                      |
| Optional        | Limit log level with `{ level: 'error' }`                                      |

---

This setup allows Winston to log errors to both a **file** and **MongoDB**, providing a robust and scalable logging system for production applications.

That error —

-------------------code----------------------
Error: You should provide db to log to.
-------------------code----------------------

— means Winston’s MongoDB transport didn’t receive the `db` connection string properly when you called `winston.add()`.

Let’s fix this cleanly and make sure it works with `winston-mongodb@3.0.0`.

---

### Correct Setup for `winston-mongodb@3.0.0`

In your **index.js**, make sure this section looks like the following:

-------------------code----------------------
const winston = require('winston');
require('winston-mongodb');

// Add file transport
winston.add(new winston.transports.File({ filename: 'logfile.log' }));

// Add MongoDB transport
winston.add(new winston.transports.MongoDB({
  db: 'mongodb://localhost/vidly', // make sure this matches your database name
  level: 'error' // optional — only log errors
}));
-------------------code----------------------

**Important points:**

1. You must use `new winston.transports.MongoDB(...)`, **not** `winston.add(winston.transports.MongoDB, {...})`.
2. The `db` field must be a **valid MongoDB URI** string.
3. Make sure MongoDB is running locally (`mongod`).

---

### ⚙️ Why the Error Happened

In older tutorials or Winston v2 code, you might see:

-------------------code----------------------
winston.add(winston.transports.MongoDB, { db: 'mongodb://localhost/vidly' });
-------------------code----------------------

That syntax no longer works with Winston v3+.
The correct syntax uses the `new` keyword to create the transport instance.

---

Example Full Snippet

Your top section of **index.js** should look like:

-------------------code----------------------
const express = require('express');
const winston = require('winston');
require('winston-mongodb');

const app = express();

// Winston transports
winston.add(new winston.transports.File({ filename: 'logfile.log' }));
winston.add(new winston.transports.MongoDB({
  db: 'mongodb://localhost/vidly',
  level: 'error'
}));

app.listen(3001, () => winston.info('Listening on port 3001...'));
-------------------code----------------------

---

### Test Steps

1. Ensure MongoDB is running:

   -------------------code----------------------
   mongod
   -------------------code----------------------
2. Start your app:

   -------------------code----------------------
   nodemon index.js
   -------------------code----------------------
3. Trigger an error (e.g., from your `/api/genres` route).
4. Check **MongoDB Compass** → `vidly` database → `log` collection.

You should now see log documents appearing there with fields like:

-------------------code----------------------on
{
  "level": "error",
  "message": "Could not get the genres",
  "timestamp": "2025-11-13T10:35:00Z"
}
-------------------code----------------------

---

Would you like me to show you how to move this Winston configuration into a dedicated `startup/logging.js` module (for a cleaner structure, like in real-world apps)?

Good question — you can check your **MongoDB database name** in several simple ways depending on how you’re connected.
Here are the most common options:

---

### **1. If You’re Using MongoDB Compass (GUI)**

1. Open **MongoDB Compass**.
2. Connect to your server (e.g., `mongodb://localhost:27017`).
3. On the left sidebar, you’ll see a list of databases such as:

   -------------------code----------------------
   admin
   config
   local
   vidly
   test
   -------------------code----------------------
4. The name you use in your Winston configuration should match exactly one of those —
   for example:

   -------------------code----------------------
   db: 'mongodb://localhost/vidly'
   -------------------code----------------------

If you don’t see **vidly**, it means your app hasn’t yet created that database (MongoDB creates databases automatically when data is first inserted).

---

### **2. If You’re Using the Mongo Shell (`mongosh`)**

Run these commands in your terminal:

-------------------code----------------------
mongosh
-------------------code----------------------

Then inside the shell:

-------------------code----------------------
show dbs
-------------------code----------------------

You’ll see something like:

-------------------code----------------------
admin       0.000GB
config      0.000GB
local       0.000GB
vidly       0.002GB
-------------------code----------------------

The database name is `vidly`.
If you want to use or inspect it:

-------------------code----------------------
use vidly
show collections
-------------------code----------------------

---

### **3. If You Want to Confirm from Your App Code**

In your Node.js code (for example, in your MongoDB connection module), check the URI used to connect:

-------------------code----------------------
mongoose.connect('mongodb://localhost/vidly', { useNewUrlParser: true, useUnifiedTopology: true });
-------------------code----------------------

Here, `vidly` at the end of the URI is your **database name**.

---

### **4. If You Haven’t Created Any Collections Yet**

MongoDB won’t show an empty database.
You’ll only see it after your app writes data to it (for example, when you create a collection like `genres` or when Winston writes logs).

---


