*** 1- Introduction ***
### Lecture Notes: Handling Unexpected Errors in Node.js and MongoDB (Vid.ly App)

---

#### 1. **Introduction**

In the current implementation of the Vid.ly application, the system assumes an *ideal environment* where all operations succeed.
However, in real-world applications, unexpected errors are inevitable — for example, the MongoDB connection might drop unexpectedly.

To build a reliable application, it is crucial to:

* Handle unexpected situations gracefully.
* Send meaningful error responses to the client.
* Log exceptions on the server for future debugging and improvement.

---

#### 2. **Demonstration of a Real-World Scenario**

**Setup:**

* The application runs with **Nodemon**.
* MongoDB server (`mongod`) runs in another terminal, listening on port `27017`.
* A **GET** request is sent from **Postman** to `/api/genres`.

**Normal Behavior:**

* The request returns a `200` response as expected.

**Simulated Failure:**

1. The MongoDB process is stopped using `Ctrl + C`.
2. A new GET request to `/api/genres` is sent.
3. The request hangs for about **30 seconds**.
4. The server terminal displays an **error message**:

   -------------------code----------------------
   UnhandledPromiseRejectionWarning: Unhandled promise rejection.
   Failed to reconnect after 30 attempts with interval 1000 milliseconds.
   -------------------code----------------------

---

#### 3. **MongoDB Driver Behavior**

* By default, if a MongoDB connection fails, the driver retries **30 times**, with **1-second intervals** between attempts.
* After 30 failed attempts, it throws an *unhandled promise rejection*.

---

#### 4. **Deprecation Warning and Node.js Behavior**

A warning appears:

-------------------code----------------------
DeprecationWarning: Unhandled promise rejections are deprecated.
In the future, unhandled rejections will terminate the Node.js process with a non-zero exit code.
-------------------code----------------------

**Implication:**

* Future versions of Node.js will automatically terminate the process if an unhandled promise rejection occurs.
* If the MongoDB server goes down temporarily (e.g., for 1 minute) and then restarts, the Node.js server will have already stopped and won’t be able to handle new client requests.

---

#### 5. **Why Proper Error Handling Matters**

* Without proper handling, a **temporary database outage** can completely **crash the Node process**.
* This means users will experience downtime, even if the database becomes available again shortly afterward.

---

#### 6. **Goal for This Section**

You will learn how to:

* Handle errors from MongoDB and other sources gracefully.
* Prevent the Node process from terminating unexpectedly.
* Log exceptions in a structured way for analysis.
* Maintain application availability during transient failures.

---

#### 7. **Key Takeaways**

* Always anticipate unexpected failures (database, network, etc.).
* Never leave promises unhandled.
* Implement global error handling to prevent server crashes.
* Log all exceptions for monitoring and improvement.
* Aim for fault-tolerant and resilient application design.

#### 8. how to run mango demon in split terminal?

To **run the MongoDB daemon (`mongod`) in a split terminal** while working on your Node.js app, follow these steps depending on your setup:

---

### **1. If You’re Using VS Code**

#### **Step-by-step:**

1. **Open the integrated terminal**
   Press <kbd>Ctrl</kbd> + <kbd>`</kbd> (backtick) or go to
   **View → Terminal**.

2. **Split the terminal**
   Click the **split terminal icon** (looks like two rectangles side by side), or press:

   -------------------code----------------------
   Ctrl + Shift + 5  (Windows/Linux)
   Cmd + Shift + 5   (macOS)
   -------------------code----------------------

3. **In the first terminal**, start your Node.js app:

   -------------------code----------------------
   npm start
   -------------------code----------------------

   or if using Nodemon:

   -------------------code----------------------
   nodemon index.js
   -------------------code----------------------

4. **In the second terminal**, start the MongoDB daemon:

   -------------------code----------------------
   mongod
   -------------------code----------------------

   This will start MongoDB’s background service, usually listening on port `27017`.

---

### **2. If You’re Using a System Installation (Mac/Linux/Windows)**

#### **Check if `mongod` is available**

-------------------code----------------------
mongod --version
-------------------code----------------------

If it’s not found, you need to install MongoDB:

* **macOS (Homebrew):**

  -------------------code----------------------
  brew services start mongodb-community@6.0
  -------------------code----------------------
* **Ubuntu/Debian:**

  -------------------code----------------------
  sudo systemctl start mongod
  -------------------code----------------------
* **Windows (using MongoDB Shell):**

  * Open a **new terminal** or **PowerShell** window.
  * Navigate to the MongoDB `bin` folder (e.g., `C:\Program Files\MongoDB\Server\6.0\bin`)
  * Run:

    -------------------code----------------------powershell
    mongod
    -------------------code----------------------

---

### **3. Using Two Tabs Instead of Split View (Optional)**

If your terminal doesn’t support splits:

* Open two terminal **tabs** or **windows**.
* In the first, run `mongod`.
* In the second, run your Node.js app.

---

### **4. Common Troubleshooting**

* **Port in use error**:

  -------------------code----------------------
  Address already in use on port 27017
  -------------------code----------------------

  → MongoDB may already be running. Check with:

  -------------------code----------------------
  ps aux | grep mongod
  -------------------code----------------------


  Find the process ID (the number right after your username) and stop it:

  -------------------code----------------------
  kill <PID>
  -------------------code----------------------
  
  Example:
  
  -------------------code----------------------
  kill 14321
  -------------------code----------------------
  
  Or, if it doesn’t stop:
  
  -------------------code----------------------
  kill -9 <PID>
  -------------------code----------------------

* **Data directory missing error**:

  -------------------code----------------------
  data/db not found
  -------------------code----------------------

  → Create it manually:

  -------------------code----------------------
  mkdir -p /data/db
  sudo chown -R $(whoami) /data/db
  -------------------code----------------------

---


* ** Data directory /data/db not found.
-------------------code----------------------
NonExistentPath: Data directory /data/db not found.
Create the missing directory or specify another path using --dbpath.
exitCode: 100
-------------------code----------------------

MongoDB is **not running** because it **couldn’t find the default data directory `/data/db`**.
Here’s the key part from your output:

-------------------code----------------------
NonExistentPath: Data directory /data/db not found.
Create the missing directory or specify another path using --dbpath.
exitCode: 100
-------------------code----------------------

Let’s fix that step-by-step on macOS:

---

if we have the DB file before 
-------------------code----------------------
mongod --dbpath /opt/homebrew/var/mongodb
-------------------code----------------------

if not use this instruction
### **1. Create the required data directory**

MongoDB stores its database files in `/data/db` by default.
Create it manually with the following commands:

-------------------code----------------------
sudo mkdir -p /data/db
sudo chown -R $(whoami) /data/db
-------------------code----------------------

Explanation:

* `mkdir -p /data/db` → creates the folder (including any missing parents)
* `chown -R $(whoami)` → gives you permission to read/write in it (MongoDB won’t run otherwise)

---

### **2. Start MongoDB again**

Now rerun:

-------------------code----------------------
mongod
-------------------code----------------------

You should see a long log ending with something like:

-------------------code----------------------
Waiting for connections on port 27017
-------------------code----------------------

That means MongoDB is now running successfully.

---

### **3. (Optional) Specify a custom data directory**

If you’d rather keep MongoDB’s data inside your project or your home folder, you can start it like this:

-------------------code----------------------
mongod --dbpath ~/mongodb-data
-------------------code----------------------

The first time, create that directory:

-------------------code----------------------
mkdir -p ~/mongodb-data
-------------------code----------------------

---

### **4. Verify MongoDB is working**

In a **new terminal tab** (keep `mongod` running), run:

-------------------code----------------------
mongosh
-------------------code----------------------

You should see:

-------------------code----------------------
test>
-------------------code----------------------

That means you’re successfully connected to your MongoDB server.

---

### **Summary**

| Problem                                    | Solution                                             |
| ------------------------------------------ | ---------------------------------------------------- |
| `NonExistentPath: /data/db not found`      | Create `/data/db` or specify `--dbpath`              |
| MongoDB shuts down immediately             | The data directory doesn’t exist or lacks permission |
| Want MongoDB to always start automatically | Use `brew services start mongodb-community@8.2`      |

---

*** 2- Handling Rejected Promises ***
---

### **Handling Unhandled Promise Rejections**

1. **Problem Overview**

   * An *unhandled promise rejection* occurs when a promise fails but its rejection is not properly handled.
   * This usually happens with asynchronous code, either using:

     * **Promise syntax (`then`)** without `catch`
     * **Async/await** without `try/catch`
   * If unhandled, Node.js may terminate the process in future versions, making the server unavailable to clients.

2. **Example in the Genres Module**

   * Current implementation:

     * Uses `await` to fetch genres.
     * No `try/catch` block is used to handle rejected promises.
   * Equivalent in promise syntax:

     -------------------code----------------------
     getGenres()
       .then(data => res.send(data))
       // Missing .catch to handle errors
     -------------------code----------------------

3. **Solution: Add Error Handling**

   * Wrap asynchronous code in a `try` block.
   * Use `catch` to handle exceptions.
   * Send a proper response to the client:

     -------------------code----------------------
     try {
       const genres = await Genre.find();
       res.send(genres);
     } catch (ex) {
       res.status(500).send('Something failed.');
       // Optional: log exception for debugging
       console.error(ex);
     }
     -------------------code----------------------
   * Key points:

     * **Async/await → use `try/catch`.**
     * **Promise `then` → always chain `catch`.**
     * Return appropriate HTTP status code (e.g., `500 Internal Server Error`) and a clear message.

4. **Demonstration Workflow**

   1. Start MongoDB (`mongod`) in one terminal.
   2. Run the Vid.ly Node application in another terminal.
   3. Test API endpoints using Postman:

      * Initially, requests succeed when MongoDB is running.
      * Stop MongoDB during testing to simulate a failure.
      * Send a request to `/api/genres`.
   4. Result:

      * Client receives `500 Internal Server Error` with message `'Something failed.'`
      * Terminal no longer shows unhandled promise rejection.
      * Server process continues running despite the temporary database outage.

5. **Key Takeaways**

   * Proper error handling prevents server crashes.
   * Always log exceptions for later debugging and analysis.
   * Incrementally improve the application by handling errors step by step.

---


*** 3- Express Error Middleware ***
### Lecture Notes: Centralized Error Handling in Express

---

#### 1. Problem with the Current Implementation

* In the previous implementation, each route handler used its own `try-catch` block to handle errors.
* This approach has several issues:

  * If we want to **change the error message** sent to the client, we must update it in **every route handler**.
  * In real-world applications, we often **log exceptions**. If we later decide to change how we log them, we must update **multiple files** again.
* The goal is to **centralize error handling** so that any changes in error handling or logging can be made in **a single place**.

---

#### 2. Express Error-Handling Middleware

* Express provides a **special type of middleware** for handling errors.
* This middleware function is defined with **four parameters**:

  -------------------code----------------------
  function (err, req, res, next) { ... }
  -------------------code----------------------
* It must be **registered after all other middleware** using:

  -------------------code----------------------
  app.use(errorMiddleware);
  -------------------code----------------------
* This ensures that if an error occurs anywhere in the app, it will eventually be passed to this middleware.

---

#### 3. Refactoring Error Handling

1. **In `index.js`**:

   * Register the error-handling middleware **after all other middleware**.
   * Example:

     -------------------code----------------------
     app.use(function (err, req, res, next) {
       // Centralized error-handling logic
     });
     -------------------code----------------------
2. **In `genres.js`** (or any route file):

   * Add the `next` parameter to the route handler.
   * Replace the `catch` logic with:

     -------------------code----------------------
     catch (ex) {
       next(ex);
     }
     -------------------code----------------------
   * This forwards the exception to the centralized error middleware.

---

#### 4. Creating a Dedicated Error Middleware Module

To improve **separation of concerns**, move the error-handling logic to its own file.

1. Create a new file:
   **`middleware/error.js`**

   -------------------code----------------------
   module.exports = function (err, req, res, next) {
     // Handle and log the error
     res.status(500).send('Something failed.');
   };
   -------------------code----------------------

2. In **`index.js`**, import and register it:

   -------------------code----------------------
   const error = require('./middleware/error');
   app.use(error);
   -------------------code----------------------

   Note: Pass the **reference** to the function, not its **execution** — do not use parentheses.

---

#### 5. Benefits of This Design

* **Single point of maintenance**: All error-handling logic is centralized.
* **Better separation of concerns**: Route handlers focus on business logic, not error management.
* **Easier future changes**: Updating logging behavior or error responses only requires modifying one module.

---

#### 6. Remaining Issue

* Each route still contains a **repetitive `try-catch` block**.
* This repetition can be avoided by improving the design further.
* The next lecture will cover how to **eliminate repetitive try-catch blocks** and make error handling even cleaner.

*** 4- Removing Try Catch Blocks ***
### Lecture Notes: Eliminating Repetitive Try-Catch Blocks Using Async Middleware in Express

---

#### 1. Problem with Repetitive Try-Catch Blocks

* Each route handler currently uses its own `try-catch` block to handle errors.
* This leads to:

  * **Repetition**: The same pattern appears in every route handler.
  * **Code clutter**: It distracts from the actual business logic of each route.
* The goal is to **remove repetitive try-catch logic** and handle it in one reusable function.

---

#### 2. Introducing the Async Middleware Pattern

* The idea is to create a **higher-order function** that wraps route handlers.
* This wrapper automatically catches errors and forwards them to the centralized error-handling middleware.

---

#### 3. Defining the Async Middleware Function

We start by creating a template function for handling async route functions:

-------------------code----------------------
function asyncMiddleware(handler) {
  return async (req, res, next) => {
    try {
      await handler(req, res);
    } catch (ex) {
      next(ex);
    }
  };
}
-------------------code----------------------

**Explanation:**

* The function `asyncMiddleware` takes a **route handler function** (`handler`) as an argument.
* It **returns a new function** that Express can call as a route handler.
* This returned function:

  * Accepts `(req, res, next)` — the standard Express parameters.
  * Executes the given handler inside a `try` block.
  * If an exception occurs, it automatically calls `next(ex)` to pass the error to the global error handler.

---

#### 4. Why We Return a Function

* In Express, when we define a route:

  -------------------code----------------------
  router.get('/', (req, res) => { ... });
  -------------------code----------------------

  we **pass a reference** to a handler function.
* Express itself calls that handler later and injects `req`, `res`, and `next`.
* Therefore, our middleware must **return** a function that Express can call later — not call it immediately.
* The `asyncMiddleware` serves as a **factory function**, producing a handler that Express can invoke.

---

#### 5. Using the Async Middleware in a Route

Instead of writing:

-------------------code----------------------
router.get('/', async (req, res, next) => {
  try {
    const genres = await Genre.find();
    res.send(genres);
  } catch (ex) {
    next(ex);
  }
});
-------------------code----------------------

We can now simplify it to:

-------------------code----------------------
router.get('/', asyncMiddleware(async (req, res) => {
  const genres = await Genre.find();
  res.send(genres);
}));
-------------------code----------------------

**Benefits:**

* No need to manually handle `try-catch` in each route.
* Cleaner and more readable route handlers.
* Errors are still properly forwarded to the central error middleware.

---

#### 6. Moving the Middleware to a Separate Module

To make this utility reusable, we extract it into its own file.

**File:** `middleware/async.js`

-------------------code----------------------
module.exports = function (handler) {
  return async (req, res, next) => {
    try {
      await handler(req, res);
    } catch (ex) {
      next(ex);
    }
  };
};
-------------------code----------------------

**Usage in a Route File (e.g., `genres.js`):**

-------------------code----------------------
const express = require('express');
const router = express.Router();
const asyncMiddleware = require('../middleware/async');

router.get('/', asyncMiddleware(async (req, res) => {
  const genres = await Genre.find();
  res.send(genres);
}));

module.exports = router;
-------------------code----------------------

---

#### 7. Benefits of This Approach

* **Removes repetitive try-catch blocks** from route handlers.
* **Improves readability**: The core logic of each route is clearer.
* **Promotes reuse**: The same `asyncMiddleware` function can be used across all routes.
* **Maintains centralized error handling**: All exceptions are still routed through the global error middleware.

---

#### 8. Summary

* We introduced an **async middleware** function that wraps route handlers.
* It automatically handles exceptions by passing them to Express’s error middleware.
* This approach enhances code **cleanliness**, **reusability**, and **maintainability**.
* The application now has:

  * A centralized error handler (in `error.js`).
  * A reusable async wrapper (in `async.js`).
  * Clean route handlers free of redundant try-catch logic.


*** 5- Express Async Errors ***
### Lecture Notes: Simplifying Async Error Handling with `express-async-errors`

---

#### 1. Background

* In the previous lecture, we created a custom `asyncMiddleware` function to handle asynchronous errors.
* This solved the problem of repetitive `try-catch` blocks but introduced another issue:

  * We had to **remember to wrap every route handler** with `asyncMiddleware`.
  * This added extra code noise and slightly reduced readability.

---

#### 2. Goal

* To **simplify the code further** by eliminating the need to manually wrap route handlers.
* We will use an existing **npm module** that automatically handles async errors in Express route handlers.

---

#### 3. Introducing the `express-async-errors` Module

* This module automatically patches Express to catch errors from asynchronous route handlers.
* It works by **monkey patching** Express’s internal behavior at runtime.
* Once imported, it wraps all async route handlers internally, so we don’t have to use our custom wrapper.

---

#### 4. Installing the Module

In the terminal, run:

-------------------code----------------------bash
npm install express-async-errors
-------------------code----------------------

**Note:**

* Be careful not to confuse it with a similar package called `express-async-error`.
* We are using `express-async-errors` (plural).
* Version used in the lecture: **2.1.0**

---

#### 5. Using the Module

In your main application file (`index.js`):

-------------------code----------------------
require('express-async-errors');
-------------------code----------------------

**Explanation:**

* You don’t need to assign the result to a constant.
* Just importing it is enough to enable its functionality.
* This must be done **at the start** of your application so it patches Express early.

---

#### 6. Simplifying Route Handlers

Now that `express-async-errors` is installed and loaded:

* You can remove the custom `asyncMiddleware` wrapper entirely.
* Your route handlers can return to their original, simpler form.

**Before (with asyncMiddleware):**

-------------------code----------------------
router.get('/', asyncMiddleware(async (req, res) => {
  const genres = await Genre.find();
  res.send(genres);
}));
-------------------code----------------------

**After (with express-async-errors):**

-------------------code----------------------
router.get('/', async (req, res) => {
  const genres = await Genre.find();
  res.send(genres);
});
-------------------code----------------------

**Also:**

* Remove the `require('../middleware/async')` line at the top of your file.
* The routes are now cleaner and more readable.

---

#### 7. Testing the Implementation

**Steps:**

1. Start MongoDB (`mongod`).
2. Run your application.
3. Test the endpoint (e.g., `GET /api/genres`) using Postman — it should return the expected data.
4. Stop MongoDB to simulate a database failure.
5. Send the same request again.

**Expected Result:**

* You should receive a **500 Internal Server Error** response.
* The global error-handling middleware in your app will handle and respond to the error automatically.

---

#### 8. Summary

* The `express-async-errors` module eliminates the need for manual `try-catch` or custom async wrappers.
* It provides a **cleaner and more maintainable** way to handle async errors in Express.
* Recommended approach:

  * Use `express-async-errors` for simplicity.
  * If it does not work properly in your environment, fall back to using your custom `asyncMiddleware` function.

---

#### 9. Final Recommendation

* For most modern Express applications, **`express-async-errors`** is the preferred solution for handling asynchronous errors.
* It offers:

  * **Less boilerplate**
  * **Better readability**
  * **Automatic error propagation** to centralized middleware
* Keep the `asyncMiddleware` file as a **backup** in case you encounter compatibility issues in the future.


*** 6- Logging Errors ***

### Lecture Notes: Logging Errors in Express Using Winston

---

#### 1. Introduction to Error Logging

* In enterprise applications, logging errors is **essential**.
* Logs help developers **review exceptions**, identify **problem areas**, and **improve reliability**.
* In this lecture, we introduce a **popular Node.js logging library** called **Winston**.

---

#### 2. About Winston

* Winston is one of the most widely used logging libraries in the Node.js ecosystem.
* It is **feature-rich**, **configurable**, and supports **multiple transports** (ways of storing or sending logs).
* Version used in the lecture: **2.4.0**
* Over **6.5 million monthly downloads** on NPM, indicating its popularity.

---

#### 3. Installation

In your terminal, run:

-------------------code----------------------
npm install winston
-------------------code----------------------

---

#### 4. Loading and Configuring Winston

In your `index.js` file:

-------------------code----------------------
const winston = require('winston');
-------------------code----------------------

* The `winston` object represents the **default logger**.
* For most small to medium-sized applications, the default logger is sufficient.
* Larger enterprise applications might create **custom loggers** with unique configurations for different modules.

---

#### 5. Understanding Winston Transports

A **transport** in Winston is a **storage mechanism** for logs.
It determines **where** your logs are written.

Common built-in transports:

* **Console** – logs messages to the terminal (default).
* **File** – logs messages to a file.
* **HTTP** – sends logs to a remote HTTP endpoint.

Other community plugins support:

* **MongoDB**
* **CouchDB**
* **Redis**
* **Loggly** (a cloud log management service)

By default, Winston logs to the **console**, but we can easily add a file transport.

---

#### 6. Adding a File Transport

In `index.js`, after importing Winston:

-------------------code----------------------
winston.add(winston.transports.File, { filename: 'logfile.log' });
-------------------code----------------------

* This line adds another transport to log messages to a file named `logfile.log`.
* Winston now logs both to the **console** and the **file** simultaneously.

---

#### 7. Using Winston in the Error Middleware

Open your **error-handling middleware** file (`middleware/error.js`):

-------------------code----------------------
const winston = require('winston');

module.exports = function (err, req, res, next) {
  winston.error(err.message, err);
  res.status(500).send('Something failed.');
};
-------------------code----------------------

**Explanation:**

* `winston.error()` logs an error-level message.
* The first argument is the message (`err.message`).
* The second argument (`err`) passes the full error object as metadata (includes the stack trace).
* This way, all error details are captured automatically.

---

#### 8. Logging Levels in Winston

Winston supports **different logging levels** that represent message importance:

| Level   | Purpose                              |
| ------- | ------------------------------------ |
| error   | Critical failures and exceptions     |
| warn    | Warnings or recoverable issues       |
| info    | General operational information      |
| verbose | Detailed logging information         |
| debug   | Developer-level debugging details    |
| silly   | Very fine-grained logs (rarely used) |

Example:

-------------------code----------------------
winston.error('Database connection failed');
winston.warn('Low disk space');
winston.info('Connected to MongoDB');
-------------------code----------------------

---

#### 9. Demonstration

1. In `genres.js`, simulate an error:

   -------------------code----------------------
   throw new Error('Could not get the genres');
   -------------------code----------------------
2. Run the application:

   -------------------code----------------------
   node index.js
   -------------------code----------------------
3. Send a request to `/api/genres` using Postman.
4. The error middleware will catch the exception and log it through Winston.

**Output:**

* In the **console**:

  -------------------code----------------------
  error: Could not get the genres
  Stack trace...
  -------------------code----------------------
* In the **logfile.log** file:

  -------------------code----------------------on
  {
    "message": "Could not get the genres",
    "stack": "...",
    "level": "error",
    "timestamp": "2025-11-13T09:00:00Z"
  }
  -------------------code----------------------

---

#### 10. Benefits of Using Winston

* Centralized and structured logging.
* Multiple output destinations via transports.
* JSON-formatted logs for easy analysis.
* Metadata support for full context (e.g., stack traces).
* Integration-ready with monitoring services like Loggly or ELK stack.

---

#### 11. Summary

* Logging is a crucial part of production-grade Express applications.
* **Winston** provides a flexible and scalable way to log application events and errors.
* Key points:

  * Install and import Winston.
  * Add a file transport for persistent logging.
  * Use `winston.error()` inside the error middleware.
  * Review `logfile.log` to analyze issues later.
* In the next lecture, we will extend Winston to **log errors to MongoDB** for even better traceability.





-------------------code----------------------
Error: Invalid transport, must be an object with a log method.
-------------------code----------------------

— means that the **transport** you passed to `winston.add()` was not constructed correctly.
This usually happens when using **newer versions of Winston (v3+)** but following the **old v2 syntax** from the lecture.

Let’s fix it step by step.

---

### 1. Identify the cause

In your code, you probably have something like this:

-------------------code----------------------
winston.add(winston.transports.File, { filename: 'logfile.log' });
-------------------code----------------------

That syntax was valid in **Winston v2**, but **invalid in v3 or later**.

In Winston 3+, transports must be instantiated with `new`.

---

### 2. Correct syntax for Winston 3+

Change your configuration in `index.js` to this:

-------------------code----------------------
const winston = require('winston');

winston.add(new winston.transports.File({ filename: 'logfile.log' }));
-------------------code----------------------

That’s it — this works correctly with Winston v3 and later.

---

### 3. Optional: Combine multiple transports

If you want to log both to the console and to a file, you can configure the logger like this:

-------------------code----------------------
const winston = require('winston');

winston.add(new winston.transports.Console());
winston.add(new winston.transports.File({ filename: 'logfile.log' }));
-------------------code----------------------

---

### 4. Use it in your error middleware

In your error-handling middleware (for example `middleware/error.js`):

-------------------code----------------------
const winston = require('winston');

module.exports = function (err, req, res, next) {
  winston.error(err.message, err);
  res.status(500).send('Something failed.');
};
-------------------code----------------------

---

### 5. Summary of fix

| Problem                                                                   | Fix                                                      |
| ------------------------------------------------------------------------- | -------------------------------------------------------- |
| Used old Winston 2 syntax (`winston.add(winston.transports.File, {...})`) | Use new syntax with `new winston.transports.File({...})` |
| Thrown error: “Invalid transport, must be an object with a log method.”   | Caused by missing `new` keyword when adding transport    |
| Version mismatch                                                          | Make sure you use proper API for the installed version   |

---

If you want to confirm which version of Winston you have, run:

-------------------code----------------------
npm list winston
-------------------code----------------------

If it shows **3.x or 4.x**, the new syntax above is required.


*** 7- Logging to MongoDB ***
### Lecture Notes: Logging Messages to MongoDB with Winston

---

#### 1. Introduction

In this lecture, we extend our logging setup to store log messages in **MongoDB** using the **winston-mongodb** transport module.

Logging to MongoDB is useful for centralizing logs, analyzing them, or integrating them into monitoring tools.

---

#### 2. Installing the MongoDB Transport

There is a known issue with the latest release candidate (`4.0.0`) of `winston-mongodb`, so we install the stable version `3.0.0` instead.

**Command:**

-------------------code----------------------
npm install winston-mongodb@3.0.0
-------------------code----------------------

Make sure to use this exact version, as the newer release candidate may not work with the examples shown here.

---

#### 3. Setting Up Winston with MongoDB Transport

In **index.js**, after requiring Winston, we also require `winston-mongodb`.

**Example setup:**

-------------------code----------------------
const winston = require('winston');
require('winston-mongodb');
-------------------code----------------------

We don’t need to assign the `require('winston-mongodb')` result to a variable — simply requiring it adds the MongoDB transport to Winston.

Now we can add a new transport to Winston.

**Example:**

-------------------code----------------------
winston.add(winston.transports.MongoDB, {
  db: 'mongodb://localhost/vidly'
});
-------------------code----------------------

This tells Winston to log messages to the MongoDB database named `vidly`.

---

#### 4. Logging in Practice

We already have Winston configured to log errors (from our error middleware).
Now, every time an error occurs, Winston will automatically:

* Log it to the console
* Log it to a log file
* Log it to MongoDB (via the new transport)

---

#### 5. Testing the Configuration

1. Run the application:

   -------------------code----------------------
   node index.js
   -------------------code----------------------

2. In **Postman**, send a request to the `/api/genres` endpoint (which throws an error).

3. Open **MongoDB Compass** and refresh the `vidly` database.

4. You’ll see a new collection named **log**.

Each document in the **log** collection includes:

* **timestamp** – when the error occurred
* **level** – the logging level (e.g., `error`)
* **message** – the log message
* **meta** – the metadata (stack trace and error details)

Example structure:

-------------------code----------------------on
{
  "_id": "...",
  "timestamp": "2025-11-13T10:25:00Z",
  "level": "error",
  "message": "Could not get the genres",
  "meta": {
    "message": "Could not get the genres",
    "name": "Error",
    "stack": "Error: Could not get the genres\n   at ..."
  }
}
-------------------code----------------------

---

#### 6. Logging Levels

Winston supports multiple logging levels:

1. **error**
2. **warn**
3. **info**
4. **verbose**
5. **debug**
6. **silly**

You can restrict which levels get stored in MongoDB.

For example, if you only want to log **errors**, modify the transport configuration:

-------------------code----------------------
winston.add(winston.transports.MongoDB, {
  db: 'mongodb://localhost/vidly',
  level: 'error'
});
-------------------code----------------------

If you set the level to `info`, Winston will log **error**, **warn**, and **info** messages — but not `debug` or `verbose`.

---

#### 7. Summary

| Step            | Description                                                                    |
| --------------- | ------------------------------------------------------------------------------ |
| Install package | `npm install winston-mongodb@3.0.0`                                            |
| Require module  | `require('winston-mongodb')`                                                   |
| Add transport   | `winston.add(winston.transports.MongoDB, { db: 'mongodb://localhost/vidly' })` |
| Test            | Trigger an error and view the `log` collection in MongoDB                      |
| Optional        | Limit log level with `{ level: 'error' }`                                      |

---

This setup allows Winston to log errors to both a **file** and **MongoDB**, providing a robust and scalable logging system for production applications.

That error —

-------------------code----------------------
Error: You should provide db to log to.
-------------------code----------------------

— means Winston’s MongoDB transport didn’t receive the `db` connection string properly when you called `winston.add()`.

Let’s fix this cleanly and make sure it works with `winston-mongodb@3.0.0`.

---

### Correct Setup for `winston-mongodb@3.0.0`

In your **index.js**, make sure this section looks like the following:

-------------------code----------------------
const winston = require('winston');
require('winston-mongodb');

// Add file transport
winston.add(new winston.transports.File({ filename: 'logfile.log' }));

// Add MongoDB transport
winston.add(new winston.transports.MongoDB({
  db: 'mongodb://localhost/vidly', // make sure this matches your database name
  level: 'error' // optional — only log errors
}));
-------------------code----------------------

**Important points:**

1. You must use `new winston.transports.MongoDB(...)`, **not** `winston.add(winston.transports.MongoDB, {...})`.
2. The `db` field must be a **valid MongoDB URI** string.
3. Make sure MongoDB is running locally (`mongod`).

---

### ⚙️ Why the Error Happened

In older tutorials or Winston v2 code, you might see:

-------------------code----------------------
winston.add(winston.transports.MongoDB, { db: 'mongodb://localhost/vidly' });
-------------------code----------------------

That syntax no longer works with Winston v3+.
The correct syntax uses the `new` keyword to create the transport instance.

---

Example Full Snippet

Your top section of **index.js** should look like:

-------------------code----------------------
const express = require('express');
const winston = require('winston');
require('winston-mongodb');

const app = express();

// Winston transports
winston.add(new winston.transports.File({ filename: 'logfile.log' }));
winston.add(new winston.transports.MongoDB({
  db: 'mongodb://localhost/vidly',
  level: 'error'
}));

app.listen(3001, () => winston.info('Listening on port 3001...'));
-------------------code----------------------

---

### Test Steps

1. Ensure MongoDB is running:

   -------------------code----------------------
   mongod
   -------------------code----------------------
2. Start your app:

   -------------------code----------------------
   nodemon index.js
   -------------------code----------------------
3. Trigger an error (e.g., from your `/api/genres` route).
4. Check **MongoDB Compass** → `vidly` database → `log` collection.

You should now see log documents appearing there with fields like:

-------------------code----------------------on
{
  "level": "error",
  "message": "Could not get the genres",
  "timestamp": "2025-11-13T10:35:00Z"
}
-------------------code----------------------

---

Would you like me to show you how to move this Winston configuration into a dedicated `startup/logging.js` module (for a cleaner structure, like in real-world apps)?

Good question — you can check your **MongoDB database name** in several simple ways depending on how you’re connected.
Here are the most common options:

---

### **1. If You’re Using MongoDB Compass (GUI)**

1. Open **MongoDB Compass**.
2. Connect to your server (e.g., `mongodb://localhost:27017`).
3. On the left sidebar, you’ll see a list of databases such as:

   -------------------code----------------------
   admin
   config
   local
   vidly
   test
   -------------------code----------------------
4. The name you use in your Winston configuration should match exactly one of those —
   for example:

   -------------------code----------------------
   db: 'mongodb://localhost/vidly'
   -------------------code----------------------

If you don’t see **vidly**, it means your app hasn’t yet created that database (MongoDB creates databases automatically when data is first inserted).

---

### **2. If You’re Using the Mongo Shell (`mongosh`)**

Run these commands in your terminal:

-------------------code----------------------
mongosh
-------------------code----------------------

Then inside the shell:

-------------------code----------------------
show dbs
-------------------code----------------------

You’ll see something like:

-------------------code----------------------
admin       0.000GB
config      0.000GB
local       0.000GB
vidly       0.002GB
-------------------code----------------------

The database name is `vidly`.
If you want to use or inspect it:

-------------------code----------------------
use vidly
show collections
-------------------code----------------------

---

### **3. If You Want to Confirm from Your App Code**

In your Node.js code (for example, in your MongoDB connection module), check the URI used to connect:

-------------------code----------------------
mongoose.connect('mongodb://localhost/vidly', { useNewUrlParser: true, useUnifiedTopology: true });
-------------------code----------------------

Here, `vidly` at the end of the URI is your **database name**.

---

### **4. If You Haven’t Created Any Collections Yet**

MongoDB won’t show an empty database.
You’ll only see it after your app writes data to it (for example, when you create a collection like `genres` or when Winston writes logs).

---


*** 8- Uncaught Exceptions ***
---

# Handling Uncaught Exceptions in Node.js (Outside Express)

## 1. Context: Express Error Middleware Limitations

* Express error-handling middleware only catches errors that occur **during the request–response pipeline**.
* If an error is thrown **outside** Express — for example, during application startup — Express middleware will not catch it.
* Example: Throwing an error directly in `index.js` (before handling any requests) will **crash the process**, and Winston will **not** log the error.

## 2. Demonstration of the Problem

1. In `index.js`, after configuring Winston, add:

   -------------------code----------------------
   throw new Error('Something failed during startup');
   -------------------code----------------------
2. Run the application using `node index.js`.
3. Result:

   * The Node process terminates.
   * The error appears in the console.
   * Winston does not record anything in the log file.
4. This means: if deployed to production, failures occurring outside Express cannot be tracked unless you have server console access.

## 3. Introducing Uncaught Exception Handling

Node.js provides a global `process` object which is an instance of **EventEmitter**.

* EventEmitters publish events.
* You can subscribe to these events using `process.on()`.

There is a special event:

### `uncaughtException`

Triggered whenever an exception is thrown **and not caught** by any `try/catch` block.

## 4. Implementing a Global Uncaught Exception Handler

Add the following at the beginning of your entry file (e.g., `index.js`):

-------------------code----------------------
process.on('uncaughtException', (exception) => {
    console.log('We got an uncaught exception');
    winston.error(exception.message, exception);
});
-------------------code----------------------

### What this does:

* Logs a message to the console.
* Uses Winston to store the exception (message + metadata).
* **Prevents the process from crashing**, because the error is now caught.

## 5. Verifying It Works

1. Rerun the app with the same intentional startup error.
2. You should now see:

   * Console: “We got an uncaught exception”
   * Process does not terminate immediately.
   * Winston log file includes the error “Something failed during startup”.

## 6. Important Notes

* A Node process crashes **only** if an exception is unhandled.
* By handling `uncaughtException`, you gain visibility into errors that happen outside Express.
* This is essential for production environments.

## 7. Next Topic

The next lecture will cover **unhandled promise rejections**, which occur when a Promise is rejected without a `.catch()` handler.

---


*** 9- Unhandled Promise Rejections ***

---

# Handling Unhandled Promise Rejections in Node.js

## 1. Recap: Uncaught Exceptions

* In the previous lecture, you learned how to handle **uncaught exceptions** using:

  -------------------code----------------------
  process.on('uncaughtException', (ex) => { ... });
  -------------------code----------------------
* This catches exceptions thrown in **synchronous** code only.
* It does not work for rejected promises.

---

# 2. Why Uncaught Exception Handlers Do Not Catch Promise Rejections

* Promises operate asynchronously.
* If a promise is rejected and no `.catch()` handler is provided, you get an **unhandled promise rejection**, not an uncaught exception.
* The uncaughtException event does **not** detect this scenario.

### Demonstration

Replace a thrown exception with a rejected promise:

-------------------code----------------------
const p = Promise.reject(new Error('Failed miserably'));

p.then(() => console.log('Done')); // No catch
-------------------code----------------------

Running the app:

* Node prints a warning: *unhandled promise rejection*
* The process does **not** terminate in current Node versions.
* Future Node versions will terminate the process on unhandled promise rejections.

---

# 3. Introducing the `unhandledRejection` Event

Node's `process` object emits another important event:

### `unhandledRejection`

Triggered when:

* A promise is rejected
* No `.catch()` handler is provided

### Adding a handler

-------------------code----------------------
process.on('unhandledRejection', (reason) => {
    winston.error(reason.message, reason);
});
-------------------code----------------------

This allows Winston to log promise-related errors that previously went unnoticed.

---

# 4. Verifying Logging Behavior

Before running the application:

* The log file only contains uncaught exceptions.
* After adding `unhandledRejection` handling:

  * Run the app again.
  * The log file now includes a new entry for the unhandled rejection.
  * This confirms Winston successfully logs asynchronous errors.

---

# 5. Best Practice: Exit the Process After Catching These Errors

Whether you catch:

* `uncaughtException`, or
* `unhandledRejection`

You should terminate the process:

-------------------code----------------------
process.exit(1);
-------------------code----------------------

### Why exit?

* The application may now be in an undefined or corrupted state.
* Restarting ensures a clean and predictable environment.

### How to restart in production?

* Use a **process manager** such as PM2, forever, or systemd.
* These tools automatically restart the application when it exits.

---

# 6. Using Winston’s `handleExceptions` Instead of Manual Handlers

Winston provides a built-in helper:

-------------------code----------------------
winston.handleExceptions(
    new winston.transports.File({ filename: 'uncaughtExceptions.log' })
);
-------------------code----------------------

Key points:

* This automatically logs uncaught exceptions.
* You can use one or multiple transports.
* You may log to a file, MongoDB, or both.

### Choosing file vs database logging

* Databases are better for querying and analyzing logs.
* File system is more reliable when the database is down.
* The recommended approach is to use **both** transports.

---

# 7. Handling Unhandled Rejections with Winston’s Exception Handler

At the time this lecture was recorded:

* `handleExceptions` works only for **uncaught exceptions**, not unhandled rejections.

### Making it work for rejected promises

Instead of manually logging the rejection:

-------------------code----------------------
process.on('unhandledRejection', (ex) => {
    throw ex;
});
-------------------code----------------------

This converts the rejection into an uncaught exception:

* Winston’s `handleExceptions` handler catches it
* Logs it automatically
* Terminates the process

This keeps error handling unified and centralized.

---

# 8. Summary

### What we now handle:

1. **Uncaught Exceptions**

   * Using `winston.handleExceptions` or `process.on('uncaughtException')`

2. **Unhandled Promise Rejections**

   * Using `process.on('unhandledRejection')`
   * Then rethrowing the error to let Winston handle it

### Best practice:

* **Always exit the process** after handling these fatal errors.
* Use a **process manager** in production to restart the application.

---

*** 10- Error Handling Recap ***

---

# Two-Minute Summary: Error Handling in Node.js and Express

## 1. Express Error Middleware

* Express provides an error-handling middleware function with four parameters:
  `(err, req, res, next)`
* This middleware catches **only errors that occur during the request–response pipeline**.
* In this middleware:

  * Use Winston to log the error.
  * Return a 500 Internal Server Error with a safe, generic message for the client.

### Limitation

* This middleware does **not** catch errors that occur **outside Express**, such as:

  * Startup errors
  * Background tasks
  * Initialization failures

---

## 2. Handling Errors Outside Express

### Uncaught Exceptions

* Startup and synchronous code errors must be handled at the Node.js process level.
* In `index.js`, use:

  -------------------code----------------------
  winston.handleExceptions(new winston.transports.File({ filename: 'uncaughtExceptions.log' }));
  -------------------code----------------------
* This logs any uncaught exception that would otherwise crash the process.

### Important Limitation

* At the time of recording, `handleExceptions` works for **uncaught exceptions** only.
* It does **not** automatically handle **unhandled promise rejections**.

---

## 3. Handling Unhandled Promise Rejections

* Subscribe to Node's `process.on('unhandledRejection')` event.
* In the handler, **throw** the rejection:

  -------------------code----------------------
  process.on('unhandledRejection', (ex) => {
      throw ex;
  });
  -------------------code----------------------
* By rethrowing, Winston’s exception handler captures the error:

  * Logs it
  * Terminates the process

---

## 4. Best Practice: Terminate the Process After Fatal Errors

* Whether handling an uncaught exception or an unhandled rejection:

  * The Node process may be left in an inconsistent or unreliable state.
  * The correct action is to terminate the process:

    -------------------code----------------------
    process.exit(1);
    -------------------code----------------------
* In production, a **process manager** should restart the app automatically.

### Common Process Managers

* PM2
* Systemd
* Forever

---

## 5. Current State of `index.js`

* The entry file has become cluttered:

  * Many responsibilities
  * Too many require statements
  * Too much configuration logic in one place
* This structure is not suitable for production or enterprise applications.

---

## 6. Upcoming Steps

* The next lectures will cover:

  * Refactoring `index.js`
  * Separating concerns into modules
  * Organizing the application setup into clean, maintainable components

---

*** 11- Extracting Routes ***
---

# Refactoring `index.js`: Separating Concerns and Extracting Routes

## 1. Problem: Lack of Separation of Concerns

The current `index.js` file contains multiple unrelated responsibilities:

* Numerous `require` statements at the top (too many dependencies).
* Code for handling and logging errors.
* Application configuration logic.
* MongoDB connection logic.
* Route and middleware setup.

These concerns should not be mixed in a single module.
The `index.js` file should focus only on **orchestrating** the application, not implementing all details.

---

# 2. Goal: Move Route Setup to a Separate Module

To improve structure and maintainability, we will extract all routing and middleware setup code into a separate module.

---

# 3. Creating the `startup` Folder and `routes.js`

1. Create a new folder named `startup`.
2. Inside it, create a new file called `routes.js`.
3. Export a function that receives the `app` object:

   -------------------code----------------------
   module.exports = function(app) {
       // route setup and middleware go here
   }
   -------------------code----------------------

This function will contain:

* All route registration
* All middleware registration
* The error middleware

---

# 4. Moving Route Setup from `index.js` to `routes.js`

In `index.js`, locate all code responsible for:

* Loading routers (genres, customers, movies, rentals, users, auth)
* Applying middleware (express.json, routes)
* Registering the error middleware

Cut all this code and paste it inside the new function in `routes.js`.

---

# 5. Handling Dependencies

### The `app` object

* `app` should be created **once** in the entire application.
* Therefore, `routes.js` should **not** create its own Express instance.
* Instead, `index.js` passes the existing `app`:

-------------------code----------------------
const app = express();
require('./startup/routes')(app);
-------------------code----------------------

### Importing required modules

* The routers (genres, customers, movies, etc.) should be imported inside `routes.js`.
* Since they are only used there, they no longer belong in `index.js`.

### Importing Express

* `routes.js` needs Express functions like `express.json()`.
* Add at the top:

  -------------------code----------------------
  const express = require('express');
  -------------------code----------------------

---

# 6. Moving the Error Middleware

* Find the error middleware function in `index.js`.
* Cut and paste it into `routes.js`, because this is the only module that uses it.

---

# 7. Cleaning Up `index.js`

After extracting all routing logic:

* `index.js` becomes shorter and clearer.
* Unnecessary `require` statements for routers are removed.
* The module now focuses on high-level application setup.

---

# 8. Updating Router Paths

Because `routes.js` now lives inside the `startup` folder, router imports need updated relative paths:

Change:

-------------------code----------------------
require('./routes/genres')
-------------------code----------------------

to:

-------------------code----------------------
require('../routes/genres')
-------------------code----------------------

Use multi-cursor editing in VS Code:

* On Mac: Command + D
* On Windows: Control + D

This allows replacing all path prefixes at once.

---

# 9. Exercise

As homework:

* Return to `index.js`.
* Move all MongoDB initialization code to a new module in the `startup` folder.
* Implement the same separation-of-concerns pattern.

The next lecture will show the instructor’s solution.

---


*** 12- Extracting the Db Logic ***
---

# Refactoring Database Initialization into `startup/db.js`

## 1. Goal

Extract database initialization logic from `index.js` into a dedicated module to improve separation of concerns and keep the entry file clean and focused.

---

# 2. Creating the Database Module

### Step 1: Create `startup/db.js`

Inside the `startup` folder, add a new file named `db.js`.

### Step 2: Export a Function

The module should export a function just like the routes module:

-------------------code----------------------
module.exports = function() {
    // database initialization logic
};
-------------------code----------------------

---

# 3. Moving the Database Initialization Code

Cut all database-related code from `index.js` and paste it inside the exported function in `db.js`.

This includes:

* The MongoDB connection logic using Mongoose.
* Any connection configuration.

---

# 4. Improving Logging Behavior

Originally, the database connection printed a message using `console.log`.
We want to replace this with proper structured logging using Winston.

### Step 1: Import Winston

Add at the top of `db.js`:

-------------------code----------------------
const winston = require('winston');
-------------------code----------------------

### Step 2: Replace `console.log`

Change the success message from:

-------------------code----------------------
console.log('Connected to MongoDB...');
-------------------code----------------------

to:

-------------------code----------------------
winston.info('Connected to MongoDB...');
-------------------code----------------------

This ensures consistent logging across the application.

---

# 5. Removing the Catch Block

Originally, the database connection call had a `.catch()`:

-------------------code----------------------
mongoose.connect(...)
  .then(...)
  .catch(err => console.error(err));
-------------------code----------------------

This catch block must be removed because:

* The rejected promise should be handled globally by the unhandled rejection handler.
* We want Winston to log the error and terminate the process automatically.
* Local handling here prevents the global error system from receiving the error.

So, remove the `.catch()` entirely.

---

# 6. Importing Mongoose

Remove the `mongoose` import from `index.js` and place it at the top of `db.js`:

-------------------code----------------------
const mongoose = require('mongoose');
-------------------code----------------------

Now, the database module has all its required dependencies and stays fully self-contained.

---

# 7. Final Structure of `db.js`

The module is now clean, short, and has a single responsibility: connecting to MongoDB.

---

# 8. Connecting the Module in `index.js`

In `index.js`, load and invoke the new database module:

-------------------code----------------------
require('./startup/db')();
-------------------code----------------------

This performs the database initialization during application startup.

---

# 9. Verifying Behavior

To test that the new structure works correctly:

1. Stop the MongoDB process.
2. Run the application with:

   -------------------code----------------------
   node index.js
   -------------------code----------------------
3. Result:

   * A connection error occurs.
   * The global unhandled rejection handler logs the exception.
   * The process terminates immediately.
   * `uncaughtExceptions.log` contains the logged error.

This confirms everything is behaving as intended.

---

# 10. Next Exercise

As your next task:

**Extract all logging initialization code from `index.js` into a new module named `startup/logging.js`.**

This will continue improving the structure of the project. The solution will be shown in the next lecture.

---

*** 13- Extracting the Logging Logic ***

---

# Lecture Notes: Extracting Logging Logic into a Separate Module

## 1. Objective

The goal of this lecture is to refactor `index.js` by moving all logging-related logic—Winston setup, handling of rejected promises, and Express async error handling—into a dedicated module named `logging.js` inside the `startup` folder.

---

## 2. Creating the Logging Module

### Step 1: Add `logging.js`

Inside the `startup` folder, create a new file:

-------------------code----------------------
startup/logging.js
-------------------code----------------------

This module will export a function:

-------------------code----------------------
module.exports = function () {
  // logging setup goes here
};
-------------------code----------------------

---

## 3. Moving Logging Setup from `index.js`

### Step 2: Move Winston Configuration

In `index.js`, identify all code related to:

* Setting up Winston
* Adding transports (file, MongoDB, console)
* Handling uncaught exceptions and unhandled promise rejections

Cut that entire block and paste it inside `logging.js` inside the exported function.

### Step 3: Import Required Packages

In `logging.js`, import the necessary modules that were originally imported in `index.js`:

-------------------code----------------------
const winston = require('winston');
require('winston-mongodb');
-------------------code----------------------

These imports should now only exist in `logging.js`.

---

## 4. Handling Async Errors in Express

### Step 4: Import Express Async Errors

This line:

-------------------code----------------------
require('express-async-errors');
-------------------code----------------------

should be moved into `logging.js` as well, because it is part of the error-handling setup.

This ensures that all logic related to error logging is encapsulated in one place.

---

## 5. Loading the Logging Module in `index.js`

### Step 5: Call Logging Module Early

Back in `index.js`, at the top of the startup sequence, require and execute the logging module:

-------------------code----------------------
require('./startup/logging')();
-------------------code----------------------

This must be done before loading other modules so that any potential errors in later modules will be properly logged and the process will terminate if required.

---

## 6. Result of Refactoring

After moving all the logging-related code:

* `index.js` becomes shorter, cleaner, and easier to maintain.
* All logic related to logging, error handling, and Winston configurations is centralized in `logging.js`.
* Startup behavior is more predictable, as errors during initialization are properly logged and handled.

---

## 7. Next Exercise

Move all configuration-related logic from `index.js` into a new module, typically named:

-------------------code----------------------
startup/config.js
-------------------code----------------------

This module should handle checking for essential configuration settings during application startup.

---

