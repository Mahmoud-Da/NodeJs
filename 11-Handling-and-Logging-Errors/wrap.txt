*** 1- Introduction ***
### Lecture Notes: Handling Unexpected Errors in Node.js and MongoDB (Vid.ly App)

---

#### 1. **Introduction**

In the current implementation of the Vid.ly application, the system assumes an *ideal environment* where all operations succeed.
However, in real-world applications, unexpected errors are inevitable — for example, the MongoDB connection might drop unexpectedly.

To build a reliable application, it is crucial to:

* Handle unexpected situations gracefully.
* Send meaningful error responses to the client.
* Log exceptions on the server for future debugging and improvement.

---

#### 2. **Demonstration of a Real-World Scenario**

**Setup:**

* The application runs with **Nodemon**.
* MongoDB server (`mongod`) runs in another terminal, listening on port `27017`.
* A **GET** request is sent from **Postman** to `/api/genres`.

**Normal Behavior:**

* The request returns a `200` response as expected.

**Simulated Failure:**

1. The MongoDB process is stopped using `Ctrl + C`.
2. A new GET request to `/api/genres` is sent.
3. The request hangs for about **30 seconds**.
4. The server terminal displays an **error message**:

   -------------------code----------------------
   UnhandledPromiseRejectionWarning: Unhandled promise rejection.
   Failed to reconnect after 30 attempts with interval 1000 milliseconds.
   -------------------code----------------------

---

#### 3. **MongoDB Driver Behavior**

* By default, if a MongoDB connection fails, the driver retries **30 times**, with **1-second intervals** between attempts.
* After 30 failed attempts, it throws an *unhandled promise rejection*.

---

#### 4. **Deprecation Warning and Node.js Behavior**

A warning appears:

-------------------code----------------------
DeprecationWarning: Unhandled promise rejections are deprecated.
In the future, unhandled rejections will terminate the Node.js process with a non-zero exit code.
-------------------code----------------------

**Implication:**

* Future versions of Node.js will automatically terminate the process if an unhandled promise rejection occurs.
* If the MongoDB server goes down temporarily (e.g., for 1 minute) and then restarts, the Node.js server will have already stopped and won’t be able to handle new client requests.

---

#### 5. **Why Proper Error Handling Matters**

* Without proper handling, a **temporary database outage** can completely **crash the Node process**.
* This means users will experience downtime, even if the database becomes available again shortly afterward.

---

#### 6. **Goal for This Section**

You will learn how to:

* Handle errors from MongoDB and other sources gracefully.
* Prevent the Node process from terminating unexpectedly.
* Log exceptions in a structured way for analysis.
* Maintain application availability during transient failures.

---

#### 7. **Key Takeaways**

* Always anticipate unexpected failures (database, network, etc.).
* Never leave promises unhandled.
* Implement global error handling to prevent server crashes.
* Log all exceptions for monitoring and improvement.
* Aim for fault-tolerant and resilient application design.

#### 8. how to run mango demon in split terminal?

To **run the MongoDB daemon (`mongod`) in a split terminal** while working on your Node.js app, follow these steps depending on your setup:

---

### **1. If You’re Using VS Code**

#### **Step-by-step:**

1. **Open the integrated terminal**
   Press <kbd>Ctrl</kbd> + <kbd>`</kbd> (backtick) or go to
   **View → Terminal**.

2. **Split the terminal**
   Click the **split terminal icon** (looks like two rectangles side by side), or press:

   -------------------code----------------------
   Ctrl + Shift + 5  (Windows/Linux)
   Cmd + Shift + 5   (macOS)
   -------------------code----------------------

3. **In the first terminal**, start your Node.js app:

   -------------------code----------------------
   npm start
   -------------------code----------------------

   or if using Nodemon:

   -------------------code----------------------
   nodemon index.js
   -------------------code----------------------

4. **In the second terminal**, start the MongoDB daemon:

   -------------------code----------------------
   mongod
   -------------------code----------------------

   This will start MongoDB’s background service, usually listening on port `27017`.

---

### **2. If You’re Using a System Installation (Mac/Linux/Windows)**

#### **Check if `mongod` is available**

-------------------code----------------------
mongod --version
-------------------code----------------------

If it’s not found, you need to install MongoDB:

* **macOS (Homebrew):**

  -------------------code----------------------
  brew services start mongodb-community@6.0
  -------------------code----------------------
* **Ubuntu/Debian:**

  -------------------code----------------------
  sudo systemctl start mongod
  -------------------code----------------------
* **Windows (using MongoDB Shell):**

  * Open a **new terminal** or **PowerShell** window.
  * Navigate to the MongoDB `bin` folder (e.g., `C:\Program Files\MongoDB\Server\6.0\bin`)
  * Run:

    -------------------code----------------------powershell
    mongod
    -------------------code----------------------

---

### **3. Using Two Tabs Instead of Split View (Optional)**

If your terminal doesn’t support splits:

* Open two terminal **tabs** or **windows**.
* In the first, run `mongod`.
* In the second, run your Node.js app.

---

### **4. Common Troubleshooting**

* **Port in use error**:

  -------------------code----------------------
  Address already in use on port 27017
  -------------------code----------------------

  → MongoDB may already be running. Check with:

  -------------------code----------------------
  ps aux | grep mongod
  -------------------code----------------------


  Find the process ID (the number right after your username) and stop it:

  -------------------code----------------------
  kill <PID>
  -------------------code----------------------
  
  Example:
  
  -------------------code----------------------
  kill 14321
  -------------------code----------------------
  
  Or, if it doesn’t stop:
  
  -------------------code----------------------
  kill -9 <PID>
  -------------------code----------------------

* **Data directory missing error**:

  -------------------code----------------------
  data/db not found
  -------------------code----------------------

  → Create it manually:

  -------------------code----------------------
  mkdir -p /data/db
  sudo chown -R $(whoami) /data/db
  -------------------code----------------------

---


* ** Data directory /data/db not found.
-------------------code----------------------
NonExistentPath: Data directory /data/db not found.
Create the missing directory or specify another path using --dbpath.
exitCode: 100
-------------------code----------------------

MongoDB is **not running** because it **couldn’t find the default data directory `/data/db`**.
Here’s the key part from your output:

-------------------code----------------------
NonExistentPath: Data directory /data/db not found.
Create the missing directory or specify another path using --dbpath.
exitCode: 100
-------------------code----------------------

Let’s fix that step-by-step on macOS:

---

if we have the DB file before 
-------------------code----------------------
mongod --dbpath /opt/homebrew/var/mongodb
-------------------code----------------------

if not use this instruction
### **1. Create the required data directory**

MongoDB stores its database files in `/data/db` by default.
Create it manually with the following commands:

-------------------code----------------------
sudo mkdir -p /data/db
sudo chown -R $(whoami) /data/db
-------------------code----------------------

Explanation:

* `mkdir -p /data/db` → creates the folder (including any missing parents)
* `chown -R $(whoami)` → gives you permission to read/write in it (MongoDB won’t run otherwise)

---

### **2. Start MongoDB again**

Now rerun:

-------------------code----------------------
mongod
-------------------code----------------------

You should see a long log ending with something like:

-------------------code----------------------
Waiting for connections on port 27017
-------------------code----------------------

That means MongoDB is now running successfully.

---

### **3. (Optional) Specify a custom data directory**

If you’d rather keep MongoDB’s data inside your project or your home folder, you can start it like this:

-------------------code----------------------
mongod --dbpath ~/mongodb-data
-------------------code----------------------

The first time, create that directory:

-------------------code----------------------
mkdir -p ~/mongodb-data
-------------------code----------------------

---

### **4. Verify MongoDB is working**

In a **new terminal tab** (keep `mongod` running), run:

-------------------code----------------------
mongosh
-------------------code----------------------

You should see:

-------------------code----------------------
test>
-------------------code----------------------

That means you’re successfully connected to your MongoDB server.

---

### **Summary**

| Problem                                    | Solution                                             |
| ------------------------------------------ | ---------------------------------------------------- |
| `NonExistentPath: /data/db not found`      | Create `/data/db` or specify `--dbpath`              |
| MongoDB shuts down immediately             | The data directory doesn’t exist or lacks permission |
| Want MongoDB to always start automatically | Use `brew services start mongodb-community@8.2`      |

---

*** 2- Handling Rejected Promises ***
---

### **Handling Unhandled Promise Rejections**

1. **Problem Overview**

   * An *unhandled promise rejection* occurs when a promise fails but its rejection is not properly handled.
   * This usually happens with asynchronous code, either using:

     * **Promise syntax (`then`)** without `catch`
     * **Async/await** without `try/catch`
   * If unhandled, Node.js may terminate the process in future versions, making the server unavailable to clients.

2. **Example in the Genres Module**

   * Current implementation:

     * Uses `await` to fetch genres.
     * No `try/catch` block is used to handle rejected promises.
   * Equivalent in promise syntax:

     -------------------code----------------------
     getGenres()
       .then(data => res.send(data))
       // Missing .catch to handle errors
     -------------------code----------------------

3. **Solution: Add Error Handling**

   * Wrap asynchronous code in a `try` block.
   * Use `catch` to handle exceptions.
   * Send a proper response to the client:

     -------------------code----------------------
     try {
       const genres = await Genre.find();
       res.send(genres);
     } catch (ex) {
       res.status(500).send('Something failed.');
       // Optional: log exception for debugging
       console.error(ex);
     }
     -------------------code----------------------
   * Key points:

     * **Async/await → use `try/catch`.**
     * **Promise `then` → always chain `catch`.**
     * Return appropriate HTTP status code (e.g., `500 Internal Server Error`) and a clear message.

4. **Demonstration Workflow**

   1. Start MongoDB (`mongod`) in one terminal.
   2. Run the Vid.ly Node application in another terminal.
   3. Test API endpoints using Postman:

      * Initially, requests succeed when MongoDB is running.
      * Stop MongoDB during testing to simulate a failure.
      * Send a request to `/api/genres`.
   4. Result:

      * Client receives `500 Internal Server Error` with message `'Something failed.'`
      * Terminal no longer shows unhandled promise rejection.
      * Server process continues running despite the temporary database outage.

5. **Key Takeaways**

   * Proper error handling prevents server crashes.
   * Always log exceptions for later debugging and analysis.
   * Incrementally improve the application by handling errors step by step.

---


*** 3- Express Error Middleware ***
### Lecture Notes: Centralized Error Handling in Express

---

#### 1. Problem with the Current Implementation

* In the previous implementation, each route handler used its own `try-catch` block to handle errors.
* This approach has several issues:

  * If we want to **change the error message** sent to the client, we must update it in **every route handler**.
  * In real-world applications, we often **log exceptions**. If we later decide to change how we log them, we must update **multiple files** again.
* The goal is to **centralize error handling** so that any changes in error handling or logging can be made in **a single place**.

---

#### 2. Express Error-Handling Middleware

* Express provides a **special type of middleware** for handling errors.
* This middleware function is defined with **four parameters**:

  -------------------code----------------------
  function (err, req, res, next) { ... }
  -------------------code----------------------
* It must be **registered after all other middleware** using:

  -------------------code----------------------
  app.use(errorMiddleware);
  -------------------code----------------------
* This ensures that if an error occurs anywhere in the app, it will eventually be passed to this middleware.

---

#### 3. Refactoring Error Handling

1. **In `index.js`**:

   * Register the error-handling middleware **after all other middleware**.
   * Example:

     -------------------code----------------------
     app.use(function (err, req, res, next) {
       // Centralized error-handling logic
     });
     -------------------code----------------------
2. **In `genres.js`** (or any route file):

   * Add the `next` parameter to the route handler.
   * Replace the `catch` logic with:

     -------------------code----------------------
     catch (ex) {
       next(ex);
     }
     -------------------code----------------------
   * This forwards the exception to the centralized error middleware.

---

#### 4. Creating a Dedicated Error Middleware Module

To improve **separation of concerns**, move the error-handling logic to its own file.

1. Create a new file:
   **`middleware/error.js`**

   -------------------code----------------------
   module.exports = function (err, req, res, next) {
     // Handle and log the error
     res.status(500).send('Something failed.');
   };
   -------------------code----------------------

2. In **`index.js`**, import and register it:

   -------------------code----------------------
   const error = require('./middleware/error');
   app.use(error);
   -------------------code----------------------

   Note: Pass the **reference** to the function, not its **execution** — do not use parentheses.

---

#### 5. Benefits of This Design

* **Single point of maintenance**: All error-handling logic is centralized.
* **Better separation of concerns**: Route handlers focus on business logic, not error management.
* **Easier future changes**: Updating logging behavior or error responses only requires modifying one module.

---

#### 6. Remaining Issue

* Each route still contains a **repetitive `try-catch` block**.
* This repetition can be avoided by improving the design further.
* The next lecture will cover how to **eliminate repetitive try-catch blocks** and make error handling even cleaner.

