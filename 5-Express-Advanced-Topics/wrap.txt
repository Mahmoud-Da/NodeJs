*** 1- Introduction ***
**Lecture Notes: Advanced Topics in Express**

**Overview:**
In the previous section, we learned how to build RESTful services using Express. In this section, we will move forward to explore more advanced concepts in Express.

**Topics Covered:**

1. **Middleware** – Understanding how middleware functions work and how to configure them properly in an Express application.
2. **Configuration** – Learning how to handle application settings for different environments (development, production, etc.).
3. **Debugging** – Using debugging tools and techniques to identify and resolve issues in Express applications.
4. **Templating Engines** – Integrating and using templating engines to render dynamic HTML views.
5. **Other Advanced Topics** – Additional Express functionalities to enhance flexibility and maintainability.

**Goal:**
To gain a deeper understanding of Express and learn how to apply its advanced features for building robust and 
maintainable web applications.

*** 2- Middleware ***
**Lecture Notes: Middleware in Express**

**Core Concept:**
One of the most important concepts in Express is **middleware** (or middleware functions). A middleware function is a function that takes a **request** object and either:

1. Returns a response to the client, or
2. Passes control to another middleware function.

---

### **Examples of Middleware Functions**

1. **Route Handler Function:**

   * Every route handler in Express is technically a middleware function.
   * It receives a request object and, in most cases, sends a response back to the client.
   * When it sends a response, it **terminates the request-response cycle**.

2. **`express.json()` Middleware:**

   * The `express.json()` method returns a middleware function.
   * This middleware reads incoming requests and, if the body contains JSON data, it parses it and sets it on `request.body`.
   * It does not terminate the cycle but instead passes control to the next middleware function.

---
**Request Processing Pipeline** in Express:

-------------------code----------------------
          ┌──────────────────────────────┐
          │        Client Request        │
          └──────────────┬───────────────┘
                         │
                         ▼
              ┌─────────────────────┐
              │ Middleware #1       │
              │ (e.g. express.json) │
              └─────────┬───────────┘
                        │
                        ▼
              ┌─────────────────────┐
              │ Middleware #2       │
              │ (e.g. Logger, Auth) │
              └─────────┬───────────┘
                        │
                        ▼
              ┌─────────────────────┐
              │ Route Handler       │
              │ (Sends Response)    │
              └─────────┬───────────┘
                        │
                        ▼
          ┌──────────────────────────────┐
          │       Client Response        │
          └──────────────────────────────┘
-------------------code----------------------

**Explanation:**

* Each incoming request from the client travels through a sequence of middleware functions.
* Each middleware can process or modify the request and decide whether to pass it on or send a response.
* The final middleware (route handler) usually sends the response and ends the cycle.


### **Request Processing Pipeline**

When a request reaches the server, it goes through a **pipeline** known as the **request processing pipeline**.

* This pipeline contains one or more middleware functions.
* Each middleware either:

  * Terminates the cycle by sending a response, or
  * Passes control to the next middleware.

**Example Flow:**

1. The first middleware (`express.json()`) parses the request body and attaches it to `request.body`.
2. Since it doesn’t terminate the cycle, it passes control to the next middleware.
3. The next middleware (the route handler) uses the populated `request.body` to process the request and sends a response, terminating the cycle.

-------------------code----------------------
 ┌──────────────────────────┐
 │      Incoming Request     │
 └─────────────┬─────────────┘
               │
               ▼
 ┌──────────────────────────┐
 │ express.json() Middleware│
 │  - Parses JSON body      │
 │  - Adds data to req.body │
 └─────────────┬─────────────┘
               │ next()
               ▼
 ┌──────────────────────────┐
 │  Custom Middleware       │
 │  (e.g., logger, auth)    │
 │  - Logs or validates     │
 │  - May end or continue   │
 └─────────────┬─────────────┘
               │ next()
               ▼
 ┌──────────────────────────┐
 │     Route Handler        │
 │  - Processes request     │
 │  - Sends response        │
 │  - Ends cycle            │
 └─────────────┬─────────────┘
               │
               ▼
 ┌──────────────────────────┐
 │     Response Sent to     │
 │         Client           │
 └──────────────────────────┘

-------------------code----------------------
---

### **Built-in and Custom Middleware**

* Express provides several built-in middleware functions.
* Developers can also create **custom middleware** functions to handle **cross-cutting concerns**, such as:

  * Logging
  * Authentication
  * Authorization
  * Input validation, etc.

---

### **Summary**

An Express application is essentially a collection of middleware functions arranged in a specific order to process incoming requests. Each middleware can modify the request, send a response, or pass control to the next function.

**Next Topic:**
Creating custom middleware functions in Express.

*** 3- Creating Custom Middleware ***
**Lecture Notes: Creating Custom Middleware Functions in Express**

---

### **1. Purpose of Custom Middleware**

Custom middleware functions allow developers to handle cross-cutting concerns such as logging, authentication, and error handling. In Express, you can define and install your own middleware functions in the **request processing pipeline**.

---

### **2. Adding a Middleware Function**

You can add middleware to the pipeline using the `app.use()` method.

**Example:**

-------------------code----------------------
app.use(function (req, res, next) {
  console.log('Logging...');
  next();
});
-------------------code----------------------

**Explanation:**

* The function receives three parameters:

  * `req` → request object
  * `res` → response object
  * `next` → reference to the next middleware function in the pipeline
* After performing its task (for example, logging), it **must call `next()`** to pass control to the next middleware.
* If `next()` is not called and the middleware doesn’t send a response, the request will hang because the request-response cycle is not terminated.

---

### **3. Example of Middleware Execution Order**

When multiple middleware functions are defined, Express executes them in the order they are added.

-------------------code----------------------
app.use(function (req, res, next) {
  console.log('Logging...');
  next();
});

app.use(function (req, res, next) {
  console.log('Authenticating...');
  next();
});
-------------------code----------------------

**Execution flow for a request:**

1. The **logging** middleware runs first.
2. The **authentication** middleware runs next.
3. Finally, the **route handler** (which is also a middleware function) runs and sends the response.

This demonstrates that middleware functions are called **in sequence**.

---

### **4. Structuring Middleware Code**

To keep the code clean, avoid defining all middleware directly in `index.js`.
Instead, define each middleware in its **own module**.

**Example: `logger.js`**

-------------------code----------------------
function log(req, res, next) {
  console.log('Logging...');
  next();
}

module.exports = log;
-------------------code----------------------

**In `index.js`:**

-------------------code----------------------
const logger = require('./logger');
app.use(logger);
-------------------code----------------------

**Explanation:**

* `logger.js` exports a single function (`log`) which is the middleware.
* The main file (`index.js`) imports and installs it using `app.use(logger)`.

---

### **5. Understanding Built-in Middleware**

When you use built-in middleware like `express.json()`, it also returns a function with the same signature:

-------------------code----------------------
(req, res, next)
-------------------code----------------------

This function parses the incoming request body, converts it to a JSON object, attaches it to `req.body`, and then calls `next()` to pass control to the next middleware.

---

### **6. Summary**

* Middleware functions can either **handle** the request or **pass it** to the next function.
* Use `next()` to continue the request flow.
* Organize custom middleware functions in **separate files** for better readability and maintainability.
* Express applications are built as a sequence (pipeline) of middleware functions.

**Exercise:**
Create a second middleware function for authentication in a separate module and integrate it into the pipeline, following the same pattern as the logger middleware.

*** 4- Built-in Middleware ***
**Lecture Notes: Built-in Middleware in Express**

---

### **1. Overview**

In the previous lecture, we learned how to create **custom middleware functions**.
Now, we will explore **built-in middleware** functions that come with Express. These are pre-defined functions designed to handle common tasks like parsing requests and serving static files.

---

### **2. Built-in Middleware Functions**

#### **a. `express.json()`**

* Parses incoming requests with **JSON payloads**.
* If the body contains valid JSON, it populates `req.body` with a JavaScript object.
* Commonly used when working with REST APIs that send and receive JSON data.

-------------------code----------------------
app.use(express.json());
-------------------code----------------------

---

#### **b. `express.urlencoded()`**

* Parses incoming requests with **URL-encoded payloads**.
* This is typically used when submitting data from traditional **HTML forms**.
* Example body:

  -------------------code----------------------
  key1=value1&key2=value2
  -------------------code----------------------
* After parsing, it also populates `req.body` with a JavaScript object.
* Example usage:

-------------------code----------------------
app.use(express.urlencoded({ extended: true }));
-------------------code----------------------

**Explanation:**

* `{ extended: true }` allows Express to parse **arrays and complex objects** using the URL-encoded format.
* If this option is omitted, Express will display a **deprecation warning** in the console:

  -------------------code----------------------
  body-parser deprecated undefined extended: provide extended option
  -------------------code----------------------

**Example Test (Postman):**

1. Set method to `POST`.
2. URL: `http://localhost:3000/api/courses`
3. Body type: `x-www-form-urlencoded`
4. Key: `name`, Value: `My Course`
5. Send request → A new course is successfully created and the body is parsed correctly.

---

#### **c. `express.static()`**

* Used to **serve static files** such as HTML, CSS, images, and text documents.
* You specify a folder (e.g., `public`) that contains these assets.

-------------------code----------------------
app.use(express.static('public'));
-------------------code----------------------

**Example:**

1. Create a folder named `public`.
2. Add a file inside it, for example `readme.txt` with the content:

   -------------------code----------------------
   This is a readme file.
   -------------------code----------------------
3. Visit the file in the browser at:

   -------------------code----------------------
   http://localhost:3000/readme.txt
   -------------------code----------------------

**Note:**
The URL does not include the `public` folder name; static files are served from the **root path**.

---

### **3. Summary**

| Middleware Function    | Purpose                                 | Example                                           | Notes                  |
| ---------------------- | --------------------------------------- | ------------------------------------------------- | ---------------------- |
| `express.json()`       | Parses JSON request bodies              | `app.use(express.json())`                         | Used for APIs          |
| `express.urlencoded()` | Parses URL-encoded form data            | `app.use(express.urlencoded({ extended: true }))` | Used for HTML forms    |
| `express.static()`     | Serves static files (CSS, images, etc.) | `app.use(express.static('public'))`               | Files served from root |

---

### **4. Next Topic**

In the next lecture, we will study **third-party middleware** and how to integrate them into an Express application for additional features and functionality.

*** 5- Third-party Middleware ***
**Lecture Notes: Third-Party Middleware in Express**

---

### **1. Introduction**

Express provides many **third-party middleware** that can be added to extend the functionality of your applications.
You can find a list of them on the official Express website under **Resources → Middleware**.

However, it is important to note that **each middleware function adds overhead** to the request processing pipeline.
Only include middleware that provides necessary functionality for your application; unnecessary middleware can reduce performance.

---

### **2. Best Practice Middleware: Helmet**

**Purpose:**
Helmet helps **secure your Express applications** by setting various **HTTP headers** automatically.

**Installation:**

-------------------code----------------------
npm install helmet
-------------------code----------------------

**Usage in Express:**

-------------------code----------------------
const helmet = require('helmet');
app.use(helmet());
-------------------code----------------------

**Explanation:**

* `helmet()` returns a middleware function.
* When used with `app.use()`, it enhances security by adjusting response headers.
* To understand the internal details of Helmet and available configuration options, consult its official documentation.

**Example:**
Helmet can help prevent attacks such as cross-site scripting (XSS) and clickjacking by configuring secure headers automatically.

---

### **3. Logging Middleware: Morgan**

**Purpose:**
Morgan is used for **logging HTTP requests** in Express applications. It helps developers monitor and debug request activity.

**Installation:**

-------------------code----------------------
npm install morgan
-------------------code----------------------

**Usage in Express:**

-------------------code----------------------
const morgan = require('morgan');
app.use(morgan('tiny'));
-------------------code----------------------

**Explanation:**

* `morgan()` returns a middleware function that logs details about incoming HTTP requests.
* The `'tiny'` format provides a minimal log output that includes:

  * HTTP method (GET, POST, etc.)
  * Request URL
  * Status code (e.g., 200 for success)
  * Response time

**Example Output (Tiny Format):**

-------------------code----------------------
GET /api/courses 200 4.351 ms - 84
-------------------code----------------------

This indicates:

* A GET request was made to `/api/courses`
* The response status was 200 (OK)
* It took about 4 milliseconds
* The response size was 84 bytes

---

### **4. Logging Options**

Morgan supports several predefined logging formats:

* `tiny` – minimal and clean
* `combined` – detailed with more request and user-agent information
* `common`, `dev`, and others

You can find the full list of formats in the Morgan documentation.

Additionally, you can configure Morgan to **write logs to a file** instead of printing them to the console.
However, writing logs to disk can **slow down request processing**, so it’s best used in **development or debugging environments**, not in production.

**Example for writing logs to a file:**

-------------------code----------------------
const fs = require('fs');
const path = require('path');
const accessLogStream = fs.createWriteStream(path.join(__dirname, 'access.log'), { flags: 'a' });
app.use(morgan('combined', { stream: accessLogStream }));
-------------------code----------------------

---

### **5. Performance Considerations**

* Every middleware adds processing time to each request.
* Avoid unnecessary middleware in production.
* Enable certain middleware (like Morgan) only when needed, using configuration logic or environment variables.

---

### **6. Summary**

| Middleware | Purpose                             | Example                   | Notes                                       |
| ---------- | ----------------------------------- | ------------------------- | ------------------------------------------- |
| `helmet()` | Secures app by setting HTTP headers | `app.use(helmet())`       | Recommended for production                  |
| `morgan()` | Logs HTTP requests                  | `app.use(morgan('tiny'))` | Use selectively for debugging or monitoring |

---

### **7. Next Topic**

In the next lecture, we will explore how to handle **different environments** (development, testing, and production) and how to configure middleware or features differently depending on the environment.

*** 6- Environments ***
### Lecture Notes: Working with Environments in Node.js

#### 1. **Purpose of Environment Awareness**

In larger or enterprise-level applications, it’s important to know the environment where your code is running.
Common environments include:

* **Development**: For local testing and debugging.
* **Testing**: For automated tests and QA.
* **Staging**: A pre-production environment that mimics production.
* **Production**: The live environment serving users.

You may want to **enable or disable certain features** depending on the environment.
Example: Enable HTTP request logging only in development but not in production.

---

#### 2. **Using the `process` Object**

* `process` is a **global object** in Node.js that provides access to the current process.
* It includes a property called `env`, which stores environment variables.

-------------------code----------------------
process.env.NODE_ENV
-------------------code----------------------

* `NODE_ENV` is a **standard environment variable** used to define the current environment.
* If it’s not set, the value is `undefined`.

You can set it manually from the terminal:

* On **Mac/Linux**:

  -------------------code----------------------
  export NODE_ENV=production
  -------------------code----------------------
* On **Windows**:

  -------------------code----------------------
  set NODE_ENV=production
  -------------------code----------------------

---

#### 3. **Using the `app` Object in Express**

The Express `app` object also provides an alternative method to get environment information:

-------------------code----------------------
app.get('env')
-------------------code----------------------

* Internally, it checks `process.env.NODE_ENV`.
* If `NODE_ENV` is not set, it defaults to **"development"**.

**Example:**

-------------------code----------------------
console.log(`Node environment: ${process.env.NODE_ENV}`);
console.log(`App environment: ${app.get('env')}`);
-------------------code----------------------

Output when no variable is set:

-------------------code----------------------
Node environment: undefined
App environment: development
-------------------code----------------------

---

#### 4. **Conditional Logic Based on Environment**

You can use conditional statements to enable or disable features depending on the environment.

**Example: Enable Morgan only in development**

-------------------code----------------------
if (app.get('env') === 'development') {
  app.use(morgan('tiny'));
  console.log('Morgan enabled...');
}
-------------------code----------------------

---

#### 5. **Testing Environment Switching**

1. **In Development (default)**:

   * Run the app without setting `NODE_ENV`.
   * Output:

     -------------------code----------------------
     Morgan enabled...
     Listening on port 3000...
     -------------------code----------------------

2. **In Production**:

   * Stop the app (`Ctrl + C`).
   * Set `NODE_ENV` to `production`.
   * Run again:

     -------------------code----------------------
     Listening on port 3000...
     -------------------code----------------------
   * Notice: Morgan is not enabled.

---

#### 6. **Summary**

* Use `process.env.NODE_ENV` or `app.get('env')` to check the environment.
* By default, `app.get('env')` returns `"development"`.
* You can conditionally enable features like logging based on the environment.
* Setting environment variables differs between operating systems.

---

*** 7- Configuration ***
---

## **Lecture Notes: Configuration Management in Express**

### **1. Overview**

In this lecture, we learn how to store and manage configuration settings for an Express application and how to override them depending on the environment (development, production, etc.).
This builds on the previous lecture about detecting the environment in which an application is running.

---

### **2. Importance of Environment-Based Configuration**

* Different environments (development, production, testing) often require different settings.
* Example:

  * **Development:** may use a local database or mail server.
  * **Production:** uses live servers and secure credentials.
* Therefore, configuration settings should be flexible and environment-dependent.

---

### **3. Configuration Management Packages**

There are several Node.js packages for managing configuration:

#### **a. `rc` Package**

* Very popular (over 11 million downloads/month).
* However, it has several issues and less elegant design.

#### **b. `config` Package**

* Preferred package by the instructor.
* Cleaner, simpler, and has an active community.
* Download count: ~600,000 per month.
* URL: `npmjs.com/package/config`.

---

### **4. Installing and Setting Up `config`**

-------------------code----------------------
npm install config
-------------------code----------------------

**Folder Structure:**

-------------------code----------------------
project/
│
├── config/
│   ├── default.json
│   ├── development.json
│   ├── production.json
│   └── custom-environment-variables.json
│
└── index.js
-------------------code----------------------

---

### **5. Creating Configuration Files**

#### **a. `default.json`**

Defines base configuration settings used across all environments.

-------------------code----------------------
{
  "name": "my express app"
}
-------------------code----------------------

#### **b. `development.json`**

Overrides or extends default settings for development.

-------------------code----------------------
{
  "name": "my express app development",
  "mail": {
    "host": "dev-mail-server"
  }
}
-------------------code----------------------

#### **c. `production.json`**

Overrides or extends default settings for production.

-------------------code----------------------
{
  "name": "my express app production",
  "mail": {
    "host": "prod-mail-server"
  }
}
-------------------code----------------------

---

### **6. Using Configuration in Code**

**index.js:**

-------------------code----------------------
const config = require('config');

console.log(`Application Name: ${config.get('name')}`);
console.log(`Mail Server: ${config.get('mail.host')}`);
-------------------code----------------------

---

### **7. Running the Application by Environment**

#### **Development Environment**

-------------------code----------------------
export NODE_ENV=development
node index.js
-------------------code----------------------

Output:

-------------------code----------------------
Application Name: my express app development
Mail Server: dev mail server
-------------------code----------------------

#### **Production Environment**

-------------------code----------------------
export NODE_ENV=production
node index.js
-------------------code----------------------

Output:

-------------------code----------------------
Application Name: my express app production
Mail Server: prod mail server
-------------------code----------------------

---

### **8. Handling Secrets (Passwords, Keys, etc.)**

#### **Why Not Store in Config Files**

* Sensitive data like database passwords should not be stored in config files.
* Risk: credentials can be exposed in version control repositories.

#### **Using Environment Variables**

Define secrets via terminal or hosting platform:

-------------------code----------------------
export APP_PASSWORD=1234
-------------------code----------------------

---

### **9. Mapping Environment Variables**

Create `custom-environment-variables.json` in the config folder:

-------------------code----------------------
{
  "mail": {
    "password": "APP_PASSWORD"
  }
}
-------------------code----------------------

Now, `config` automatically maps the environment variable to the configuration key.

**index.js:**

-------------------code----------------------
console.log(`Mail Password: ${config.get('mail.password')}`);
-------------------code----------------------

**Run the app:**

-------------------code----------------------
node index.js
-------------------code----------------------

Output:

-------------------code----------------------
Mail Password: 1234
-------------------code----------------------

---

### **10. Config Package Summary**

* Reads settings from multiple sources:

  * JSON configuration files
  * Environment variables
  * Command-line arguments
* Provides a clean and consistent structure for managing settings.
* Encourages secure and environment-specific configurations.

---

### **11. Key Takeaways**

* Use `config` package for flexible configuration management.
* Separate configuration files by environment.
* Store secrets in environment variables, not configuration files.
* Access settings easily using `config.get('property')`.

---


*** 8- Debugging ***
## **Lecture Notes: Debugging with the `debug` Module in Node.js**

### **1. The Problem with `console.log`**

* Developers often use `console.log()` for debugging.
* However, this approach has several drawbacks:

  * You must manually delete or comment out logs after debugging.
  * If needed again later, you must rewrite or uncomment them.
  * It clutters the code and is time-consuming to manage.

**Conclusion:**
`console.log` is not efficient for long-term debugging or managing logs in different environments.

---

### **2. The `debug` Package**

The `debug` package provides a more flexible and powerful logging system.

**Advantages:**

* Enables or disables debugging through environment variables (no code modification needed).
* Supports multiple namespaces (e.g., `app:startup`, `app:db`).
* Allows selective viewing of debugging information.
* Automatically color-codes logs by namespace for readability.

---

### **3. Installing the Package**

-------------------code----------------------
npm install debug
-------------------code----------------------

---

### **4. Using `debug` in Code**

**Example setup in `index.js`:**

-------------------code----------------------
const debug = require('debug')('app:startup');
const dbDebugger = require('debug')('app:db');

// Application startup message
debug('Application is starting...');

// Simulated database operation
dbDebugger('Connected to the database...');
-------------------code----------------------

**Explanation:**

* `require('debug')` returns a function.
* Calling it with a namespace (e.g., `'app:startup'`) returns another function that logs messages for that namespace.
* Each namespace represents a specific category of logs (startup, database, API, etc.).

---

### **5. Enabling and Disabling Debug Output**

#### **a. Enable a Single Namespace**

To display messages for a specific namespace:

-------------------code----------------------
export DEBUG=app:startup
node index.js
-------------------code----------------------

**Output:**

-------------------code----------------------
app:startup Application is starting...
-------------------code----------------------

#### **b. Disable All Debugging**

To hide all debugging logs:

-------------------code----------------------
export DEBUG=
node index.js
-------------------code----------------------

No debug output will appear.

#### **c. Enable Multiple Namespaces**

To show logs from multiple namespaces:

-------------------code----------------------
export DEBUG=app:startup,app:db
node index.js
-------------------code----------------------

**Output:**

-------------------code----------------------
app:startup Application is starting...
app:db Connected to the database...
-------------------code----------------------

#### **d. Enable All Namespaces Using Wildcard**

To show all debug logs under a base namespace:

-------------------code----------------------
export DEBUG=app:*
node index.js
-------------------code----------------------

---

### **6. Shortcut for Setting Environment Variables**

Instead of setting environment variables separately, you can define and run in one line:

-------------------code----------------------
DEBUG=app:db node index.js
-------------------code----------------------

or (with nodemon)

-------------------code----------------------
DEBUG=app:startup nodemon index.js
-------------------code----------------------

This runs the app while enabling logs only for the `app:startup` namespace.

---

### **7. Simplifying Debuggers**

If a file only needs one debugger, you can simplify the code:

-------------------code----------------------
const debug = require('debug')('app:startup');

debug('Application is starting...');
-------------------code----------------------

No need to create multiple debugger instances unless necessary.

---

### **8. Benefits of Using `debug`**

* Cleaner, maintainable debugging approach.
* Full control over logging visibility without modifying code.
* Organized logs by namespace.
* Color-coded output for readability.
* Works across all environments (development, testing, production).

---

### **9. Key Takeaways**

* Avoid relying on `console.log()` for debugging in production code.
* Use the `debug` package for environment-based, flexible logging.
* Define clear namespaces for different parts of your application.
* Control log visibility through the `DEBUG` environment variable.

---

*** 9- Templating Engines ***
## **Lecture Notes: Using Templating Engines in Express**

### **1. Overview**

* So far, we have been returning **JSON objects** in responses.
* However, sometimes we need to return **HTML markup** to the client.
* In such cases, we use a **templating engine** to generate dynamic HTML.

---

### **2. What Is a Templating Engine?**

A templating engine allows you to:

* Embed dynamic data into HTML pages.
* Render and return complete HTML markup to the client.
* Keep your code cleaner and separate logic from presentation.

**Popular templating engines for Express:**

* **Pug** (formerly called Jade)
* **Mustache**
* **EJS**

Each engine has its own syntax and style for generating HTML.

---

### **3. Installing Pug**

-------------------code----------------------
npm install pug
-------------------code----------------------

---

### **4. Setting Up Pug in Express**

In your `index.js` (or main app file):

-------------------code----------------------
const express = require('express');
const app = express();

// Set the view engine to pug
app.set('view engine', 'pug');

// Optional: specify the folder for views (default is './views')
app.set('views', './views');
-------------------code----------------------

**Explanation:**

* `app.set('view engine', 'pug')`: tells Express to use Pug for rendering views.
* `app.set('views', './views')`: defines where templates are stored (optional, default is `views` folder in the root).

---

### **5. Creating a View Template**

**File path:** `views/index.pug`

**Example template:**

-------------------code----------------------
html
  head
    title= title
  body
    h1= message
-------------------code----------------------

**Explanation:**

* Pug uses indentation instead of opening and closing HTML tags.
* Variables like `title` and `message` will be replaced dynamically when rendering.

---

### **6. Rendering the Template in a Route**

Replace your existing route:

-------------------code----------------------
app.get('/', (req, res) => {
  res.send('Hello World');
});
-------------------code----------------------

With a new render-based response:

-------------------code----------------------
app.get('/', (req, res) => {
  res.render('index', { title: 'My Express App', message: 'Hello' });
});
-------------------code----------------------

**Explanation:**

* `res.render(viewName, data)`:

  * `viewName`: the name of the template file (without extension).
  * `data`: an object containing key-value pairs used in the template.

---

### **7. Running the Application**

Start your application:

-------------------code----------------------
node index.js
-------------------code----------------------

Then visit:

-------------------code----------------------
http://localhost:3000
-------------------code----------------------

**Result:**

* The browser displays a web page rendered from `index.pug`.
* You can view the HTML source to confirm it was converted to standard HTML:

  -------------------code----------------------
  <html>
    <head>
      <title>My Express App</title>
    </head>
    <body>
      <h1>Hello</h1>
    </body>
  </html>
  -------------------code----------------------

---

### **8. When to Use a Templating Engine**

* Use a templating engine when building **server-rendered web applications**.
* You can dynamically generate and serve full HTML pages.

**However:**

* For **RESTful APIs** or **backend services** that serve frontend clients (React, Angular, etc.), templating engines are not needed.
* Those applications typically return **JSON** instead of HTML.

---

### **9. Summary**

* Use a templating engine to render HTML dynamically.
* Express supports multiple engines such as Pug, Mustache, and EJS.
* Pug offers a clean, indentation-based syntax.
* `res.render()` replaces `res.send()` when sending HTML responses.
* For backend RESTful APIs, templating engines are optional and usually unnecessary.

---



*** 10- Database Integration ***
## **Lecture Notes: Database Integration in Node and Express**

### **1. Introduction**

* This lecture provides an overview of how to integrate databases with **Node.js** and **Express**.
* A detailed explanation of working with **MongoDB** and **Mongoose** will be covered later in a dedicated section.
* The goal here is to understand the various **database integration options** available in Express applications.

---

### **2. Database Integration Options**

Express does not limit you to a single database; it can work with almost any database through the use of **drivers** or **ORM/ODM libraries**.

**Common Databases Supported:**

* **Cassandra**
* **Couchbase**
* **MySQL**
* **MongoDB**
* **Oracle**
* **Redis**
* **SQL Server**
* **Elasticsearch**

Each database type has its own **driver** (a Node.js package) that enables communication between the application and the database.

---

### **3. Installing and Using a Database Driver**

#### **Example: MongoDB**

To connect to MongoDB, you first install the official driver:

-------------------code----------------------
npm install mongodb
-------------------code----------------------

Then in your code:

-------------------code----------------------
const { MongoClient } = require('mongodb');

const url = 'mongodb://localhost:27017';
const client = new MongoClient(url);

async function connect() {
  await client.connect();
  console.log('Connected successfully to MongoDB');
  const db = client.db('mydatabase');
  const collection = db.collection('users');
}
connect();
-------------------code----------------------

**Explanation:**

* The MongoDB driver provides methods to:

  * Connect to a database.
  * Access collections.
  * Perform CRUD (Create, Read, Update, Delete) operations.

The same general steps apply to other databases:

1. Install the corresponding driver package via npm.
2. Import and configure it in your application.
3. Use its API to connect and query data.

---

### **4. Working with MongoDB via Mongoose**

Although the native MongoDB driver works well, **Mongoose** is often preferred for application development because it:

* Simplifies working with MongoDB.
* Provides a higher-level API.
* Includes schema definitions and data validation.
* Manages relationships and complex queries more efficiently.

**Installation:**

-------------------code----------------------
npm install mongoose
-------------------code----------------------

**Example usage (later covered in detail):**

-------------------code----------------------
const mongoose = require('mongoose');

mongoose.connect('mongodb://localhost/mydatabase')
  .then(() => console.log('Connected to MongoDB via Mongoose'))
  .catch(err => console.error('Connection failed', err));
-------------------code----------------------

---

### **5. Summary**

* Node and Express can integrate with a wide variety of databases.
* Integration typically involves:

  1. Installing the database driver.
  2. Requiring and configuring it in the app.
  3. Using its API to connect and interact with data.
* For **MongoDB**, the preferred approach is to use **Mongoose** instead of the native driver, due to its cleaner and more feature-rich design.
* A detailed exploration of MongoDB and Mongoose will follow in a later section.

---

